<template>
	<!-- Pencil icon made by <a href="http://appzgear.com" title="Appzgear">Appzgear</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>. Licensed under <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0">CC BY 3.0</a> -->
	<!-- Cursor icon adapted from cursor by Gentleface.com, licensed under Creative Commons Attribution Non-commercial (by-nc) -->
	<style>
		#pianoroll {
			position: relative;
			left: 100px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			width: calc(100% - 350px);
			height: 580px;
			overflow: scroll;
		}
		#bgCanvas {
			position: absolute;
			left: 0px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
		#fgCanvas {
			position: absolute;
			left: 0px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
		#appkeyboard {
			width: 100px;
			float: left;
		}
		#noteproperties {
			display: none;
			background: #252477;
			float: right;
			width: 270px;
			height: 580px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#notepropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			background: slateblue;
		}
		#noteproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#groupproperties {
			display: none;
			background: #252477;
			float: right;
			width: 270px;
			height: 580px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#grouppropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			background: slateblue;
		}
		#groupproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#trackproperties {
			display: block;
			background: #252477;
			float: right;
			width: 270px;
			height: 580px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#trackpropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			background: slateblue;
		}
		#trackproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
		}
		.biggertext{
			font-family: 'Oswald';
			font-size: 20px;
			opacity: 0.85;
			color: #FFF;
		}
		.shorttextbox {
			width: 50px;
		}
		.slider {
			position: relative;
			top: 5px;
			width: 110px !important;
		}
	</style>
	<div id="noteproperties">
		<div id="notepropertiesHeader"><h3>Note Properties</h3></div>
		<p>Start <input type="text" id="note_start"></input></p>
		<p>Length <input type="text" id="note_length"></input></p>
		<p>Auto-adjust <input type="checkbox" id="note_autoadjust" checked></p>
	</div>
	<div id="groupproperties">
		<div id="grouppropertiesHeader"><h3>Group Properties</h3></div>
		<p>Start <input type="text" id="group_start"></input></p>
		<p>Length <input type="text" id="group_length"></input></p>
		<p>Auto-adjust <input type="checkbox" id="group_autoadjust" checked></p>
	</div>
	<div id="trackproperties">
		<div id="trackpropertiesHeader"><h3>Track Properties</h3></div>
		<p>Cutoff		<input class="slider" id="cutoff" type="range" min="-12" max="72" step="1" value="24" />     <input id="cutoff_text" type="text" class="shorttextbox" value="24"></input></p> <!-- cutoff, -36 to 36 (singlestepped) -->
		<p>Resonance	<input class="slider" id="resonance" type="range" min="0" max="24" step="1" value="6" />     <input id="resonance_text" type="text" class="shorttextbox" value="6"></input></p> <!-- resonance (res), 0 to 24 (singlestepped) -->
		<p>Mod			<input class="slider" id="mod" type="range" min="0" max="200" step="1" value="30" />         <input id="mod_text" type="text" class="shorttextbox" value="3"></input></p> <!-- depth, 0 to 20 (singlestepped) -->
		<p>Attack		<input class="slider" id="attack" type="range" min="0" max="100" step="1" value="0" />       <input id="attack_text" type="text" class="shorttextbox" value="0"></input></p> <!-- attack, 0 to 5 (100 steps) -->
		<p>Decay		<input class="slider" id="decay" type="range" min="0" max="100" step="1" value="5" />        <input id="decay_text" type="text" class="shorttextbox" value="0.5"></input></p> <!-- decay, 0 to 5 (100 steps) -->
		<p>Release time <input class="slider" id="release_time" type="range" min="0" max="200" step="1" value="10"/> <input id="release_time_text" type="text" class="shorttextbox" value="0.5"></input></p> <!-- release time, 0 to 5 (100 steps) -->
		<p>Feedback		<input class="slider" id="feedback" type="range" min="0" max="100" step="1" value="50" />    <input id="feedback_text" type="text" class="shorttextbox" value="0.5"></input></p> <!-- feedback, 0 to 1 (100 steps) -->
		<p>Echo			<input class="slider" id="echo" type="range" min="0" max="100" step="1" value="50" />        <input id="echo_text" type="text" class="shorttextbox" value="0.5"></input></p> <!-- echo, 0 to 1 (100 steps) -->
		<p>Echo Enabled <input id="echoEnabled" type="checkbox" /></p>
	</div>
	<denoto-keyboard id="appkeyboard" keycount="24"></denoto-keyboard>
	<div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
	<!--<canvas id="bgCanvas" width="32767" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas> MAX WIDTH CANVAS -->
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
</template>
<!-- Include sorted list for the noteset -->
<script src="<%= asset_path("SortedList.js")%>"></script>

<script>
    (function(){
    	// ticks per pixel (AKA zoom level)
    	var TPP = 4;

		// declare a persistent canvas
		var canvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var pianorollPrototype = Object.create(HTMLElement.prototype);

		// keep track of preview notes
		var preview;
		var previewSet;
		var status;

		// keep track of displayed notes
		var noteset = new NoteSet();

		// current cursor mode. Options: draw, select
		var mode = 'draw';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		pianorollPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			// give the noteset access to the host in order to throw events
			noteset.host = root.host;

			// keep track of note pane fields
			var notepane = root.getElementById("noteproperties");
			var note_start = root.getElementById("note_start");
			var note_length = root.getElementById("note_length");
			var note_autoadjust = root.getElementById("note_autoadjust");

			// keep track of group pane fields
			var grouppane = root.getElementById("groupproperties");
			var group_start = root.getElementById("group_start");
			var group_length = root.getElementById("group_length");
			var group_autoadjust = root.getElementById("group_autoadjust");

			// keep track of track pane fields
			var trackpane = root.getElementById("trackproperties");

			// get the canvas info
			canvas = root.querySelector('#bgCanvas');
			var context = canvas.getContext("2d");
			var width = canvas.getAttribute("width");
			var height = canvas.getAttribute("height");

			// set up the measure bars, etc.
			drawCanvas(context, width, height, TPP);

			canvas = root.querySelector('#fgCanvas');
			context = canvas.getContext("2d");

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					var keyEvent = new CustomEvent("denoto-selectmode", {"detail": "select"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 100){ // pressed 'd'
					var keyEvent = new CustomEvent("denoto-drawmode", {"detail": "draw"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 120){ // TODO: change to use the real delete key instead of 'x'
					if(typeof noteset.currentNote !== 'undefined'){
						eraseNote(context, noteset.currentNote, TPP);

						// dispatch the event so that listeners can handle it
						noteset.RemoveNote(noteset.currentNote);
						noteset.currentNote = undefined;
						noteset.previousNote = undefined;
					}
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							eraseNote(context, noteset.selectedSet[index], TPP);
							noteset.RemoveNote(noteset.selectedSet[index]);
						}
					}
				}

				// handle if any panes need to change
				showPanes();
			});

			document.addEventListener('denoto-zoomin', function(){
				TPP = TPP / 2;
				if(TPP < 1)
					TPP = 1;

				// redraw the guiding lines, etc.
				redrawCanvas(root, TPP);

				// redraw the notes with their new location/sizes
				redrawAllNotes(root, noteset, TPP);
			});

			document.addEventListener('denoto-zoomout', function(){
				TPP = TPP * 2;
				if(TPP > 8)
					TPP = 8;

				// redraw the guiding lines, etc.
				redrawCanvas(root, TPP);

				// redraw the notes with their new location/sizes
				redrawAllNotes(root, noteset, TPP);
			});

			document.addEventListener('denoto-selectmode', function(){
				mode = 'select';
				//canvas.style.cursor = 'auto';
				canvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
			});

			document.addEventListener('denoto-drawmode', function(){
				mode = 'draw';
				//canvas.style.cursor = 'cell';
				canvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

				drawNote(context, noteset.currentNote, TPP);

				noteset.earliestSelected = undefined;
				noteset.latestSelected = undefined;
				for(var index in noteset.selectedSet){
					drawNote(context, noteset.selectedSet[index], TPP);
				}
				if(noteset.selectedSet.length > 0){
					noteset.selectedSet = new Array();
				}

				noteset.currentNote = undefined;
				noteset.previousNote = undefined;
			});

			canvas.addEventListener('mousedown', function(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the piano roll
				mouseY = mouseY - mouseY % 23 + 3;

				var keyValue = (mouseY - 3) / 23;
				var key = keyValue % 12;
				var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#6666AA" : "#AAAAFF";
				//var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#252477" : "#A7BEE3";
				var outlinecolor = (color === "#6666AA") ? "#000044" : "#222266";
				//var outlinecolor = "#000000";

				if(mode === 'select'){

					if(!event.ctrlKey && noteset.selectedCount < 2){
						drawNote(context, noteset.currentNote, TPP);
					}

					preview = noteset.SelectNote({keyValue: keyValue, tickstart: mouseX * TPP});

					if(typeof preview === 'undefined'){
						status = undefined;
						canvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';

						// deselect any notes
						drawNote(context, noteset.currentNote, TPP);
						noteset.previousNote = undefined;
						noteset.currentNote = undefined;

						// clear the note properties in the window
						note_start.value = "";
						note_length.value = "";
					} else {
						preview = new Note(preview);

						if(!event.ctrlKey || typeof noteset.selectedSet[preview.ID] === 'undefined'){
							if(preview.tickduration !== 0){
								// display the note's properties in the window
								note_start.value = preview.tickstart;
								note_length.value = preview.tickduration;
							} else {
								// don't display properties for notes that can't exist in the noteset
								note_start.value = "";
								note_length.value = "";
							}
						}

						// deselect the selected set if the user clicked outside of it without ctrl held down
						if(!event.ctrlKey && typeof noteset.selectedSet[preview.ID] === 'undefined'){
							// redraw the formerly-selected notes as deselected
							for(var index in noteset.selectedSet){
								drawNote(context, noteset.selectedSet[index], TPP);
							}

							// reset the selected set to be empty
							noteset.selectedSet = new Array();
							noteset.selectedCount = 0;
						}

						// set up a new set of preview notes
						previewSet = new Array();
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined'){
								previewSet[index] = new Note(noteset.selectedSet[index]);
							}
						}
					}

					status = mouseDownNote(mouseX, noteset, TPP);

					if(event.ctrlKey && status !== "none"){
						status = "move";
					}
					if (status === 'move' && typeof preview !== 'undefined'){
						preview.Xoffset = mouseX - (preview.tickstart / TPP);
					}
				} else {
					var temp = noteset.GetNote({"keyValue": keyValue, "tickstart": mouseX * TPP});
					var prev;
					if(typeof temp !== 'undefined'){
						while(typeof temp !== 'undefined'){
							prev = temp;
							temp = noteset.GetNote({"keyValue": keyValue, "tickstart": temp.tickstart + temp.tickduration + 1});
						}
						preview = new Note({"keyValue": keyValue, "tickstart": prev.tickstart + prev.tickduration, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = preview.tickstart / TPP;
					} else {
						preview = new Note({"keyValue": keyValue, "tickstart": mouseX * TPP, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = mouseX;
					}
				}
				
				// handle if any panes need to change
				if(!event.ctrlKey)
					showPanes();
			});


			// add mouse event handling
			canvas.addEventListener('mousemove', function(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);
				mouseY = mouseY - mouseY % 23 + 3;
				var keyValue = (mouseY - 3) / 23;
				
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){
					canvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

					if(typeof preview !== 'undefined' && button === 0){
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / TPP);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						if(x > 0 && (mouseX * TPP) < (preview.tickstart + preview.tickduration) && mouseX < preview.Xoffset){
							preview.tickstart += x * TPP;
							preview.tickduration -= x * TPP;
							preview = noteset.PreviewNote(preview);
						} else if (x > 0){
							preview.tickstart = preview.Xoffset * TPP;
							preview.tickduration = x * TPP;
							preview = noteset.PreviewNote(preview);
						} else if (x < 0){
							preview.tickduration -= x * TPP;
							preview.tickstart = preview.Xoffset * TPP - preview.tickduration;
							preview = noteset.PreviewNote(preview);
						}

						if(preview.isValid && (preview.tickstart + preview.tickduration >= preview.Xoffset * TPP || preview.tickstart >= preview.Xoffset * TPP)){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawNote(context, preview, TPP);
							}
						} else {
							preview = prevPreview;
						}
					}
				}
				else
				{
					if(typeof status === 'undefined' || (status !== "resize-duration" && status !== "resize-start" && status !== "move"))
						status = mouseOverNote(mouseX, noteset.currentNote, TPP);

					if (typeof preview !== 'undefined' && status === "resize-duration"){
						canvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / TPP);

						// when modifying the duration, don't allow backwards "flips"
						if (x < 0)
							x = 0;

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						preview.tickduration = x * TPP;
						preview = noteset.PreviewNote(preview);

						// clear the old rectangle
						if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
							eraseNote(context, prevPreview, TPP);

						// draw the new rectangle
						if(typeof preview !== 'undefined' && preview.isValid){
							drawSelectedNote(context, preview, TPP);
						}
					}
					else if (typeof preview !== 'undefined' && status === "resize-start")
					{
						canvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / TPP);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview);

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * TPP;
						preview.tickduration -= x * TPP;
						preview = noteset.PreviewNote(preview);

						// make sure that resizing hasn't changed the endpoint (this is only supposed to resize the start)
						if((temp.tickstart + temp.tickduration) === (preview.tickstart + preview.tickduration) && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview, TPP);
							}
						} else {
							preview = temp;
						}
					}
					else if (typeof preview !== 'undefined' && status === "move")
					{
						canvas.style.cursor = "move";
						
						// draw a preview rectangle
						var x = mouseX - ((preview.tickstart / TPP) + preview.Xoffset);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview); 

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * TPP;
						preview = noteset.PreviewNote(preview);

						// this is a movement, so do not allow resizing
						if(temp.tickduration === preview.tickduration && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview, TPP);
							}
						} else {
							// if note is "stuck", make it flush with the next/previous note
							if(mouseX > (preview.tickstart + preview.tickduration) / TPP){
								temp.tickstart = (preview.tickstart + preview.tickduration) - temp.tickduration;
							} else if(mouseX < preview.tickstart / TPP){
								temp.tickstart = preview.tickstart;
							}
							
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							drawSelectedNote(context, temp, TPP);

							preview = temp;
						}

						x = preview.tickstart - noteset.currentNote.tickstart;

						MoveSet(x, previewSet, preview);
					}
					else
					{
						var temp = noteset.GetNote({keyValue: keyValue, tickstart: (mouseX * TPP)});
						
						if(status !== "mouseover" && status !== "resize")
							status = mouseOverNote(mouseX, temp, TPP);

						if (status === "resize")
						{
							canvas.style.cursor = "ew-resize";
						}
						else if (status === "mouseover")
						{
							canvas.style.cursor = "move";
						}
						else
						{
							canvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
						}
					}
				}

				// show the note preview's information
				if(typeof preview !== 'undefined' && preview.tickduration !== 0){
					// display the note's properties in the window
					root.getElementById("note_start").value = preview.tickstart;
					root.getElementById("note_length").value = preview.tickduration;
				}

				// handle if any panes need to change
				if(!event.ctrlKey)
					showPanes();
			});


			canvas.addEventListener('mouseup', function(){
				// if there is not an existing note to work with, do nothing
				if(typeof preview === 'undefined'){
					status = undefined;

					// clear the note properties in the window
					root.getElementById("note_start").value = "";
					root.getElementById("note_length").value = "";

					// clear any multiselect if ctrl is not held down
					if(!event.ctrlKey){
						noteset.earliestSelected = undefined;
						noteset.latestSelected = undefined;
						for(var index in noteset.selectedSet){
							drawNote(context, noteset.selectedSet[index], TPP);
						}
						noteset.selectedSet = new Array();
						noteset.selectedCount = 0;
					}

					return false;
				} else {
					// display the note's properties in the window
					root.getElementById("note_start").value = preview.tickstart;
					root.getElementById("note_length").value = preview.tickduration;
				}

				// unset the mousebutton for mousemove
				button = undefined;

				// don't draw anything if mouse originated outside of the canvas
				if(typeof preview === 'undefined'){
					return;
				}

				// check for right-clicks
				if(event.button === 2.0){
					// restore previous note to original appearance
					drawNote(context, noteset.previousNote, TPP);

					// select the previewed note
					noteset.SelectNote(preview);

					// don't remove non-existent notes
					if (typeof noteset.currentNote !== 'undefined') {
						// remove the note
						eraseNote(context, noteset.currentNote, TPP);
						noteset.RemoveNote(noteset.currentNote);
					}
					if(noteset.selectedCount == 1){
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined'){
								noteset.currentNote = noteset.selectedSet[index];
								note_start.value = noteset.currentNote.tickstart;
								note_length.value = noteset.currentNote.tickduration;
							}
						}
					}

				} else if(mode === 'draw') {
					var myNote = noteset.AddNote(preview);
					drawNote(context, myNote, TPP);

				} else if (status === "resize-duration"){
					// set the currently-selected note's duration to its new value
					noteset.currentNote.tickduration = preview.tickduration;
					drawSelectedNote(context, preview, TPP);

					// update note in rhombus
					noteset.UpdateRhombNote(noteset.currentNote);

				} else if (status === "resize-start"){
					// set the currently-selected note's start and duration to their new values
					noteset.currentNote.tickduration = preview.tickduration;
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview, TPP);

					// update note in rhombus
					noteset.UpdateRhombNote(noteset.currentNote);

				} else if (status === "move" || mode === "select"){
					// set the selected note locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
							noteset.selectedSet[index].tickstart = previewSet[index].tickstart;
						}
					}

					// set the currently-selected note's location to its new value
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview, TPP);

					// update the index of the current note in the sorted list
					noteset.AdjustIndex(noteset.currentNote);

					// update note in rhombus
					noteset.UpdateRhombNote(noteset.currentNote);

					// update the indices of the current notes selected set and update them in rhombus
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							noteset.AdjustIndex(noteset.selectedSet[index]);
							noteset.UpdateRhombNote(noteset.selectedSet[index]);
						}
					}
					
					if(event.ctrlKey){
						if(typeof noteset.selectedSet[noteset.currentNote.ID] !== 'undefined'){
							noteset.selectedSet[noteset.currentNote.ID] = undefined;
							noteset.selectedCount--;
							drawNote(context, noteset.currentNote, TPP);
							noteset.currentNote = undefined;
							noteset.previousNote = undefined;

							// update earliest and latest selected notes
							noteset.earliestSelected = undefined;
							noteset.latestSelected = undefined;
							if(noteset.selectedCount > 0){
								for(var index in noteset.selectedSet){
									if(typeof noteset.selectedSet[index] !== 'undefined'){
										if(typeof noteset.earliestSelected === 'undefined' || noteset.selectedSet[index].tickstart < noteset.earliestSelected.tickstart)
											noteset.earliestSelected = noteset.selectedSet[index];
										if(typeof noteset.latestSelected === 'undefined' || noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration > noteset.latestSelected.tickstart + noteset.latestSelected.tickduration)
											noteset.latestSelected = noteset.selectedSet[index];
									}
								}
								group_start.value = noteset.earliestSelected.tickstart;
								group_length.value = noteset.latestSelected.tickstart + noteset.latestSelected.tickduration - noteset.earliestSelected.tickstart;
							}

							// if there is only a single note in the set, then treat as a single note selection
							if(noteset.selectedCount === 1){
								for(var index in noteset.selectedSet){
									if(typeof noteset.selectedSet[index] !== 'undefined'){
										noteset.SelectNote(noteset.selectedSet[index]);
										noteset.previousNote = undefined;
									}
								}
								note_start.value = noteset.currentNote.tickstart;
								note_length.value = noteset.currentNote.tickduration;
							}

						} else {
							if(typeof noteset.earliestSelected === 'undefined' || noteset.currentNote.tickstart < noteset.earliestSelected.tickstart){
								noteset.earliestSelected = noteset.currentNote;
							}
							if(typeof noteset.previousNote !== 'undefined' && noteset.previousNote.tickstart < noteset.earliestSelected.tickstart){
								noteset.earliestSelected = noteset.previousNote;	
							}
							if(typeof noteset.latestSelected === 'undefined' || noteset.currentNote.tickstart + noteset.currentNote.tickduration > noteset.latestSelected.tickstart + noteset.latestSelected.tickduration){
								noteset.latestSelected = noteset.currentNote;
							}
							if(typeof noteset.previousNote !== 'undefined' && (typeof noteset.latestSelected === 'undefined' || noteset.previousNote.tickstart + noteset.previousNote.tickduration > noteset.latestSelected.tickstart + noteset.latestSelected.tickduration)){
								noteset.latestSelected = noteset.previousNote;
							}
							group_start.value = noteset.earliestSelected.tickstart;
							group_length.value = noteset.latestSelected.tickstart + noteset.latestSelected.tickduration - noteset.earliestSelected.tickstart;

							if(typeof noteset.selectedSet[noteset.currentNote.ID] === 'undefined'){
								noteset.selectedSet[noteset.currentNote.ID] = noteset.currentNote;
								noteset.selectedCount++;
							}
							if(typeof noteset.previousNote !== 'undefined' && typeof noteset.selectedSet[noteset.previousNote.ID] === 'undefined'){
								noteset.selectedSet[noteset.previousNote.ID] = noteset.previousNote;
								noteset.selectedCount++;
							}
						}
					} else if(typeof noteset.selectedSet[noteset.currentNote.ID] === 'undefined'){
						noteset.earliestSelected = noteset.currentNote;
						noteset.latestSelected = noteset.currentNote;
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined')
								drawNote(context, noteset.selectedSet[index], TPP);
						}

						// clear out the selected set
						noteset.selectedSet = new Array();
						noteset.selectedCount = 0;
					}
				}

				// reset preview to undefined
				preview = undefined;
				status = undefined;

				// determine if the displayed panes need to change
				showPanes();
			});


			// reset mouse attributes when mousing out of the canvas
			canvas.addEventListener('mouseout',
				function(){
					// just redraw the canvas if something was happening while mousing out
					redrawAllNotes(root, noteset, TPP);

					preview = undefined;
				});

			// used to handle note property updates
			function handleNoteKeyUp()
			{
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					// keep a backup of the unchanged currently-selected note in order to erase it if needed
					var backup = new Note(noteset.currentNote);
					
					// try to change the parameters of the currently-selected note
					if(noteset.TrySetNote({tickstart: parseInt(note_start.value), tickduration: parseInt(note_length.value), autoadjust: note_autoadjust.checked})){
						// change succeeded, erase old note and draw the new one
						eraseNote(context, backup, TPP);
						drawSelectedNote(context, noteset.currentNote, TPP);

						// update the note properties pane with new values
						note_start.value = noteset.currentNote.tickstart;
						note_length.value = noteset.currentNote.tickduration;
					}
				}
			}

			// allow user to submit a new note start without submitting a form
			note_start.addEventListener('keyup', handleNoteKeyUp);
			note_length.addEventListener('keyup', handleNoteKeyUp);

			// shows different panes based on what is currently selected
			function showPanes(){
				if(noteset.selectedCount > 1){
					notepane.style.display = "none";
					trackpane.style.display = "none";
					grouppane.style.display = "block";
				}
				else if(typeof noteset.currentNote === 'undefined')
				{
					notepane.style.display = "none";
					grouppane.style.display = "none";
					trackpane.style.display = "block";
				}
				else
				{
					trackpane.style.display = "none";
					grouppane.style.display = "none";
					notepane.style.display = "block";
				}
			}

			// used to handle track property updates
			root.getElementById("release_time_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("release_time").value = input * 100;
					rhomb.setReleaseTime(input);
				}
			});
			root.getElementById("cutoff_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value);
					root.getElementById("cutoff").value = input;
					rhomb.setFilterCutoff(input);
				}
			});
			root.getElementById("resonance_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value);
					root.getElementById("resonance").value = input;
					rhomb.setFilterRes(input);
				}
			});
			root.getElementById("mod_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 10) / 10;
					root.getElementById("mod").value = input * 10;
					rhomb.setEnvDepth(input);
				}
			});
			root.getElementById("attack_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("attack").value = input * 100;
					rhomb.setAttackTime(input);
				}
			});
			root.getElementById("decay_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("decay").value = input * 100;
					rhomb.setDecayTime(input);
				}
			});
			root.getElementById("feedback_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("feedback").value = input * 100;
					rhomb.setFeedbackGain(input);
				}
			});
			root.getElementById("echo_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100;
					root.getElementById("echo").value = input * 100;
					rhomb.setWetGain(input);
				}
			});

			// track property slider events
			root.getElementById("release_time").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("release_time_text").value = input;
				rhomb.setReleaseTime(input);
			};
			root.getElementById("cutoff").oninput = function(){
				var input = parseInt(event.srcElement.value);
				root.getElementById("cutoff_text").value = input;
				rhomb.setFilterCutoff(input);
			};
			root.getElementById("resonance").oninput = function(){
				var input = parseInt(event.srcElement.value);
				root.getElementById("resonance_text").value = input;
				rhomb.setFilterRes(input);
			};
			root.getElementById("mod").oninput = function(){
				var input = parseInt(event.srcElement.value) / 10;
				root.getElementById("mod_text").value = input;
				rhomb.setEnvDepth(input);
			};
			root.getElementById("attack").oninput = function(){
				var input = 0.005 + parseInt(event.srcElement.value) / 100.0;
				root.getElementById("attack_text").value = input;
				rhomb.setAttackTime(input);
			};
			root.getElementById("decay").oninput = function(){
				var input = 0.010 + parseInt(event.srcElement.value) / 100.0;
				root.getElementById("decay_text").value = input;
				rhomb.setDecayTime(input);
			};
			root.getElementById("feedback").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("feedback_text").value = input;
				rhomb.setFeedbackGain(input);
			};
			root.getElementById("echo").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("echo_text").value = input;
				rhomb.setWetGain(input);
			};
			root.getElementById("echoEnabled").onchange = function(){
				rhomb.setEffectOn(event.srcElement.checked);
			}

			// moves a set of notes while previewing against the current noteset
			function MoveSet(x, previewSet, preview){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
						var prevPreview = noteset.PreviewNote(new Note(previewSet[index]));
						var temp = new Note(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Note(noteset.selectedSet[index]);
						previewSet[index].tickstart += x;
						previewSet[index] = noteset.PreviewNote(previewSet[index]);

						// noteset is a movement, so do not allow resizing
						if(temp.tickduration === previewSet[index].tickduration && previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedNote(context, previewSet[index], TPP);
							}
						} else {
							// if note is "stuck", make it flush with the next/previous note
							if((x + noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + noteset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, TPP);

							// draw the new rectangle
							drawSelectedNote(context, temp, TPP);

							previewSet[index] = temp;
						}
					}
				}
			}
		};

		// register the element
		var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();

// represents a set of notes to be displayed
function NoteSet(){
	this.rhomb = undefined;
	this.host = undefined;
	this.currentNote = undefined;
	this.previousNote = undefined;
	this.selectedSet = new Array();
	this.selectedCount = 0;
	this.lanes = new Array();
	for(var i = 0; i <= 24; i++){
		this.lanes[i] = new SortedList();
	}
}

// adds a note to the noteset
NoteSet.prototype.AddNote = function(note){
	// check if the note can be added
	note = this.PreviewNote(note);
	if(typeof note === 'undefined' || !note.isValid)
		return undefined;

	// assign a new ID to the note
	// TODO: fix temporary keyValue shift
	var rnote = new rhomb.Note(59 - note.keyValue, note.tickstart, note.tickduration);
	note.rnote = rnote;
	note.ID = rnote.id;

	// insert the note into the lane
	var lane = this.lanes[note.keyValue];
	lane.insertOne(note);

	// throw rhombus note creation
	var keyEvent = new CustomEvent("denoto-writenote", {"detail":{"note": rnote}});
	this.host.dispatchEvent(keyEvent);

	// return the added note (with any necessary adjustments)
	return note;
}

// adjusts an input note to make it valid (valid notes are unchanged)
NoteSet.prototype.PreviewNote = function(note){
	var lane = this.lanes[note.keyValue];

	// by default, a note is valid until proven otherwise
	note.isValid = true;

	if(note.tickduration <= 0){
		note.isValid = false;
		//console.log("Invalid note. Reason: negative tick duration.");
	}
	var index = lane.bsearch(note);

	// check for overlap during backwards draws
	for(var i = index; i < lane.length; i++){
		if(typeof lane[i] !== 'undefined' && lane[i].ID !== note.ID && typeof this.selectedSet[lane[i].ID] === 'undefined' && note.tickstart < lane[i].tickstart && note.tickstart + note.tickduration > lane[i].tickstart + lane[i].tickduration){
			note.isValid = false;
			//console.log("Invalid note. Reason: backwards draw overlap.");
		}
	}

	// check to see if this note's beginning overlaps with other notes
	if(index !== -1 && note.isValid){
		if(lane[index].ID !== note.ID && typeof this.selectedSet[lane[index].ID] === 'undefined' && lane[index].tickstart <= note.tickstart && (lane[index].tickstart + lane[index].tickduration) > note.tickstart){
			// if note is entirely within existing note, nothing to preview
			if((lane[index].tickstart + lane[index].tickduration) >= (note.tickstart + note.tickduration)){
				note.isValid = false;
				//console.log("Invalid note. Reason: entirely within another note.");
			}

			// clip the beginning of the note to make it valid
			note.tickduration = (note.tickstart + note.tickduration) - (lane[index].tickstart + lane[index].tickduration);
			note.tickstart = lane[index].tickstart + lane[index].tickduration;
			if(note.tickduration <= 0){
				note.isValid = false;
				//console.log("Invalid note. Reason: SECONDARY negative tick duration.");
			}
		}
		
		// check to see if this note's end overlaps with other notes
		if(index+1 < lane.length){
			if(lane[index+1].ID !== note.ID && typeof this.selectedSet[lane[index+1].ID] === 'undefined' && lane[index+1].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index+1].tickstart + lane[index+1].tickduration) || (note.tickstart < lane[index+1].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index+1].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
					//console.log("Invalid note. Reason: TERTIARY negative tick duration.");
				}
			}
		} else {
			if(lane[index].ID !== note.ID && typeof this.selectedSet[lane[index].ID] === 'undefined' && lane[index].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index].tickstart + lane[index].tickduration) || (note.tickstart < lane[index].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
					//console.log("Invalid note. Reason: QUATERNARY negative tick duration.");
				}
			}
		}	
	} // handle drawing at the beginning of a lane
	else if (note.isValid && lane.length > 0) {
		if(lane[0].ID !== note.ID && typeof this.selectedSet[lane[0].ID] === 'undefined' && lane[0].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[0].tickstart + lane[0].tickduration) || (note.tickstart < lane[0].tickstart))){
			note.tickduration -= (note.tickstart + note.tickduration) - lane[0].tickstart;
			if(note.tickduration <= 0){
				note.isValid = false;
				//console.log("Invalid note. Reason: QUINTERNARY negative tick duration.");
			}
		}
	}

	// make sure there are no notes between the new start and end
	if(lane.bsearch(note.tickstart) != lane.bsearch(note.tickstart + note.tickduration)){
		note.isValid = false;
		//console.log("Invalid note. Reason: other.");
	}

	// if there are no overlaps, return the original noteset
	return note;
}

// selects a note from the noteset AND sets it as the currently selected note
NoteSet.prototype.SelectNote = function(event){
	var lane = this.lanes[event.keyValue];
	var index = lane.bsearch(event);

	if(typeof lane[index] === 'undefined')
		return undefined;

	if(lane[index].tickstart <= event.tickstart && event.tickstart <= (lane[index].tickstart + lane[index].tickduration)){
		this.previousNote = this.currentNote;
		this.currentNote = lane[index];
		return lane[index];
	}

	this.previousNote = this.currentNote;
	this.currentNote = undefined;
	return undefined;
}

// selects a note from the noteset WITHOUT setting it as the currently selected note
NoteSet.prototype.GetNote = function(event){
	var lane = this.lanes[event.keyValue];
	var index = lane.bsearch(event);

	if(typeof lane[index] === 'undefined')
		return undefined;

	if(lane[index].tickstart <= event.tickstart && event.tickstart <= (lane[index].tickstart + lane[index].tickduration)){
		return lane[index];
	}

	return undefined;
}

// tries to set a note's properties manually (i.e. through a text field in the UI)
NoteSet.prototype.TrySetNote = function(event){
	var preview = new Note(this.currentNote);
	var lane = this.lanes[preview.keyValue];
	var index = lane.bsearch(preview);
	preview.tickstart = event.tickstart;
	preview.tickduration = event.tickduration;

	preview = this.PreviewNote(preview);

	if(!preview.isValid){
		alert("Note parameters are not valid");
		return false;
	} else {
		if(event.autoadjust || (preview.tickstart === event.tickstart && preview.tickduration === event.tickduration) || confirm("Note parameters need to be adjusted to fit. Would you like to do so?")){
			lane[index] = preview; // update the note in the SortedList
			this.currentNote = preview;
			this.AdjustIndex(this.currentNote);
			this.UpdateRhombNote(this.currentNote);
			return true;
		}
		else
			return false;
	}
}

// removes and then readds an element to the SortedList to move it to the correct index
NoteSet.prototype.AdjustIndex = function(note){
	var lane = this.lanes[note.keyValue];
	//var string = "Before: "
	//for(var i = 0; i < lane.length; i++){string += "[" + lane[i].tickstart + "]"}
	//console.log(string);
	
	lane.InsertionSort();
	
	//string = "After: "
	//for(var i = 0; i < lane.length; i++){string += "[" + lane[i].tickstart + "]"}
	//console.log(string);
}

// removes a note from the noteset
NoteSet.prototype.RemoveNote = function(note) {
	// shouldn't try to remove notes that don't exist
	if (note !== undefined) {
		// throw the rhombus note deletion
		var keyEvent = new CustomEvent("denoto-erasenote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);

		// remove the note from each place it was found
		var lane = this.lanes[note.keyValue];
		var index = lane.bsearch(note);
		this.selectedSet[note.ID] = undefined;

		if(index !== -1){
			lane.remove(index);
			this.currentNote = undefined;
			this.previousNote = undefined;
			this.selectedCount--;
		}
	}
}

// notifies rhombus of a note update in the noteset
NoteSet.prototype.UpdateRhombNote = function(note) {
	// shouldn't try to update notes that don't exist
	if (note !== undefined) {
		// update the rhombus version of the note
		note.rnote._start = note.tickstart;
		note.rnote._length = note.tickduration;

		// throw the rhombus note update
		var keyEvent = new CustomEvent("denoto-UpdateRhombNote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);
	}
}

// represents a single note that exists in the pianoroll
function Note(event){
	this.keyValue = event.keyValue;
	this.tickstart = event.tickstart;
	this.tickduration = event.tickduration;
	this.color = event.color;
	this.outlinecolor = event.outlinecolor;
	this.ID = event.ID;
	this.rnote = event.rnote;
	this.isValid = event.isValid;
	this.Xoffset = event.Xoffset;
}

// used for "close enough" calculations in the UI
function isWithinRange(cursorX, edgeX, TPP){
	return (cursorX > edgeX - 5) && (cursorX < edgeX + 5);
}

function mouseOverNote(mouseX, note, TPP){
	if(typeof note === 'undefined')
		return "none";

	if (isWithinRange(mouseX, ((note.tickstart + note.tickduration) / TPP))) {
		return "resize";
	}
	else if (isWithinRange(mouseX, (note.tickstart / TPP))) {
		return "resize";
	}
	else if ((note.tickstart / TPP) < mouseX && mouseX < ((note.tickstart + note.tickduration) / TPP))
	{
		return "mouseover";
	}
	else
	{
		return "none";
	}
}

function mouseDownNote(mouseX, noteset, TPP){
	if(typeof noteset.currentNote === 'undefined')
		return "none";

	if (isWithinRange(mouseX, ((noteset.currentNote.tickstart + noteset.currentNote.tickduration) / TPP))) {
		return "resize-duration";
	}
	else if (isWithinRange(mouseX, (noteset.currentNote.tickstart / TPP))) {
		return "resize-start";
	}
	else if ((noteset.currentNote.tickstart / TPP) < mouseX && mouseX < ((noteset.currentNote.tickstart + noteset.currentNote.tickduration) / TPP))
	{
		return "move";
	}
	else
	{
		return "none";
	}
}
</script>
