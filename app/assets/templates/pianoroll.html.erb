<template>
	<style>
		#pianoroll {
			position: relative;
			left: 0px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			padding: 0px;
		}
		#bgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
		#fgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
	</style>
	<div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
</template>
<!-- Include sorted list for the noteset -->
<script src="<%= asset_path("SortedList.js")%>"></script>

<script>
    (function(){
		// declare a persistent canvas
		var canvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var pianorollPrototype = Object.create(HTMLElement.prototype);

		// keep track of preview note
		var preview;
		var status;

		// keep track of displayed notes
		var noteset = new NoteSet();

		// current cursor mode. Options: draw, select
		var mode = 'draw';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		pianorollPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			// give the noteset access to the host in order to throw events
			noteset.host = root.host;

			// get the canvas info
			canvas = root.querySelector('#bgCanvas');
			var context = canvas.getContext("2d");
			var width = canvas.getAttribute("width");
			var height = canvas.getAttribute("height");

			// fill the canvas background
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.fillStyle = "#EEEEEE";			
			context.fill();

			// draw the black key bars
			var on = true;
			var times = 0;
			for(var i = 26; i < height; i += 23){
				times++;
				if(on && times !== 7 && times !== 12){
					context.beginPath()
					context.rect(0, i, width, 23);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
					on = false;
				} else {
					on = true;
				}
				if(times === 7 || times === 12){
					context.beginPath()
					context.moveTo(0, i);
					context.lineTo(width, i);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
				}
				if(times > 12){
					times = 1;
					//on = true;
				}
			}

			// draw the measure bars
			for(var i = 0.0; i < width; i += 40.0){
				context.beginPath();
				context.linewidth = 5;
				context.moveTo(i, 0);
				context.lineTo(i, height);
				if(i % 160 === 0.0){
					context.strokeStyle = "#000000";
				} else {
					context.strokeStyle = "#666666";
				}
				context.fill();
				context.stroke();
			}

			// outline the canvas
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.linewidth = 5;
			context.strokeStyle = "#000000";
			context.stroke();

			canvas = root.querySelector('#fgCanvas');
			context = canvas.getContext("2d");

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					mode = 'select';
					canvas.style.cursor = 'auto';
				}
				else if(event.charCode === 100){ // pressed 'd'
					mode = 'draw';
					canvas.style.cursor = 'cell';

					drawNote(context, noteset.currentNote);

					noteset.currentNote = undefined;
					noteset.previousNote = undefined;
				}
			});

			document.addEventListener('denoto-selectmode', function(){
				mode = 'select';
				canvas.style.cursor = 'auto';
			});

			document.addEventListener('denoto-drawmode', function(){
				mode = 'draw';
				canvas.style.cursor = 'cell';

				drawNote(context, noteset.currentNote);

				noteset.currentNote = undefined;
				noteset.previousNote = undefined;
			});

			document.addEventListener('keypress', function(){
				if(event.charCode === 120){
					if(typeof noteset.currentNote !== 'undefined'){
						eraseNote(context, noteset.currentNote);

						// dispatch the event so that listeners can handle it
						noteset.RemoveNote(noteset.currentNote);
						noteset.currentNote = undefined;
						noteset.previousNote = undefined;
					}
				}
			});


			canvas.addEventListener('mousedown', function(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the piano roll
				mouseY = mouseY - mouseY % 23 + 3;

				var keyValue = (mouseY - 3) / 23;
				var key = keyValue % 12;
				var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#6666AA" : "#AAAAFF";
				var outlinecolor = (color === "#6666AA") ? "#000044" : "#222266";

				if(mode === 'select'){
					drawNote(context, noteset.currentNote);

					preview = noteset.SelectNote({keyValue: keyValue, tickstart: mouseX * 3});

					if(typeof preview === 'undefined'){
						status = undefined;
						canvas.style.cursor = 'auto';
					} else {
						preview = new Note(preview);
					}

					status = mouseDownNote(mouseX, noteset);
					if (status === 'move'){
						preview.Xoffset = mouseX - (preview.tickstart / 3);
					}
				} else {
					preview = new Note({"keyValue": keyValue, "tickstart": mouseX * 3, "tickduration": 0, color: color, outlinecolor: outlinecolor});
					preview.Xoffset = mouseX;
				}
			});


			// add mouse event handling
			canvas.addEventListener('mousemove', function(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);
				mouseY = mouseY - mouseY % 23 + 3;
				var keyValue = (mouseY - 3) / 23;
				
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){
					canvas.style.cursor = 'cell';

					if(typeof preview !== 'undefined' && button === 0){
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / 3);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						if(x > 0 && (mouseX * 3) < (preview.tickstart + preview.tickduration) && mouseX < preview.Xoffset){
							preview.tickstart += x * 3;
							preview.tickduration -= x * 3;
							preview = noteset.PreviewNote(preview);
						} else if (x > 0){
							preview.tickstart = preview.Xoffset * 3;
							preview.tickduration = x * 3;
							preview = noteset.PreviewNote(preview);
						} else if (x < 0){
							preview.tickduration -= x * 3;
							preview.tickstart = preview.Xoffset * 3 - preview.tickduration;
							preview = noteset.PreviewNote(preview);
						}

						if(preview.isValid && (preview.tickstart + preview.tickduration >= preview.Xoffset * 3 || preview.tickstart >= preview.Xoffset * 3)){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawNote(context, preview);
							}
						} else {
							preview = prevPreview;
						}
					}
				}
				else
				{	
					if(typeof status === 'undefined' || (status !== "resize-duration" && status !== "resize-start" && status !== "move"))
						status = mouseOverNote(mouseX, noteset.currentNote);

					if (typeof preview !== 'undefined' && status === "resize-duration"){
						canvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / 3);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						preview.tickduration = x * 3;
						preview = noteset.PreviewNote(preview);

						// clear the old rectangle
						if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
							eraseNote(context, prevPreview);

						// draw the new rectangle
						if(typeof preview !== 'undefined' && preview.isValid){
							drawSelectedNote(context, preview);
						}
					}
					else if (typeof preview !== 'undefined' && status === "resize-start")
					{
						canvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / 3);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview);

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * 3;
						preview.tickduration -= x * 3;
						preview = noteset.PreviewNote(preview);

						// make sure that resizing hasn't changed the endpoint (this is only supposed to resize the start)
						if((temp.tickstart + temp.tickduration) === (preview.tickstart + preview.tickduration) && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview);
							}
						} else {
							preview = temp;
						}
					}
					else if (typeof preview !== 'undefined' && status === "move")
					{
						canvas.style.cursor = "move";
						
						// draw a preview rectangle
						var x = mouseX - ((preview.tickstart / 3) + preview.Xoffset);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview); 

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * 3;
						preview = noteset.PreviewNote(preview);

						// this is a movement, so do not allow resizing
						if(temp.tickduration === preview.tickduration && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview);
							}
						} else {
							// if note is "stuck", make it flush with the next/previous note
							if(mouseX > (preview.tickstart + preview.tickduration) / 3){
								temp.tickstart = (preview.tickstart + preview.tickduration) - temp.tickduration;
							} else if(mouseX < preview.tickstart / 3){
								temp.tickstart = preview.tickstart;
							}
							
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview);

							// draw the new rectangle
							drawSelectedNote(context, temp);

							preview = temp;
						}
					}
					else
					{
						var temp = noteset.GetNote({keyValue: keyValue, tickstart: (mouseX * 3)});
						
						if(status !== "mouseover" && status !== "resize")
							status = mouseOverNote(mouseX, temp);

						if (status === "resize")
						{
							canvas.style.cursor = "ew-resize";
						}
						else if (status === "mouseover")
						{
							canvas.style.cursor = "move";
						}
						else
						{
							canvas.style.cursor = 'auto';
						}
					}
				}
			});


			canvas.addEventListener('mouseup', function(){
				// if there is not an existing note to work with, do nothing
				if(typeof preview === 'undefined'){
					status = undefined;
					return false;
				}

				// unset the mousebutton for mousemove
				button = undefined;

				// don't draw anything if mouse originated outside of the canvas
				if(typeof preview === 'undefined'){
					return;
				}

				// check for right-clicks
				if(event.button === 2.0){
					// restore previous note to original appearance
					drawNote(context, noteset.previousNote);

					// select the previewed note
					noteset.SelectNote(preview);

					// don't remove non-existent notes
					if (typeof noteset.currentNote !== 'undefined') {
						// remove the note
						eraseNote(context, noteset.currentNote);
						noteset.RemoveNote(noteset.currentNote);
					}

				} else if(mode === 'draw') {
					var myNote = noteset.AddNote(preview);
					drawNote(context, myNote);

				} else if (status === "resize-duration"){
					// set the currently-selected note's duration to its new value
					noteset.currentNote.tickduration = preview.tickduration;
					drawSelectedNote(context, preview);

					// update note in rhombus
					noteset.UpdateNote(noteset.currentNote);

				} else if (status === "resize-start"){
					// set the currently-selected note's start and duration to their new values
					noteset.currentNote.tickduration = preview.tickduration;
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview);

					// update note in rhombus
					noteset.UpdateNote(noteset.currentNote);

				} else if (status === "move"){
					// set the currently-selected note's duration to its new value
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview);

					// update the index of the current note in the sorted list
					noteset.AdjustIndex(noteset.currentNote);

					// update note in rhombus
					noteset.UpdateNote(noteset.currentNote);

				} else if(mode === 'select') {
					// restore the old note's appearance
					drawNote(context, noteset.previousNote);

					// draw the current note as selected
					drawSelectedNote(context, noteset.currentNote);
				}

				// reset preview to undefined
				preview = undefined;
				status = undefined;
			});


			// reset mouse attributes when mousing out of the canvas
			canvas.addEventListener('mouseout',
				function(){
					// erase any preview rectangle
					eraseNote(context, preview);

					// redraw current note in case it was dragged out of the canvas
					drawSelectedNote(context, noteset.currentNote);

					preview = undefined;
				});
		};

		// register the element
		var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();

// represents a set of notes to be displayed
function NoteSet(){
	this.rhomb = undefined;
	this.host = undefined;
	this.currentNote = undefined;
	this.previousNote = undefined;
	this.lanes = new Array();
	for(var i = 1; i <= 24; i++){
		this.lanes[i] = new SortedList();
	}
}

// adds a note to the noteset
NoteSet.prototype.AddNote = function(note){
	// check if the note can be added
	note = this.PreviewNote(note);
	if(typeof note === 'undefined' || !note.isValid)
		return undefined;

	// assign a new ID to the note
	// TODO: fix temporary keyValue shift
	var rnote = new rhomb.Note(59 - note.keyValue, note.tickstart, note.tickduration);
	note.rnote = rnote;
	note.ID = rnote.id;

	// insert the note into the lane
	var lane = this.lanes[note.keyValue];
	lane.insertOne(note);

	// throw rhombus note creation
	var keyEvent = new CustomEvent("denoto-writenote", {"detail":{"note": rnote}});
	this.host.dispatchEvent(keyEvent);

	// return the added note (with any necessary adjustments)
	return note;
}

// adjusts an input note to make it valid (valid notes are unchanged)
NoteSet.prototype.PreviewNote = function(note){
	var lane = this.lanes[note.keyValue];

	// by default, a note is valid until proven otherwise
	note.isValid = true;

	if(note.tickduration <= 0)
		note.isValid = false;
	var index = lane.bsearch(note);

	// check for overlap during backwards draws
	for(var i = index; i < lane.length; i++){
		if(typeof lane[i] !== 'undefined' && lane[i].ID !== note.ID && note.tickstart < lane[i].tickstart && note.tickstart + note.tickduration > lane[i].tickstart + lane[i].tickduration)
			note.isValid = false;
	}

	// check to see if this note's beginning overlaps with other notes
	if(index !== -1 && note.isValid){
		if(lane[index].ID !== note.ID && lane[index].tickstart <= note.tickstart && (lane[index].tickstart + lane[index].tickduration) > note.tickstart){
			// if note is entirely within existing note, nothing to preview
			if((lane[index].tickstart + lane[index].tickduration) >= (note.tickstart + note.tickduration))
				note.isValid = false;

			// clip the beginning of the note to make it valid
			note.tickduration = (note.tickstart + note.tickduration) - (lane[index].tickstart + lane[index].tickduration);
			note.tickstart = lane[index].tickstart + lane[index].tickduration;
			if(note.tickduration <= 0)
				note.isValid = false;
		}
		
		// check to see if this note's end overlaps with other notes
		if(index+1 < lane.length){
			if(lane[index+1].ID !== note.ID && lane[index+1].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index+1].tickstart + lane[index+1].tickduration) || (note.tickstart < lane[index+1].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index+1].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		} else {
			if(lane[index].ID !== note.ID && lane[index].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index].tickstart + lane[index].tickduration) || (note.tickstart < lane[index].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		}	
	} // handle drawing at the beginning of a lane
	else if (note.isValid && lane.length > 0) {
		if(lane[0].ID !== note.ID && lane[0].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[0].tickstart + lane[0].tickduration) || (note.tickstart < lane[0].tickstart))){
			note.tickduration -= (note.tickstart + note.tickduration) - lane[0].tickstart;
			if(note.tickduration <= 0){
				note.isValid = false;
			}
		}
	}

	// make sure there are no notes between the new start and end
	if(lane.bsearch(note.tickstart) != lane.bsearch(note.tickstart + note.tickduration)){
		note.isValid = false;
	}

	// if there are no overlaps, return the original noteset
	return note;
}

// selects a note from the noteset AND sets it as the currently selected note
NoteSet.prototype.SelectNote = function(event){
	var lane = this.lanes[event.keyValue];
	var index = lane.bsearch(event);

	if(typeof lane[index] === 'undefined')
		return undefined;

	if(lane[index].tickstart <= event.tickstart && event.tickstart <= (lane[index].tickstart + lane[index].tickduration)){
		this.previousNote = this.currentNote;
		this.currentNote = lane[index];
		return lane[index];
	}

	this.previousNote = this.currentNote;
	this.currentNote = undefined;
	return undefined;
}

// selects a note from the noteset WITHOUT setting it as the currently selected note
NoteSet.prototype.GetNote = function(event){
	var lane = this.lanes[event.keyValue];
	var index = lane.bsearch(event);

	if(typeof lane[index] === 'undefined')
		return undefined;

	if(lane[index].tickstart <= event.tickstart && event.tickstart <= (lane[index].tickstart + lane[index].tickduration)){
		return lane[index];
	}

	return undefined;
}

// removes and then readds an element to the SortedList to move it to the correct index
NoteSet.prototype.AdjustIndex = function(note){
	var lane = this.lanes[note.keyValue];
	var string = "Before: "
	for(var i = 0; i < lane.length; i++){string += "[" + lane[i].tickstart + "]"}
	console.log(string);
	
	lane.InsertionSort();
	
	string = "After: "
	for(var i = 0; i < lane.length; i++){string += "[" + lane[i].tickstart + "]"}
	console.log(string);
}

// removes a note from the noteset
NoteSet.prototype.RemoveNote = function(note) {
	// shouldn't try to remove notes that don't exist
	if (note !== undefined) {
		// throw the rhombus note deletion
		var keyEvent = new CustomEvent("denoto-erasenote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);

		// remove the note from each place it was found
		var lane = this.lanes[note.keyValue];
		var index = lane.bsearch(note);

		if(index !== -1){
			lane.remove(index);
			this.currentNote = undefined;
			this.previousNote = undefined;
		}
	}
}

// notifies rhombus of a note update in the noteset
NoteSet.prototype.UpdateNote = function(note) {
	// shouldn't try to update notes that don't exist
	if (note !== undefined) {
		// update the rhombus version of the note
		note.rnote._start = note.tickstart;
		note.rnote._length = note.tickduration;

		// throw the rhombus note update
		var keyEvent = new CustomEvent("denoto-updatenote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);
	}
}

// represents a single note that exists in the pianoroll
function Note(event){
	this.keyValue = event.keyValue;
	this.tickstart = event.tickstart;
	this.tickduration = event.tickduration;
	this.color = event.color;
	this.outlinecolor = event.outlinecolor;
	this.ID = event.ID;
	this.rnote = undefined;
	this.isValid = event.isValid;
	this.Xoffset = event.Xoffset;
}

// used for "close enough" calculations in the UI
function isWithinRange(cursorX, edgeX){
	return (cursorX > edgeX - 5) && (cursorX < edgeX + 5);
}

function mouseOverNote(mouseX, note){
	if(typeof note === 'undefined')
		return "none";

	if (isWithinRange(mouseX, ((note.tickstart + note.tickduration) / 3))) {
		return "resize";
	}
	else if (isWithinRange(mouseX, (note.tickstart / 3))) {
		return "resize";
	}
	else if ((note.tickstart / 3) < mouseX && mouseX < ((note.tickstart + note.tickduration) / 3))
	{
		return "mouseover";
	}
	else
	{
		return "none";
	}
}

function mouseDownNote(mouseX, noteset){
	if(typeof noteset.currentNote === 'undefined')
		return "none";

	if (isWithinRange(mouseX, ((noteset.currentNote.tickstart + noteset.currentNote.tickduration) / 3))) {
		return "resize-duration";
	}
	else if (isWithinRange(mouseX, (noteset.currentNote.tickstart / 3))) {
		return "resize-start";
	}
	else if ((noteset.currentNote.tickstart / 3) < mouseX && mouseX < ((noteset.currentNote.tickstart + noteset.currentNote.tickduration) / 3))
	{
		return "move";
	}
	else
	{
		return "none";
	}
}
</script>
