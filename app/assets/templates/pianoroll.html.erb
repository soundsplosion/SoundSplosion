<template>
  <!-- Pencil icon made by <a href="http://appzgear.com" title="Appzgear">Appzgear</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>. Licensed under <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0">CC BY 3.0</a> -->
  <!-- Cursor icon adapted from cursor by Gentleface.com, licensed under Creative Commons Attribution Non-commercial (by-nc) -->
  <style>
    input[type=range][orient=vertical]
    {
      writing-mode: bt-lr; /* IE */
      -webkit-appearance: slider-vertical; /* WebKit */
      width: 8px;
      height: 100px;
      padding: 0 5px;
    }
    #pianoroll {
      background: #243544;
      position: relative;
      left: 0px;
      top: 0px;
      white-space: nowrap;
      margin: 0px;
      width: calc(100% - 350px);
      height: 610px;
      overflow: scroll;
    }
    #filler{
      position: relative;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    #bgCanvas {
      position: absolute;
      left: 0px;
      top: 53px;
      margin: 0px;
      padding: 0px;
      z-index: 0;
    }
    #fgCanvas {
      position: absolute;
      left: 0px;
      opacity: 0.75;
      top: 33px;
      margin: 0px;
      padding: 0px;
      z-index: 1;
    }
    #bgMeasurebar {
      position: fixed;
      left: 100px;
      top: 150px;
      margin: 0px;
      padding: 0px;
      z-index: 2;
    }
    #fgMeasurebar {
      position: fixed;
      left: 100px;
      top: 150px;
      margin: 0px;
      padding: 0px;
      z-index: 3;
    }
    #overlayCanvas {
      position: absolute;
      left: 0px;
      top: 0px;
      margin: 0px;
      padding: 0px;
      z-index: 4;
      image-rendering: pixelated;
    }
    #kbwrapper{
      background: #172837;
      height: 620px;
      width: 100px;
      float: left;
      z-index: 2;
      position: relative;
      padding-top: 7px;
    }
    #kbcover{
      background: #172837;
      height: 30px;
      width: 100px;
      position: fixed;
      left: 0px;
      top: 150px;
      z-index: 4;
    }
    #appkeyboard {
      background: #172837;
      float: left;
      position: relative;
      top: 30px;
    }
    #noteproperties {
      display: none;
      background: #172837;
      float: right;
      width: 270px;
      height: 610px;
      left: calc(100% - 270px);
      position: fixed;
      z-index: 6;
      color: #FFFFFF;
      text-align: right;
    }
    #notepropertiesHeader {
      text-align: center;
      opacity: 0.9;
      position: relative;
      top: -15px;
      height: 25px;
    }
    #noteproperties p {
      padding-left: 10px;
      padding-right: 10px;
      opacity: 0.9;
      position: relative;
      top: 5px;
    }
    #groupproperties {
      display: none;
      background: #172837;
      float: right;
      width: 270px;
      height: 610px;
      left: calc(100% - 270px);
      position: fixed;
      z-index: 6;
      color: #FFFFFF;
      text-align: right;
    }
    #grouppropertiesHeader {
      text-align: center;
      opacity: 0.9;
      position: relative;
      top: -15px;
      height: 25px;
    }
    #groupproperties p {
      padding-left: 10px;
      padding-right: 10px;
      opacity: 0.9;
      position: relative;
      top: 5px;
    }
    #instrumentproperties {
      display: block;
      background: #172837;
      float: right;
      width: 270px;
      height: 610px;
      left: calc(100% - 270px);
      position: fixed;
      z-index: 6;
      color: #FFFFFF;
      text-align: right;
    }
    #instrumentpropertiesHeader {
      text-align: center;
      opacity: 0.9;
      position: relative;
      top: -15px;
      height: 25px;
    }
    #instrumentproperties p {
      padding-left: 10px;
      padding-right: 10px;
      opacity: 0.9;
    }
    .biggertext{
      font-family: 'Oswald';
      font-size: 20px;
      opacity: 0.85;
      color: #FFF;
    }
    .shorttextbox {
      width: 50px;
    }
    .slider {
      position: relative;
      top: 5px;
      width: 110px !important;
    }
    .vert_slider {
      position: relative;
      top: 5px;
    }
    #footer{
      width: 100%;
      position: fixed;
      bottom: 0px;
      height: 185px;
      background: #172837;
      z-index: 5;
    }
    #footerWrapper{
      position: absolute;
      left: 100px;
      /*background: #243544;*/
      top: 5%;
      height: 90%;
      width: 100%;
    }
    #footerCanvas{
      position: absolute;
      width: 100%;
      height: 80px;
      top: 85px;
      z-index: 1;
      background: #243544;
    }
    #appautomation{
      z-index: 0;
    }
    #screenposition{
      background: #FFFFFF;
      opacity: 0.1;
      position: absolute;
      top: 85px;
      height: 80px;
      z-index: 2;
    }
    #preload{
      display: none;
    }
    .denotobutton{
      background: #243544;
      display: inline-block;
      padding: 10px;
      margin-right: 10px;
      margin-left: 10px;
    }
    .denotobutton:hover{
      background: #172837;
      cursor: pointer;
    }
  </style>
  <div id="noteproperties">
    <div id="notepropertiesHeader"><h3>Note Properties</h3></div>
    <p><denoto-editableclock type="shorttext" id="note_start" isposition="true" caption="Start: "></denoto-editableclock></p>
    <p><denoto-editableclock type="shorttext" id="note_length" isposition="false" caption="Length: "></denoto-editableclock></p>
    <p>Pitch: <denoto-editabletext type="shorttext" id="note_pitch"></denoto-editabletext></p>
    <p>Velocity: <denoto-editabletext type="shorttext" id="note_velocity"></denoto-editabletext></p>
    <p><div id="note_quantize" class="denotobutton">Quantize Notes</div> Quantize Length <input type="checkbox" id="note_quantize_length" checked></p>
  </div>
  
  <div id="groupproperties">
    <div id="grouppropertiesHeader"><h3>Group Properties</h3></div>
    <p><denoto-editableclock type="shorttext" id="group_start" isposition="true" caption="Start: "></denoto-editableclock></p>
    <p><div id="group_quantize" class="denotobutton">Quantize Notes</div> Quantize Length <input type="checkbox" id="group_quantize_length" checked></p>
  </div>
  
  <div id="instrumentproperties">
    <div id="instrumentpropertiesHeader"><h3>Properties</h3></div>
    <p>Insert Velocity <input id="insert_velocity" type="number" value="0.5" min="0" max="1" step="0.01" width="25px"></p>
    <p><div id="all_quantize" class="denotobutton">Quantize All Notes</div> Quantize Length <input type="checkbox" id="all_quantize_length" checked></p>

    <p>Automation Lane: <select id="all_automation_select">
        <option value="Velocity" selected="selected">Velocity</option>
        <option value="1">Control Signal 1</option>
        <option value="2">Control Signal 2</option>
        <option value="3">Control Signal 3</option>
        <option value="4">Control Signal 4</option>
        <option value="5">Control Signal 5</option>
      </select>
    </p>
  </div>


  <div id="kbcover"></div>
  <div id="kbwrapper">
    <denoto-keyboard id="appkeyboard" keycount="128"></denoto-keyboard>
  </div>
  <div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
    </style>
    <div id="filler"></div>
    <canvas id="bgCanvas" width="1920" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
    <canvas id="fgCanvas" width="3600" height="128" oncontextmenu="event.preventDefault(); return false;"></canvas>
    <canvas id="bgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
    <canvas id="fgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
    <canvas id="overlayCanvas" width="100" height="1" oncontextmenu="event.preventDefault(); return false;"></canvas>
  </div>
  <div id="footer">
    <div id="footerWrapper">
      <denoto-automation id="appautomation"></denoto-automation>
      <canvas id="footerCanvas" width="3600" height="128" oncontextmenu="event.preventDefault(); return false;"></canvas>
      <div id="screenposition"></div>
    </div>
  </div>
  <div id="preload">
    <img src='<%= asset_path("tb_pencil_cursor.png")%>' />
    <img src='<%= asset_path("tb_cursor_auto.png")%>' />
  </div>
</template>
<link rel="import" href="<%= asset_path("keyboard.html")%>">
<link rel="import" href="<%= asset_path("blackkey.html")%>">
<link rel="import" href="<%= asset_path("whitekey.html")%>">
<link rel="import" href="<%= asset_path("editabletext.html")%>">
<link rel="import" href="<%= asset_path("automation.html")%>">
<link rel="import" href="<%= asset_path("dialog.html")%>">

<script>
(function() {
    // keep track of display settings like ticks per pixel (AKA zoom level), and whether to show measure guides
    var displaySettings = {TPP: 4, showguides: true, loopEnabled: false, quantization: (1920 / 16), length_quantization: (1920 / 16), timesig_num: 4, timesig_den: 4, snapto: true, endmarkerticks: (16 * 1920), maxmeasures: 16};

    // hold the pianoroll's node when it's detached
    var pianorollholder;

    // declare a persistent canvas
    var bgCanvas, canvas;
    var bgMeasurebar, fgMeasurebar;
    var overlayCanvas, footerCanvas;
    var automation;

    // get the template for this element
    var template = document.currentScript.ownerDocument.querySelector('template');

    // copy a prototype from HTMLElement
    var pianorollPrototype = Object.create(HTMLElement.prototype);

    // keep track of whether or not the notes are playing
    var playing = false;

    // keep track of preview notes
    var preview;
    var previewSet;
    var previewMarker;
    var addSet;
    var copySet;
    var status;
    var Xoffset;
    var pitchStart;
    var deltaTick;
    var deltaPitch;

    // keep track of loop bar
    var loopbar = {start: 0, end: 1920};
    var loopbarPreview;

    // current cursor mode. Options: draw, select
    var mode = 'draw';

    // set by mousedown, unset by mouseup, used in mousemove
    var button;

    // specify the created callback ("constructor")
    pianorollPrototype.createdCallback = function() {
      var root = this.createShadowRoot();
      var that = this;
      root.appendChild(document.importNode(template.content, true));

      var appkeyboard = root.getElementById("appkeyboard");

      // keep track of the originating playlist item
      that.playlistItem = undefined;      

      // keep track of note pane fields
      var notepane = root.getElementById("noteproperties");
      var note_start = root.getElementById("note_start");
      var note_length = root.getElementById("note_length");
      var note_pitch = root.getElementById("note_pitch");
      var note_velocity = root.getElementById("note_velocity");
      var note_autoadjust = root.getElementById("note_autoadjust");

      // keep track of group pane fields
      var grouppane = root.getElementById("groupproperties");
      var group_start = root.getElementById("group_start");
      var group_length = root.getElementById("group_length");
      var group_autoadjust = root.getElementById("group_autoadjust");

      // keep track of track pane fields
      var trackpane = root.getElementById("instrumentproperties");

      // keep track of on-screen elements
      var screenposition = root.getElementById("screenposition");
      var pianoroll = root.getElementById("pianoroll");
      bgMeasurebar = root.querySelector('#bgMeasurebar');
      fgMeasurebar = root.querySelector('#fgMeasurebar');
      overlayCanvas = root.querySelector('#overlayCanvas');
      footerCanvas = root.querySelector('#footerCanvas');
      canvas = root.querySelector('#fgCanvas');
      bgCanvas = root.querySelector('#bgCanvas');
      automation = root.getElementById("appautomation");

      // keep track of contexts
      var context = canvas.getContext("2d");
      var bgContext = bgCanvas.getContext("2d");
      var overlayContext = overlayCanvas.getContext("2d");
      var footerContext = footerCanvas.getContext("2d");
      var fgMeasurebarContext = fgMeasurebar.getContext("2d");

      canvas.style.imageRendering = "pixelated";

      // resize the canvas and other elements to be the same height as the keyboard
      var keyboardHeight = parseInt(root.getElementById("appkeyboard").style.height) + 5;
      setHeights(keyboardHeight);

      // draw the background canvas
      redrawEverything();

      // setup scrolling events
      setupScrolling();

      // set up top bar interface events
      setupTopbarEvents();

      function quantizeSelectedNotes(doEnds){
        var selectedNotes = that.pattern.getSelectedNotes();
        rhomb.Edit.quantizeNotes(that.ptnId, selectedNotes, displaySettings.quantization, doEnds);
        for(var i in selectedNotes){
          selectedNotes[i].select();
        }
      }
      function quantizeAllNotes(doEnds){
        var allNotes = that.pattern.getAllNotes();
        rhomb.Edit.quantizeNotes(that.ptnId, allNotes, displaySettings.quantization, doEnds);
      }
      var note_quantize = root.getElementById("note_quantize");
      note_quantize.addEventListener("mousedown", function(){
        event.preventDefault();
        var doEnds = root.getElementById("note_quantize_length").checked;
        quantizeSelectedNotes(doEnds);
        that.redrawAllNotes();
      });
      var group_quantize = root.getElementById("group_quantize");
      group_quantize.addEventListener("mousedown", function(){
        event.preventDefault();
        var doEnds = root.getElementById("group_quantize_length").checked;
        quantizeSelectedNotes(doEnds);
        that.redrawAllNotes();
      });
      var all_quantize = root.getElementById("all_quantize");
      all_quantize.addEventListener("mousedown", function(){
        event.preventDefault();
        var doEnds = root.getElementById("all_quantize_length").checked;
        quantizeAllNotes(doEnds);
        that.redrawAllNotes();
      });
      var all_automation_select = root.getElementById("all_automation_select");
      all_automation_select.addEventListener("change", function(){
        var value = event.srcElement.value;
        if(value === "Velocity"){
          var autoEvent = new CustomEvent("denoto-editvelocity", {});
          document.dispatchEvent(autoEvent);
        } else {
          value = parseInt(value);
          var autoEvent = new CustomEvent("denoto-editparameter", {"detail": {"parameterIndex": value}});
          document.dispatchEvent(autoEvent);
        }
      });

      // give the parameter automation a reference to the display settings
      var displaysettingsEvent = new CustomEvent('denoto-displaysettings', {"detail": {"displaySettings": displaySettings}});
      automation.dispatchEvent(displaysettingsEvent);

      this.handleKeyDown = function(){        
        if (event.keyCode === 90) { // pressed 'z'
          if(event.ctrlKey){
            rhomb.Undo.doUndo();
            redrawEverything();
          }
        } else if (event.keyCode === 88) { // pressed 'x'
          if(event.ctrlKey){
            var selectedNotes = that.pattern.getSelectedNotes();
            copySet = [];
            for(var i in selectedNotes){
              var n = selectedNotes[i];
              copySet.push(new Rhombus.Note(+n._pitch, +n._start, +n._length, +n._velocity, rhomb));
            }
            rhomb.Edit.deleteNotes(selectedNotes, that.ptnId);
            redrawEverything();
          }
        } else if (event.keyCode === 67) { // pressed 'c'
          if(event.ctrlKey){
            var selectedNotes = that.pattern.getSelectedNotes();
            copySet = [];
            for(var i in selectedNotes){
              var n = selectedNotes[i];
              copySet.push(new Rhombus.Note(+n._pitch, +n._start, +n._length, +n._velocity, rhomb));
            }
            redrawEverything();
          }
        } else if (event.keyCode === 86) { // pressed 'v'
          if(event.ctrlKey && typeof copySet !== 'undefined'){
            that.pattern.clearSelectedNotes();
            var anotherCopy = []; // this is a hack to get around rhombus preventing duplicate notes from being added
            rhomb.Edit.insertNotes(copySet, that.ptnId, 0);
            for(var i in copySet){
              var n = copySet[i];
              anotherCopy.push(new Rhombus.Note(+n._pitch, +n._start, +n._length, +n._velocity, rhomb));
              copySet[i].select();
            }
            copySet = anotherCopy;
            redrawEverything();
          }
        } else if (event.keyCode === 46) {
          var selectedNotes = that.pattern.getSelectedNotes();
          
          that.pattern.deleteNotes(selectedNotes);
          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
          
          // update the overview image on the footer
          footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
          footerContext.drawImage(canvas, 0, 0);
        }
        else if (event.keyCode === 27) {
          // remove self from document and restore the trackview
          var trackEvent = new CustomEvent('denoto-edittrack', {});
          document.dispatchEvent(trackEvent);
        }
        else if(event.ctrlKey && status === "move") {
          if(typeof previewSet !== 'undefined' && previewSet.length > 0) {
            drawNotes(root, previewSet, displaySettings);
          }
        }

        // handle if any panes need to change
        showPanes();
      };

      document.addEventListener('keypress', function() {
        if (event.charCode === 115) { // pressed 's'
          var keyEvent = new CustomEvent("denoto-selectmode", {"detail": "select"});
          document.dispatchEvent(keyEvent);
        }
        else if (event.charCode === 100) { // pressed 'd'
          var keyEvent = new CustomEvent("denoto-drawmode", {"detail": "draw"});
          document.dispatchEvent(keyEvent);
        }

        // handle if any panes need to change
        showPanes();
      });

      document.addEventListener('denoto-edittrack', function() {
        if (typeof pianorollholder === 'undefined' && root.host.ownerDocument.getElementById("apppianoroll") !== null) {
          pianorollholder = document.getElementById("midi-interface").removeChild(root.host);
        }
      });

      document.addEventListener('denoto-editeffects', function() {
        if (typeof pianorollholder === 'undefined' && root.host.ownerDocument.getElementById("apppianoroll") !== null) {
          pianorollholder = document.getElementById("midi-interface").removeChild(root.host);
        }
      });

      document.addEventListener('denoto-editpattern', function() {
        if (typeof pianorollholder !== 'undefined') {
          document.getElementById("midi-interface").appendChild(pianorollholder);
          pianorollholder = undefined;
        }

        if (typeof rhomb !== "undefined") {
          console.log("[PianoRoll] - disabling record");
          rhomb.setRecordEnabled(false);
          rhomb.Record.clearBuffer();
        }

        // save current tab's settings if switching to a different tab
        if(typeof that.ptnId !== 'undefined'){
          var tab = document.getElementById("tabset").shadowRoot.getElementById("pattern" + that.ptnId);
          if (typeof tab === "undefined" || !tab) {
            console.log("[PianoRoll] - tab is undefined or null");
          }
          else {
            var displaysettingsEvent = new CustomEvent('denoto-displaysettings', {"detail": {"displaySettings": JSON.parse(JSON.stringify(displaySettings)), "source": that}});
            tab.dispatchEvent(displaysettingsEvent);
          }
        }

        that.playlistItem = event.detail.playlistItem;

        ptnId = event.detail.pattern._id.toString();
        that.ptnId = event.detail.pattern._id;
        that.pattern = event.detail.pattern;
        that.start = event.detail.start;
        that.length = event.detail.length;

        // deselect the notes in the noteset (because we should never enter a tab with notes selected)
        that.pattern.clearSelectedNotes();

        // put the current marker at the beginning of this instance of the pattern (only if not playing)
        if (!rhomb.isPlaying() && typeof event.detail.start !== 'undefined') {
          rhomb.moveToPositionTicks(event.detail.start);
        }
        if(typeof that.playlistItem !== 'undefined') {
          displaySettings.startOffsetTicks = that.playlistItem.getStart();
        }
        else {
          displaySettings.startOffsetTicks = 0; // this is only reached when the playlistitem we're trying to access has been deleted. Would be better to find another instance of the same pattern (if any exists) and use its starting point (essentially start editing it instead).
        }

        displaySettings.endmarkerticks = 16 * 1920;
        displaySettings.maxmeasures = 16;

        that.trackIndex = event.detail.trackIndex;

        // set the global target to play this instrument
        rhomb.setGlobalTarget(event.detail.trackIndex);

        var tab = document.getElementById("tabset").shadowRoot.getElementById("pattern" + that.ptnId);
        if (typeof tab === "undefined" || !tab) {
          console.log("[PianoRoll] - tab is undefined or null");
        }
        else {
          var displaysettingsEvent = new CustomEvent('denoto-getdisplaysettings', {"detail": undefined});
          tab.dispatchEvent(displaysettingsEvent);
        }

        redrawEverything();
      });

      this.applyDisplaySettings = function(){
        var offsetTicks = displaySettings.startOffsetTicks;
        displaySettings = event.detail.displaySettings;
        displaySettings.startOffsetTicks = offsetTicks; // keep the offset from being clobbered by an old value saved in the tab

        var displaysettingsEvent = new CustomEvent('denoto-displaysettings', {"detail": {"displaySettings": displaySettings}});
        document.getElementById("quantizationcontrol").dispatchEvent(displaysettingsEvent);
        automation.dispatchEvent(displaysettingsEvent);

        redrawEverything();

        // update the background image for the pianoroll
        var bgImage = bgCanvas.toDataURL();
        that.shadowRoot.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
        bgCanvas.style.display = "none";

        // add scroll handling here
        that.scrollToCoord(displaySettings.scrollCoord);
        if(typeof displaySettings.vScroll !== 'undefined')
          window.scrollTo(0, displaySettings.vScroll);
        else
          window.scrollTo(0, 1270); // middle C, I think...
      };

      // listen to events thrown to this pattern editor
      root.host.addEventListener('denoto-createdpattern', function() {
        var name = event.detail.pattern._name;
        if (name == "Default Pattern Name")
          name = "[Click to enter pattern name]";

        document.getElementById('header_name').setAttribute("value", name);
      });

      function finishRecord() {
        rhomb.setRecordEnabled(false);
        var notes = rhomb.Record.dumpBuffer();
        rhomb.Record.clearBuffer();

        if (typeof notes === "undefined" || notes.length < 1) {
          return;
        }

        var parentId = that.playlistItem.getPatternId();
        var offset = -that.playlistItem.getStart();

        rhomb.Edit.insertNotes(notes, parentId, offset); 
        redrawEverything();
      }

      document.getElementById("transportbar").addEventListener("denoto-recordenable", 
        function(e) {
          if (typeof that.playlistItem !== "undefined") {
            rhomb.setRecordEnabled(!rhomb.getRecordEnabled(), that.playlistItem);
            console.log("[PianoRoll] - Record Enabled: " + rhomb.getRecordEnabled() + "; playlist ID: " + that.playlistItem._id);
            if (!rhomb.getRecordEnabled()) {
              finishRecord();
            }
          }
        });

      document.addEventListener("denoto-finishrecord",
        function(e) {
          if (rhomb.getRecordEnabled()) {
            finishRecord();
          }
        });

      this.resizeScrollbar = function() {
        resizeScrollbar();
      }

      function resizeScrollbar() {
        var width = document.body.clientWidth - 370;
        screenposition.style.width = (width * pianoroll.clientWidth) / pianoroll.scrollWidth + "px";
        footerCanvas.style.width = width + "px";
      }

      this.redrawAllNotes = function(){
        redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
        var selectedNotes = that.pattern.getSelectedNotes();
        setNotePropertiesPane(selectedNotes);
        setGroupPropertiesPane(selectedNotes);
        showPanes();
      };

      this.handleNotePaneUpdateVelocity = function(){
        note_velocity.setAttribute("value", event.detail.velocity);
      };

      this.documentMousemove = function() {
        if(event.clientY < fgMeasurebar.getBoundingClientRect().bottom && typeof button !== 'undefined'){
          var mouse = getMousePosition(fgMeasurebar);
          if (typeof displaySettings.startOffsetTicks !== 'undefined')
            rhomb.moveToPositionTicks(mouse.tick + displaySettings.startOffsetTicks);
          else
            rhomb.moveToPositionTicks(mouse.tick);
          
          var posEvent = new CustomEvent("denoto-updatestartpos");
          document.dispatchEvent(posEvent);
        }
        if(event.clientY < fgMeasurebar.getBoundingClientRect().bottom && typeof that.startRectMouse !== "undefined"){
          if(!that.scroll_Up){
            that.scroll_Up = true;
            scroll_Up();
          }
          that.scrollDown = false;
        } else if(event.clientY > parseInt(root.getElementById("footer").getBoundingClientRect().top) && typeof that.startRectMouse !== "undefined") {
          if(!that.scroll_Down){
            that.scroll_Down = true;
            scroll_Down();
          }
          that.scroll_Up = false;
        } else {
          that.scroll_Up = false;
          that.scroll_Down = false;
        }

        if(event.clientX < 100 && typeof that.startRectMouse !== "undefined"){
          if(!that.scroll_Left){
            that.scroll_Left = true;
            scroll_Left();
          }
          that.scroll_Right = false;
        } else if(event.clientX > (window.innerWidth - 270) && typeof that.startRectMouse !== "undefined") {
          if(!that.scroll_Right){
            that.scroll_Right = true;
            scroll_Right()
          }
          that.scroll_Left = false;
        } else {
          that.scroll_Right = false;
          that.scroll_Left = false;
        }

        handleMousemove();
      };

      function scroll_Left(){
        if(that.scroll_Left){
          pianoroll.scrollLeft -= 10;
          setTimeout(scroll_Left, 30);
        }
      }

      function scroll_Right(){
        if(that.scroll_Right){
          pianoroll.scrollLeft += 10;
          setTimeout(scroll_Right, 30);
        }
      }

      function scroll_Up(){
        if(that.scroll_Up){
          window.scrollBy(0, -3);
          setTimeout(scroll_Up, 10);
        }
      }

      function scroll_Down(){
        if(that.scroll_Down){
          window.scrollBy(0, 3);
          setTimeout(scroll_Down, 10);
        }
      }

      this.documentMouseup = function() {
        handleMouseup();
      };

      this.handleZoomIn = function() {
        displaySettings.TPP = displaySettings.TPP / 2;
        if (displaySettings.TPP < 1) {
          displaySettings.TPP = 1
        }
        else {
          redrawEverything();

          var bgImage = bgCanvas.toDataURL();
          root.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
        }
      }

      this.handleZoomOut = function() {
        displaySettings.TPP = displaySettings.TPP * 2;
        if (displaySettings.TPP > 32) {
          displaySettings.TPP = 32;
        }
        else {
          redrawEverything();
          
          var bgImage = bgCanvas.toDataURL();
          root.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
        }
      }


      function getMousePosition(element) {
        var pageOffset = document.body.getBoundingClientRect();
        var offset = element.getBoundingClientRect();
        var mouse = {};
        mouse.x = event.pageX - (offset.left - pageOffset.left);
        mouse.origX = parseInt(mouse.x);
        mouse.y = event.pageY - (offset.top - pageOffset.top);
        mouse.origY = parseInt(mouse.y);
        mouse.y = mouse.y - mouse.y % 23 + 3;
        mouse.pitch = 127 - ((mouse.y - 3) / 23);
        mouse.tick = mouse.x * displaySettings.TPP;
        return mouse;
      }

      // TG WAS HERE
      // This is kinda hacky
      var insertVelocity = 0.5;
      root.getElementById("insert_velocity").onchange = function() {
        insertVelocity = root.getElementById("insert_velocity").value;
        console.log("[Pianoroll] - setting insert velocity to " + insertVelocity);
        var velocityEvent = new CustomEvent("denoto-setinsertvelocity", {"detail": {"velocity": insertVelocity}});
        document.dispatchEvent(velocityEvent);
      }


      this.handleScroll = function(){
        displaySettings.vScroll = window.scrollY;
      };

      this.rendering = false;

      function render() {
        setTimeout(function() {
          if(that.rendering && rhomb.isPlaying())
            window.requestAnimationFrame(render);

          // draw the time marker on the overlay
          redrawOverlay(root, displaySettings);
          var ticks = rhomb.seconds2Ticks(rhomb.getPosition());
          drawTimeMarker(overlayContext, ticks, overlayCanvas.getAttribute("height"), displaySettings);

          if(that.scrollWithMusic){
            if(ticks <= displaySettings.startOffsetTicks)
              pianoroll.scrollLeft = 0;
            else
            {
              var scrollTo = ((ticks - displaySettings.startOffsetTicks) / displaySettings.TPP) * 0.9;
              if((pianoroll.scrollLeft + window.innerWidth * 0.5) < scrollTo){
                pianoroll.scrollLeft = scrollTo - window.innerWidth * 0.5;
              }
            }
          }

          // The tick value can become negative when playback loops around
          // This is to 'correct' the tick value so that the time display is more accurate
          if (ticks < 0) {
            ticks = rhomb.getLoopEnd() + ticks;
          }

          // In most composing software, the song starts at  1.1.1.0, not 0.0.0.0
          var timeEvent = new CustomEvent("denoto-setcurrenttime", {"detail": {"ticks": ticks}});
          document.dispatchEvent(timeEvent);

        }, 1000/45);
      }

      function setHeights(height) {
        root.getElementById("kbwrapper").style.height = (height + 203) + "px";
        notepane.style.height = (height + 130) + "px";
        grouppane.style.height = (height + 130) + "px";
        trackpane.style.height = (height + 130) + "px";
        pianoroll.style.height = (height + 50) + "px";
        canvas.style.height = height + "px"; // resize canvas screen space without changing its buffer size
        bgCanvas.setAttribute("height", 23 * 12);
        //var footertop = (height + 180) < (window.innerHeight - 100) ? (height + 180) : (window.innerHeight - 100);
        var footertop = (height + 180) < (window.innerHeight - 185) ? (height + 180) : (window.innerHeight - 185);
        root.getElementById("footer").style.top = footertop + "px";

        root.getElementById('filler').setAttribute("height", height);

        overlayCanvas.style.height = (height + 30) + "px"; // resize canvas screen-space without changing its buffer size
      }

      function setWidths(width) {
        canvas.style.width = width + "px";
        canvas.setAttribute("width", width);
        automation.setAttribute("width", width);
        bgCanvas.setAttribute("width", 1920 / displaySettings.TPP);
        root.getElementById('filler').style.width = width + "px";
        footerCanvas.setAttribute("width", width);
        bgMeasurebar.setAttribute("width", width);
        fgMeasurebar.setAttribute("width", width);
        screenposition.style.width = ((document.body.clientWidth - 370) * pianoroll.clientWidth) / pianoroll.scrollWidth + "px";
        
        overlayCanvas.setAttribute("width", width); // resize canvas buffer
        overlayCanvas.style.width = width + "px";   // resize canvas screen-space
      }

      function setupScrolling() {
        // move the screen position indicator
        var offset = canvas.getBoundingClientRect();
        var width = document.body.clientWidth - 370;
        screenposition.style.width = (width * pianoroll.clientWidth) / pianoroll.scrollWidth + "px";
        screenposition.style.left = ((width - parseInt(screenposition.style.width)) * (100 - offset.left)) / (pianoroll.scrollWidth - pianoroll.clientWidth) + "px";
        footerCanvas.style.width = width + "px";

        var scrollButton = undefined;
        footerCanvas.addEventListener("mousedown", scrollPreview);
        screenposition.addEventListener("mousedown", scrollPreview);
        document.addEventListener("mousemove", function() {
          if (scrollButton === 0)
            scrollPreview();
        });
        document.addEventListener("mouseup", function() {
          scrollButton = undefined;
        });

        function scrollPreview() {
          that.scrollWithMusic = false;
          event.preventDefault();

          // get page coordinates for the mouse that account for scrolling
          var pageOffset = document.body.getBoundingClientRect();
          var offset = footerCanvas.getBoundingClientRect();
          var mouseX = event.pageX - (offset.left - pageOffset.left);
          var coord = mouseX - (parseInt(screenposition.style.width) / 2);

          if (coord < 0)
            coord = 0;

          if (coord + screenposition.clientWidth > footerCanvas.clientWidth)
            coord = footerCanvas.clientWidth - screenposition.clientWidth;

          screenposition.style.left = coord + "px";

          var scrollLeft = Math.round((pianoroll.scrollWidth - pianoroll.clientWidth) * (coord / (footerCanvas.clientWidth - screenposition.clientWidth)));
          pianoroll.scrollLeft = scrollLeft;
          automation.setAttribute("scrollLeft", scrollLeft);
          document.body.focus();

          scrollButton = event.button;

          displaySettings.scrollCoord = coord;
        }

        that.scrollToCoord = function(coord) {
          if (coord < 0)
            coord = 0;

          if (coord + screenposition.clientWidth > footerCanvas.clientWidth)
            coord = footerCanvas.clientWidth - screenposition.clientWidth;

          screenposition.style.left = coord + "px";

          var scrollLeft = Math.round((pianoroll.scrollWidth - pianoroll.clientWidth) * (coord / (footerCanvas.clientWidth - screenposition.clientWidth)));
          pianoroll.scrollLeft = scrollLeft;
          automation.setAttribute("scrollLeft", scrollLeft);
          document.body.focus();

          var offset = canvas.getBoundingClientRect();
          bgMeasurebar.style.left = offset.left + "px";
          fgMeasurebar.style.left = offset.left + "px";

          scrollButton = event.button;
        }

        // resize the footer when window is resized
        window.addEventListener('resize', resizeScrollbar);
        window.addEventListener('resize', setUIHeights);

        function setUIHeights() {
          var height = window.innerHeight - 276;
          var footertop = (height + 180) < (window.innerHeight - 185) ? (height + 180) : (window.innerHeight - 185);
          root.getElementById("footer").style.top = footertop + "px";
        }

        // make the measure bar scroll with the rest of the piano roll
        root.getElementById("pianoroll").addEventListener("scroll", function() {
          var offset = canvas.getBoundingClientRect();
          var pianoroll = root.getElementById("pianoroll");
          bgMeasurebar.style.left = offset.left + "px";
          fgMeasurebar.style.left = offset.left + "px";

          // move the screen position indicator
          var width = document.body.clientWidth - 370;
          screenposition.style.left = ((width - parseInt(screenposition.style.width)) * (100 - offset.left)) / (pianoroll.scrollWidth - pianoroll.clientWidth) + "px";
          footerCanvas.style.width = width + "px";
        });
      }

      this.handleUpdateQuantization = function() {
        console.log("[Pianoroll] - Setting quantization to " + event.detail.value);

        displaySettings.quantization = event.detail.value;
        
        // redraw the guiding lines, etc.
        redrawCanvas(root, displaySettings);

        var bgImage = bgCanvas.toDataURL();
        root.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
      };

      this.handleUpdateLengthQuantization = function() {
        console.log("[Pianoroll] - Setting length quantization to " + event.detail.value);

        displaySettings.length_quantization = event.detail.value;
        
        // redraw the guiding lines, etc.
        redrawCanvas(root, displaySettings);

        var bgImage = bgCanvas.toDataURL();
        root.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
      };

      function setupTopbarEvents() {
        document.getElementById('header_name').addEventListener("keyup", function() {
          if (event.keyCode === 13) {
            // handle changed name here
          }
        });

        document.addEventListener('denoto-settimesignature', function() {
          displaySettings.timesig_num = event.detail.numerator;
          displaySettings.timesig_den = event.detail.denominator;
          
          // redraw the guiding lines, etc.
          redrawCanvas(root, displaySettings);        
        });

        document.addEventListener('denoto-snapto', function() {
          displaySettings.snapto = event.detail.snapto;
        });

        document.addEventListener('denoto-selectmode', function() {
          mode = 'select';
          overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
        });

        document.addEventListener('denoto-showguides', function() {
          displaySettings.showguides = event.detail.showguides;
          redrawCanvas(root, displaySettings);
        });

        document.addEventListener('denoto-drawmode', function() {
          mode = 'draw';
          overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';
        });

        // update the measure bar to either show or not show the loop
        document.getElementById("transportbar").addEventListener("denoto-loopToggle",
          function() {
            displaySettings.loopEnabled = ! displaySettings.loopEnabled;

            // redraw the loop bar
            eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
            drawLoop(fgMeasurebarContext, loopbar, displaySettings);
          });

        // handle loop changes  
        document.addEventListener('denoto-updateloopstart',
          function() {
            eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
            loopbar.start = event.detail.start;
            drawLoop(fgMeasurebarContext, loopbar, displaySettings);
          });

        document.addEventListener('denoto-updateloopend',
          function() {
            eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
            loopbar.end = event.detail.end;
            drawLoop(fgMeasurebarContext, loopbar, displaySettings);
          });

        // move the time marker as necessary
        document.addEventListener('denoto-play', function() {
          playing = true;
          that.scrollWithMusic = true;
          render();
        });

        document.addEventListener('denoto-stop', function() {
          playing = false;
        });

        document.addEventListener('rhombus-stop', function() {
          playing = false;
        });

        document.addEventListener('rhombus-start', function() {
          playing = true;
          that.scrollWithMusic = true;
          render();
        });

        document.addEventListener('rhombus-newbuffernote', function() {
          drawNotes(root, rhomb.Record.dumpBuffer(), displaySettings);
        });

        document.addEventListener('denoto-updatestartpos', function() {
          render();
        });
      }

      function redrawEverything() {
        canvas.style.imageRendering = "pixelated";

        var autoEvent = new CustomEvent("denoto-refreshautomation", {});
        document.dispatchEvent(autoEvent);

        // resize any needed elements due to zooming or length changes
        var width = (displaySettings.maxmeasures * displaySettings.timesig_num * Math.floor((480 * 4) / displaySettings.timesig_den)) / displaySettings.TPP;
        setWidths(width);

        overlayCanvas.style.height = (parseInt(canvas.style.height) + 30) + "px";

        // redraw the guiding lines, etc.
        redrawCanvas(root, displaySettings);

        // redraw the notes with their new location/sizes
        if(typeof that.pattern !== 'undefined') {
          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
          drawNotes(root, rhomb.Record.dumpBuffer(), displaySettings);
        }

        // redraw the loop bar
        clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
        drawLoop(fgMeasurebarContext, loopbar, displaySettings);

        // redraw the measure bar
        drawMeasureBar(root, displaySettings);

        // redraw the overlay
        redrawOverlay(root, displaySettings);

        if(typeof rhomb !== 'undefined'){
          var ticks = rhomb.seconds2Ticks(rhomb.getPosition());
          drawTimeMarker(overlayContext, ticks, overlayCanvas.getAttribute("height"), displaySettings);
        }

        // update the overview image on the footer
        footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
        footerContext.drawImage(canvas, 0, 0);

        // resize the scroll bar
        resizeScrollbar();
      }

      function setNotePropertiesPane(notes){
        if(notes.length === 1){
          // display the note's properties in the window
          note_start.setAttribute("value", notes[0].getStart());
          note_length.setAttribute("value", notes[0].getLength());
          note_pitch.setAttribute("value", notes[0].getPitch());
          var vel = Math.round(notes[0].getVelocity() * 1000) / 1000.0;
          note_velocity.setAttribute("value", vel);
        } else {
          // clear the note properties in the window
          note_start.setAttribute("value", "");
          note_length.setAttribute("value", "");
          note_velocity.setAttribute("value", "");
        }
      }

      function setGroupPropertiesPane(notes){
        if(notes.length > 1){
          // display the group's properties in the window
          group_start.setAttribute("value", notes[0].getStart());
        } else {
          // clear the group properties in the window
          group_start.setAttribute("value", "");
        }
      }

      // used for "close enough" calculations in the UI
      function isWithinRange(cursorX, edgeX) {
        return (cursorX > edgeX - 5) && (cursorX < edgeX + 5);
      }

      function mouseOverNote(mouseX, note, displaySettings) {
        if (typeof note === 'undefined')
          return "none";
        else if (isWithinRange(mouseX, ((note.getStart() + note.getLength()) / displaySettings.TPP)))
          return "resize";
        // else if (isWithinRange(mouseX, (note.getStart() / displaySettings.TPP)))
        //   return "resize";
        else if ((note.getStart() / displaySettings.TPP) < mouseX && mouseX < ((note.getStart() + note.getLength()) / displaySettings.TPP))
          return "mouseover";
        else
          return "none";
      }

      function mouseOverNotes(mouseX, notes, displaySettings){
        var status = "none";
        for(var i in notes){
          status = mouseOverNote(mouseX, notes[i], displaySettings);
          if(status !== "none")
            return status;
        }
        return status;
      }

      function mouseDownNote(mouseX, note, displaySettings) {
        if (typeof note === 'undefined')
          return "none";
        else if (isWithinRange(mouseX, ((note.getStart() + note.getLength()) / displaySettings.TPP)))
          return "resize-duration";
        // else if (isWithinRange(mouseX, (note.getStart() / displaySettings.TPP)))
        //   return "resize-start";
        else if ((note.getStart() / displaySettings.TPP) < mouseX && mouseX < ((note.getStart() + note.getLength()) / displaySettings.TPP))
          return "move";
        else
          return "none";
      }

      function mouseDownNotes(mouseX, notes, displaySettings){
        var status = "none";
        for(var i in notes){
          status = mouseDownNote(mouseX, notes[i], displaySettings);
          if(status !== "none")
            return status;
        }
        return status;
      }

      function snapToFloor(mouse){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.quantization / displaySettings.TPP;
          mouse.x = Math.floor(mouse.x / adjustment) * adjustment;
          mouse.tick = mouse.x * displaySettings.TPP;
        }
        return mouse;
      }

      function snapToCeil(mouse){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.length_quantization / displaySettings.TPP;
          if (displaySettings.length_quantization === "insert") {
            adjustment = displaySettings.quantization / displaySettings.TPP;
          }
          mouse.x = Math.ceil(mouse.x / adjustment) * adjustment;
          mouse.tick = mouse.x * displaySettings.TPP;
        }
        return mouse;
      }

      function quantizeLengthFloor(ticks){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.length_quantization;
          if (displaySettings.length_quantization === "insert") {
            adjustment = displaySettings.quantization;
          }
          ticks = Math.floor(ticks / adjustment) * adjustment;
        }
        return ticks;
      }

      function quantizeLengthCeil(ticks){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.length_quantization;
          if (displaySettings.length_quantization === "insert") {
            adjustment = displaySettings.quantization;
          }
          ticks = Math.ceil(ticks / adjustment) * adjustment;
        }
        return ticks;
      }

      function quantizeFloor(ticks){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.quantization;
          ticks = Math.floor(ticks / adjustment) * adjustment;
        }
        return ticks;
      }

      function quantizeRound(ticks){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.quantization;
          ticks = Math.round(ticks / adjustment) * adjustment;
        }
        return ticks;
      }

      function quantizeCeil(ticks){
        if (displaySettings.snapto) {
          var adjustment = displaySettings.length_quantization;
          ticks = Math.ceil(ticks / adjustment) * adjustment;
        }
        return ticks;
      }

      // event listeners for drawing/moving/selecting/changing notes
      this.overlayMousedown = function() {
        // make sure focus is removed from any text fields when drawing/selecting in the canvas
        document.activeElement.blur();

        var pageOffset = document.body.getBoundingClientRect();
        var offset = bgMeasurebar.getBoundingClientRect();
        var mouseY = event.pageY - (offset.top - pageOffset.top);
        var mouseX = event.pageX - (offset.left - pageOffset.left);

        // handle in piano roll if below the measure bar
        if (mouseY > bgMeasurebar.getAttribute("height")) {
          handleMousedown();
        }
        else {
          button = event.button;
          if (typeof displaySettings.startOffsetTicks !== 'undefined')
            rhomb.moveToPositionTicks(mouseX * displaySettings.TPP + displaySettings.startOffsetTicks);
          else
            rhomb.moveToPositionTicks(mouseX * displaySettings.TPP);
          
          var posEvent = new CustomEvent("denoto-updatestartpos");
          document.dispatchEvent(posEvent);
        }
      };

      // handles mouse down events within the canvas
      function handleMousedown() {
        that.scrollWithMusic = false;
        event.preventDefault();
        button = event.button;
        var mouse = getMousePosition(canvas);
        var singleSelect = true;
        var clickedNotes = that.pattern.getNotesAtTick(Math.round(mouse.tick), mouse.pitch, mouse.pitch, singleSelect);

        if(button === 2) {
          that.pattern.deleteNotes(clickedNotes);
          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
        }
        else if(mode === 'select') {
          deltaTick = 0;
          deltaPitch = 0;
          addSet = [];
          if(event.ctrlKey){
            for(var i in clickedNotes){
              //clickedNotes[i].toggleSelect();
              if(!clickedNotes[i].getSelected()){
                clickedNotes[i].select();
                addSet.push(clickedNotes[i]._id);
              } else {
                clickedNotes[i].deselect();
                drawNote(context, clickedNotes[i], displaySettings);
                clickedNotes[i].select();
              }
            }
          } else {
            var unclicked = false;
            for(var i in clickedNotes){
              if(!clickedNotes[i].getSelected()){
                unclicked = true;
                break;
              }
            }
            if(unclicked)
              that.pattern.clearSelectedNotes();

            for(var i in clickedNotes){
              clickedNotes[i].select();
            }
          }

          if(clickedNotes.length === 0) {
            status = undefined;
            overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';

            if(!event.ctrlKey){
              that.pattern.clearSelectedNotes();
            }

            that.startRectMouse = getMousePosition(canvas);

            that.startRectDiv = document.createElement("div");
            that.startRectDiv.style.position = "absolute";
            that.startRectDiv.style.left = that.startRectMouse.x + "px";
            that.startRectDiv.style.top = (that.startRectMouse.origY + 33) + "px";
            that.startRectDiv.style.width = "1px";
            that.startRectDiv.style.height = "1px";
            that.startRectDiv.style.background = "#8888FF";
            that.startRectDiv.style.opacity = "0.4";
            that.startRectDiv.style.zIndex = "1";
            that.startRectDiv.style.borderStyle = "solid";
            that.startRectDiv.style.borderColor = "#000000";
            pianoroll.appendChild(that.startRectDiv);
          } else {
            that.startRectMouse = undefined;
          }

          var selectedNotes = that.pattern.getSelectedNotes();
          setNotePropertiesPane(selectedNotes);
          setGroupPropertiesPane(selectedNotes);
          previewSet = [];
          for(var i in selectedNotes){
            var n = selectedNotes[i];
            previewSet.push(new Rhombus.Note(+n._pitch, +n._start, +n._length, +n._velocity, rhomb));
          }

          status = mouseDownNotes(mouse.x, clickedNotes, displaySettings);
          if (event.ctrlKey && status !== "none") {
            status = "move";
          }
          if (status === 'move' && selectedNotes.length > 0){
            mouse = snapToFloor(mouse);
            Xoffset = mouse.x - (selectedNotes[0].getStart() / displaySettings.TPP);
            pitchStart = mouse.pitch;
          } else if(status === 'resize-duration') {
            Xoffset = mouse.x;
          }

          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
        }
        // draw mode
        else if (clickedNotes.length === 0) {
          mouse = snapToFloor(mouse);

          var quantVal = (displaySettings.length_quantization === "insert") ?
            displaySettings.quantization : displaySettings.length_quantization;

          var length = displaySettings.snapto ? quantVal : 1;

          preview = new Rhombus.Note(+mouse.pitch, +mouse.tick, +length, +insertVelocity, rhomb);
          Xoffset = mouse.x;

          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
          drawNote(context, preview, displaySettings);
        }
        
        // handle if any panes need to change
        if (!event.ctrlKey) {
          showPanes();
        }
      }

      function handleMousemove() {
        var mouse = getMousePosition(canvas);
        var overNotes = that.pattern.getNotesAtTick(Math.round(mouse.tick), mouse.pitch, mouse.pitch);

        if(button === 2){
          rhomb.Edit.deleteNotes(overNotes, that.ptnId);
          redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
        }
        else if (mode === 'draw') {
          mouse = snapToCeil(mouse);
          overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

          if (typeof preview !== 'undefined') {
            var length = mouse.tick - preview.getStart();
            length = quantizeLengthCeil((length < 1) ? 1 : length); // notes have a minimum length of one
            preview._length = length;
            redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
            drawNote(context, preview, displaySettings);
          }
        }
        else {
          if (typeof that.startRectMouse === 'undefined' && (typeof status === 'undefined' || (status !== "resize-duration" && status !== "resize-start" && status !== "move"))) {
            status = mouseOverNotes(mouse.x, overNotes, displaySettings);
          }

          if (typeof button !== 'undefined' && status === "resize-duration") {
            overlayCanvas.style.cursor = "ew-resize";
            
            var selectedNotes = that.pattern.getSelectedNotes();
            deltaTick = (mouse.tick - Xoffset * displaySettings.TPP);

            if (displaySettings.snapto) {
              deltaTick = quantizeTick(deltaTick, displaySettings.length_quantization);
            }

            redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);

            for (var i in selectedNotes) {
              var note = selectedNotes[i];
              var end = note.getStart() + note.getLength();
              var offset = quantizeTick(end, displaySettings.length_quantization) - end;
              var length = selectedNotes[i].getLength() + deltaTick;
              if(length > 0) {
                previewSet[i]._length = length + offset;
              }
            }

            previewNotes(root, previewSet, displaySettings);

            setNotePropertiesPane(previewSet);
            setGroupPropertiesPane(previewSet);
          }
          else if (typeof that.startRectMouse !== 'undefined') {
            // draw the current rectangle
            var width = (mouse.origX - that.startRectMouse.origX);
            var height = (mouse.origY - that.startRectMouse.origY);

            var left = (width < 0) ? mouse.origX : that.startRectMouse.origX;
            var top = (height < 0) ? (mouse.origY + 33) : (that.startRectMouse.origY + 33);

            that.startRectDiv.style.left = left + "px";
            that.startRectDiv.style.top = top + "px";
            that.startRectDiv.style.width = Math.abs(width) + "px";
            that.startRectDiv.style.height = Math.abs(height) + "px";
          }
          else if (typeof previewSet !== 'undefined' && status === "resize-start") {
            // do nothing for now
            /*overlayCanvas.style.cursor = "ew-resize";*/
          }
          else if (typeof previewSet !== 'undefined' && status === "move") {
            overlayCanvas.style.cursor = "move";

            var selectedNotes = that.pattern.getSelectedNotes();
            if (selectedNotes.length > 0) {

              deltaTick  = (mouse.tick - Xoffset * displaySettings.TPP) - selectedNotes[0].getStart();
              
              if (displaySettings.snapto) {
                deltaTick = Math.floor(deltaTick/displaySettings.quantization) * displaySettings.quantization;
              }

              deltaPitch = mouse.pitch - pitchStart;

              // figure out how far out of quantization the leading selected note is so that
              // we can offset the quantization for the group of selected notes
              var quantizeOffset = 0;
              if (displaySettings.snapto) {
                var quantizedStart = quantizeTick(selectedNotes[0].getStart(), displaySettings.quantization);
                quantizeOffset = quantizedStart - selectedNotes[0].getStart();
              }

              if(rhomb.Edit.isValidTranslation(selectedNotes, deltaPitch, deltaTick + quantizeOffset)) {
                redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);

                var start;
                var pitch;
                for(var i in selectedNotes){

                  previewSet[i]._start = selectedNotes[i].getStart() + deltaTick + quantizeOffset;
                  previewSet[i]._pitch = selectedNotes[i].getPitch() + deltaPitch;
                }

                if(!event.ctrlKey){
                  previewNotes(root, previewSet, displaySettings);
                } else {
                  drawNotes(root, previewSet, displaySettings);
                }

                setNotePropertiesPane(previewSet);
                setGroupPropertiesPane(previewSet);
              }
            }
          }
          else {
            if (status !== "mouseover" && status !== "resize") {
              status = mouseOverNotes(mouse.x, overNotes, displaySettings);
            }

            if (status === "resize") {
              overlayCanvas.style.cursor = "ew-resize";
            }
            else if (status === "mouseover") {
              overlayCanvas.style.cursor = "move";
            }
            else {
              overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
            }
          }
        }

        // handle if any panes need to change
        if (!event.ctrlKey) {
          showPanes();
        }
      }

      function handleMouseup() {
        redrawEverything();

        // update the overview image on the footer
        footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
        footerContext.drawImage(canvas, 0, 0);

        button = undefined;

        if(typeof that.startRectMouse !== 'undefined'){
          // select notes in range
          var mouse = getMousePosition(canvas);

          var start = (that.startRectMouse.tick < mouse.tick) ? that.startRectMouse.tick : mouse.tick;
          var end = (that.startRectMouse.tick > mouse.tick) ? that.startRectMouse.tick : mouse.tick;;
          var low = (mouse.pitch > that.startRectMouse.pitch) ? that.startRectMouse.pitch : mouse.pitch;
          var high = (mouse.pitch < that.startRectMouse.pitch) ? that.startRectMouse.pitch : mouse.pitch;

          var rectNotes = rhomb.Edit.getNotesInRange(that.ptnId, start, end, low, high);

          for(var i in rectNotes){
            rectNotes[i].select();
          }

          setNotePropertiesPane(rectNotes);
          setGroupPropertiesPane(rectNotes);

          pianoroll.removeChild(that.startRectDiv);

          // reset the selection rectangle
          that.startRectMouse = undefined;
          that.startRectDiv = undefined;
        }

        var selectedNotes = that.pattern.getSelectedNotes();

        if (mode === 'draw' && typeof preview !== 'undefined') {
          rhomb.Edit.insertNote(preview, that.ptnId);
        } 
        else if (status === "resize-duration" || status === "resize-start") {
          if(typeof deltaTick !== 'undefined') {
            if (selectedNotes.length !== previewSet.length) {
              console.log("[Pianoroll] - preview/selection mismatch: " + selectedNotes.length + ", " + previewNotes.length);
            }
            else {
              var lengths = new Array(previewSet.length);
              for (var i = 0; i < previewSet.length; i++) {
                lengths[i] = previewSet[i].getLength();
              } 

              rhomb.Edit.applyNoteLengths(selectedNotes, lengths);
            }
          }
        } 
        else if (status === "resize-start") {
          // batch change note length here once it's implemented
        } 
        else if (status === "move" || mode === "select") {
          if(typeof deltaPitch !== 'undefined' && typeof deltaTick !== 'undefined' && typeof selectedNotes !== 'undefined' && typeof selectedNotes[0] !== 'undefined') {
            if(!event.ctrlKey) {
              // move the notes
              var quantizeOffset = 0;
              if (displaySettings.snapto) {
                var quantizedStart = quantizeTick(selectedNotes[0].getStart(), displaySettings.quantization);
                quantizeOffset = quantizedStart - selectedNotes[0].getStart();
              }
              rhomb.Edit.translateNotes(that.ptnId, selectedNotes, deltaPitch, deltaTick + quantizeOffset);
              for(var i in selectedNotes){
                selectedNotes[i].select();
              }
              that.redrawAllNotes();
            } else {
              // copy the notes if the movement distance is at least the quantization value,
              // or 15 ticks (whichever is greater)
              var quant = (displaySettings.snapto) ? displaySettings.quantization : 0;
              if (Math.abs(deltaTick) >= 15 && Math.abs(deltaTick) >= quant || deltaPitch !== 0) {
                that.pattern.clearSelectedNotes();
                rhomb.Edit.insertNotes(previewSet, that.ptnId, 0);
                for(var i in previewSet){
                  previewSet[i].select();
                }
              } else {
                // no movement occurred, just toggle the select
                var mouse = getMousePosition(canvas);
                var clickedNotes = that.pattern.getNotesAtTick(Math.round(mouse.tick), mouse.pitch, mouse.pitch, true);
                for(var i in clickedNotes){
                  if(!clickedNotes[i].getSelected())
                    clickedNotes[i].select();
                  var add = false;
                  for(var j in addSet){
                    if(clickedNotes[i]._id === addSet[j])
                      add = true;
                  }
                  if(!add)
                    clickedNotes[i].deselect();
                }
              }
            }

            that.redrawAllNotes();
          }
        }

        // reset preview to undefined
        preview = undefined;
        status = undefined;
        previewSet = undefined;
        deltaPitch = undefined;
        deltaTick = undefined;
        Xoffset = undefined;
        pitchStart = undefined;

        // determine if the displayed panes need to change
        showPanes();

        redrawEverything();
      }

      // used to handle note property updates
      function handleNoteKeyUp()
      {
        if (event.keyCode == 13) {

          var selectedNotes = that.pattern.getSelectedNotes();
          
          var start = parseInt(note_start.value);
          var length = parseInt(note_length.value);
          var pitch = parseInt(note_pitch.value);
          pitch = (pitch < 0) ? 0 : pitch;
          pitch = (pitch > 127) ? 127 : pitch;
          var velocity = parseFloat(note_velocity.value);
          if (velocity < 0 && velocity > 1.0) {
            velocity = 0.5;
          }

          if(velocity !== selectedNotes[0].getVelocity() || start !== selectedNotes[0].getStart() || length !== selectedNotes[0].getLength() || pitch !== selectedNotes[0].pitch){
            rhomb.Edit.updateNote(selectedNotes[0]._id, pitch, start, length, velocity, that.ptnId);
            redrawAllNotes(root, that.pattern.getAllNotes(), displaySettings);
          }

          var autoEvent = new CustomEvent("denoto-refreshautomation", {});
          document.dispatchEvent(autoEvent);

          setNotePropertiesPane(selectedNotes);
        }
      }

      // allow user to submit a new note start without submitting a form
      note_start.addEventListener('keyup', handleNoteKeyUp);
      note_length.addEventListener('keyup', handleNoteKeyUp);
      note_pitch.addEventListener('keyup', handleNoteKeyUp);
      note_velocity.addEventListener('keyup', handleNoteKeyUp);

      // used to handle group property updates
      function handleGroupKeyUp()
      {
        if (event.keyCode == 13) {
          // calculate how much to move everything by
          var start = parseInt(group_start.value);
          //var pitch = parseInt(group_pitch.value); // implement the UI element for this

          var selectedNotes = that.pattern.getSelectedNotes();
          var deltaTick = start - selectedNotes[0].getStart();
          var deltaPitch = 0;

          if(rhomb.Edit.isValidTranslation(selectedNotes, deltaTick, deltaPitch)){
            rhomb.Edit.translateNotes(that.ptnId, selectedNotes, deltaTick, deltaPitch);
          }

          setGroupPropertiesPane(selectedNotes);
        }
      }

      // allow user to submit a new note start without submitting a form
      group_start.addEventListener('keyup', handleGroupKeyUp);

      // shows different panes based on what is currently selected
      function showPanes() {
        var length;
        if (typeof that.pattern === "undefined") {
          console.log("[Pianoroll] - that.pattern is undefined");
        }
        else {
          length = that.pattern.getSelectedNotes().length;
        }
        if (length > 1) {
          notepane.style.display = "none";
          trackpane.style.display = "none";
          grouppane.style.display = "block";
        }
        else if (length === 0) {
          notepane.style.display = "none";
          grouppane.style.display = "none";
          trackpane.style.display = "block";
        }
        else {
          trackpane.style.display = "none";
          grouppane.style.display = "none";
          notepane.style.display = "block";
        }
      }

      redrawEverything();
    };

    pianorollPrototype.attachedCallback = function() {
      var that = this;
      var root = that.shadowRoot;
      var timeEvent = new CustomEvent('denoto-updatestartpos', {detail: undefined});
      document.dispatchEvent(timeEvent);

      canvas.style.imageRendering = "pixelated";

      // event listeners for drawing/moving/selecting/changing patterns
      overlayCanvas.addEventListener('mousedown', this.overlayMousedown);
      document.addEventListener('mousemove', this.documentMousemove);
      document.addEventListener('mouseup', this.documentMouseup);
      document.addEventListener('denoto-zoomin', this.handleZoomIn);
      document.addEventListener('denoto-zoomout', this.handleZoomOut);
      document.addEventListener('denoto-resizescrollbar', this.resizeScrollbar);
      document.addEventListener('denoto-setloopsettings', this.setLoopsettings);
      document.addEventListener('keydown', this.handleKeyDown);
      document.addEventListener('denoto-updatequantization', this.handleUpdateQuantization);
      document.addEventListener('denoto-updatelengthquantization', this.handleUpdateLengthQuantization);
      root.host.addEventListener('denoto-applydisplaysettings', this.applyDisplaySettings);
      window.addEventListener('scroll', this.handleScroll);
      document.addEventListener('denoto-redrawallnotes', this.redrawAllNotes);
      document.addEventListener('denoto-notepane-updatevelocity', this.handleNotePaneUpdateVelocity);

      var bgImage = bgCanvas.toDataURL();
      this.shadowRoot.getElementById('filler').style.backgroundImage = "url(" + bgImage + ")";
      bgCanvas.style.display = "none";

      var resizeEvent = new CustomEvent('denoto-resizescrollbar', {detail: undefined});
      document.dispatchEvent(resizeEvent);

      var loopEvent = new CustomEvent('denoto-setloopsettings', {detail: undefined});
      document.dispatchEvent(loopEvent);

      this.rendering = true;
    };

    pianorollPrototype.detachedCallback = function() {
      var that = this;
      var root = that.shadowRoot;
      // event listeners for drawing/moving/selecting/changing patterns
      overlayCanvas.removeEventListener('mousedown', this.overlayMousedown);
      document.removeEventListener('mousemove', this.documentMousemove);
      document.removeEventListener('mouseup', this.documentMouseup);
      document.removeEventListener('denoto-zoomin', this.handleZoomIn);
      document.removeEventListener('denoto-zoomout', this.handleZoomOut);
      document.removeEventListener('keydown', this.handleKeyDown);
      document.removeEventListener('denoto-updatequantization', this.handleUpdateQuantization);
      document.removeEventListener('denoto-updatelengthquantization', this.handleUpdateLengthQuantization);
      root.host.removeEventListener('denoto-applydisplaysettings', this.applyDisplaySettings);
      window.removeEventListener('scroll', this.handleScroll);
      document.removeEventListener('denoto-redrawallnotes', this.redrawAllNotes);
      document.removeEventListener('denoto-notepane-updatevelocity', this.handleNotePaneUpdateVelocity);

      var tab = document.getElementById("tabset").shadowRoot.getElementById("pattern" + that.ptnId);
      var displaysettingsEvent = new CustomEvent('denoto-displaysettings', {"detail": {"displaySettings": displaySettings, "source": that}});
      tab.dispatchEvent(displaysettingsEvent);

      this.rendering = false;
    };

    // register the element
    var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();
</script>
