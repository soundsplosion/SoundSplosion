<template>
	<style>
		#pianoroll {
			position: relative;
			left: 0px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			padding: 0px;
		}
		#bgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
		#fgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
	</style>
	<div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
</template>
<!-- Include sorted list for the noteset -->
<script src="<%= asset_path("SortedList.js")%>"></script>

<script>
    (function(){
		// declare a persistent canvas
		var canvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var pianorollPrototype = Object.create(HTMLElement.prototype);

		// keep track of mouse coordinates
		var mouseX, mouseY;
		var prevDirection, prevPreview, preview;

		// keep track of clicked key info
		var keyType, keyValue;

		// keep track of displayed notes
		var noteset = new NoteSet();

		// current cursor mode. Options: draw, select
		var mode = 'draw';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		pianorollPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			// give the noteset access to the host in order to throw events
			noteset.host = root.host;

			// get the canvas info
			canvas = root.querySelector('#bgCanvas');
			var context = canvas.getContext("2d");
			var width = canvas.getAttribute("width");
			var height = canvas.getAttribute("height");

			// fill the canvas background
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.fillStyle = "#EEEEEE";			
			context.fill();

			// draw the black key bars
			var on = true;
			var times = 0;
			for(var i = 26; i < height; i += 23){
				times++;
				if(on && times !== 7 && times !== 12){
					context.beginPath()
					context.rect(0, i, width, 23);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
					on = false;
				} else {
					on = true;
				}
				if(times === 7 || times === 12){
					context.beginPath()
					context.moveTo(0, i);
					context.lineTo(width, i);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
				}
				if(times > 12){
					times = 1;
					//on = true;
				}
			}

			// draw the measure bars
			for(var i = 0.0; i < width; i += 40.0){
				context.beginPath();
				context.linewidth = 5;
				context.moveTo(i, 0);
				context.lineTo(i, height);
				if(i % 160 === 0.0){
					context.strokeStyle = "#000000";
				} else {
					context.strokeStyle = "#666666";
				}
				context.fill();
				context.stroke();
			}

			// outline the canvas
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.linewidth = 5;
			context.strokeStyle = "#000000";
			context.stroke();

			canvas = root.querySelector('#fgCanvas');
			context = canvas.getContext("2d");

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					mode = 'select';
					canvas.style.cursor = 'auto';
				}
				else if(event.charCode === 100){ // pressed 'd'
					mode = 'draw';
					canvas.style.cursor = 'cell';

					if(typeof noteset.currentNote !== 'undefined'){
						drawRect(context, {left: (noteset.currentNote.tickstart / 3),
							top: noteset.currentNote.ypos,
							right: (noteset.currentNote.tickduration / 3),
							bottom: 23}, noteset.currentNote.color, "#000044", 5);
					}

					noteset.currentNote = undefined;
					noteset.previousNote = undefined;
				}
			});

			document.addEventListener('denoto-selectmode', function(){
				mode = 'select';
				canvas.style.cursor = 'auto';
			});

			document.addEventListener('denoto-drawmode', function(){
				mode = 'draw';
				canvas.style.cursor = 'cell';

				if(typeof noteset.currentNote !== 'undefined'){
					drawRect(context, {left: (noteset.currentNote.tickstart / 3),
						top: noteset.currentNote.ypos,
						right: (noteset.currentNote.tickduration / 3),
						bottom: 23}, noteset.currentNote.color, "#000044", 5);
				}

				noteset.currentNote = undefined;
				noteset.previousNote = undefined;
			});

			document.addEventListener('keypress', function(){
				if(event.charCode === 120){
					if(typeof noteset.currentNote !== 'undefined'){
						context.clearRect((noteset.currentNote.tickstart / 3) - 1, noteset.currentNote.ypos-1, (noteset.currentNote.tickduration / 3) + 2, noteset.currentNote.height + 2);

						// dispatch the event so that listeners can handle it
						noteset.RemoveNote(noteset.currentNote);
						noteset.currentNote = undefined;
						noteset.previousNote = undefined;
					}
				}
			});


			canvas.addEventListener('mousedown', function(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				mouseX = event.pageX - (offset.left - pageOffset.left);
				mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the piano roll
				mouseY = mouseY - mouseY % 23 + 3;

				var keyValue = (mouseY - 3) / 23;
				var key = keyValue % 12;
				var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#6666AA" : "#AAAAFF";

				if(mode === 'select'){
					//noteset.SelectNote({keyValue: keyValue, measure: measure, beat: beat});
				} else {
					preview = new Note({"keyValue": keyValue, "tickstart": mouseX * 3, "tickduration": 0, color: color});
				}
			});


			// add mouse event handling
			canvas.addEventListener('mousemove', function(){
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){
					canvas.style.cursor = 'cell';
					if(typeof mouseX !== 'undefined' && typeof mouseY !== 'undefined' && button === 0){
						// draw a preview rectangle
						var pageOffset = document.body.getBoundingClientRect();
						var offset = canvas.getBoundingClientRect();
						var x = event.pageX - (offset.left - pageOffset.left) - mouseX;
						var direction = x === 0 ? 1 : Math.abs(x)/x;
						
						var color = (keyType === "white") ? "#AAAAFF" : "#6666AA";

						// 3 ticks per pixel
						var tickstart = mouseX * 3;
						var tickduration = x * 3;

						preview = noteset.PreviewNote({tickstart: tickstart, tickduration: tickduration, keyValue: preview.keyValue});

						// clear the old rectangle
						if(typeof prevPreview !== 'undefined')
							context.clearRect((prevPreview.tickstart / 3) - 1, (prevPreview.keyValue * 23 + 3)-1, (prevPreview.tickduration / 3)+2, 25);

						// draw the new rectangle
						if(typeof preview !== 'undefined' && preview.isValid){
							drawRect(context, {left: (preview.tickstart / 3), top: mouseY, right: (preview.tickduration / 3), bottom: 23}, color, "#000044", 5);
							prevDirection = direction;
							prevPreview = preview;
						}
					}
				}
				else
					canvas.style.cursor = 'auto';
			});


			canvas.addEventListener('mouseup', function(){
				// declarations
				var color;
				var keyEvent;

				// unset the mousebutton for mousemove
				button = undefined;

				// make sure this note does not get erased when drawing the next note
				prevPreview = undefined;

				// don't draw anything if mouseX or mouseY originated outside of the canvas
				if(typeof mouseX === 'undefined' || typeof mouseY === 'undefined'){
					return;
				}

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var x = event.pageX - (offset.left - pageOffset.left) - mouseX;

				// 3 ticks per pixel
				var tickstart = mouseX * 3;
				var tickduration = x * 3;

				// determine color to draw
				if(keyType === "white"){
					color = "#AAAAFF";
				} else {
					color = "#6666AA";
				}

				// check for right-clicks
				if(event.button === 2.0){
					var myNote = noteset.SelectNote({"keyValue": keyValue, "tickstart": tickstart, "tickduration": tickduration});

					// don't remove non-existent notes
					if (myNote !== undefined) {
						// make sure a deleted note is not accidentally redrawn
						if(noteset.currentNote === myNote)
							noteset.currentNote = undefined;
						if(noteset.previousNote === myNote)
							noteset.previousNote = undefined;

						// remove the note
						noteset.RemoveNote(myNote);
						context.clearRect((myNote.tickstart / 3) - 1, mouseY-1, (myNote.tickduration / 3) + 2, 25);
					}

				} else if(mode === 'draw') {
					var myNote = noteset.AddNote(preview);

					if (myNote !== undefined) {
						drawRect(context, {left: (myNote.tickstart / 3), top: mouseY, right: (myNote.tickduration / 3), bottom: 23}, color, "#000044", 5);
					}
				} else if(mode === 'select') {
					// try to grab a note from the noteset
					var myNote = noteset.SelectNote({"keyValue": keyValue, "tickstart": tickstart, "tickduration": tickduration, color: color});
					noteset.previousNote = noteset.currentNote;
					noteset.currentNote = myNote;
					if(typeof noteset.previousNote !== 'undefined'){
						drawRect(context, {left: (noteset.previousNote.tickstart / 3),
							top: previousMouseY,
							right: (noteset.previousNote.tickduration / 3),
							bottom: 23}, noteset.previousNote.color, "#000044", 5);
					}
					if(typeof noteset.currentNote !== 'undefined'){
						drawRect(context, {left: (noteset.currentNote.tickstart / 3),
							top: mouseY,
							right: (noteset.currentNote.tickduration / 3),
							bottom: 23}, "#66FF66", "#000044", 5);
					}
					previousMouseY = mouseY;
				}

				// reset mouseX and mouseY to undefined
				mouseX = undefined;
				mouseY = undefined;
				preview = undefined;
			});


			// reset mouse attributes when mousing out of the canvas
			canvas.addEventListener('mouseout',
				function(){
					// erase any preview rectangle
					if(typeof prevPreview !== 'undefined')
						context.clearRect((prevPreview.tickstart / 3) - 1, (keyValue * 23 + 3)-1, (prevPreview.tickduration / 3)+2, 25);

					mouseX = undefined;
					mouseY = undefined;
					preview = undefined;
				});
		};

		// register the element
		var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();

// represents a set of notes to be displayed
function NoteSet(){
	this.rhomb = undefined;
	this.host = undefined;
	this.currentNote = undefined;
	this.previousNote = undefined;
	this.lanes = new Array();
	for(var i = 1; i <= 24; i++){
		this.lanes[i] = new SortedList();
	}
}

// adds a note to the noteset
NoteSet.prototype.AddNote = function(note){
	// check if the note can be added
	note = this.PreviewNote(note);
	if(typeof note === 'undefined')
		return undefined;

	// assign a new ID to the note
	// TODO: fix temporary keyValue shift
	var rnote = new rhomb.Note(note.keyValue + 35, note.tickstart, note.tickduration);
	note.rnote = rnote;
	note.ID = rnote.id;

	// insert the note into the lane
	var lane = this.lanes[note.keyValue];
	lane.insertOne(note);

	// throw rhombus note creation
	var keyEvent = new CustomEvent("denoto-writenote", {"detail":{"note": rnote}});
	this.host.dispatchEvent(keyEvent);

	// return the added note (with any necessary adjustments)
	return note;
}

// returns whether or not it would be valid to start a note here
NoteSet.prototype.IsValidLocation = function(note){
	var lane = this.lanes[note.keyValue];
	var index = lane.bsearch(note.tickstart);
	
	// check to see if this note's beginning overlaps with other notes
	if(index !== -1){
		if(lane[index].tickstart <= note.tickstart && (lane[index].tickstart + lane[index].tickduration) >= note.tickstart){
			console.log("Tickstart is too early");
			return false;
		}
		
		// check to see if this note's end overlaps with other notes
		if(index+1 < lane.length){
			if(lane[index+1].tickstart <= (note.tickstart + note.tickduration)){
				console.log("Tickend is too late");
				return false;
			}
		} else {
			if(lane[index].tickstart <= (note.tickstart + note.tickduration)){
				console.log("Tickend is too late");
				return false;
			}
		}
	}

	// if there are no overlaps, it is a valid location
	return true;
}

// adjusts an input note to make it valid (valid notes are unchanged)
NoteSet.prototype.PreviewNote = function(note){
	var lane = this.lanes[note.keyValue];

	// by default, a note is valid until proven otherwise
	note.isValid = true;

	if(note.tickduration === 0)
		note.isValid = false;
	if(note.tickduration < 0){
		note.tickstart += note.tickduration;
		note.tickduration = Math.abs(note.tickduration);
	}
	var index = lane.bsearch(note.tickstart);
	
	// check to see if this note's beginning overlaps with other notes
	if(index !== -1){
		if(lane[index].tickstart <= note.tickstart && (lane[index].tickstart + lane[index].tickduration) > note.tickstart){
			// if note is entirely within existing note, nothing to preview
			if((lane[index].tickstart + lane[index].tickduration) >= (note.tickstart + note.tickduration))
				note.isValid = false;

			// clip the beginning of the note to make it valid
			note.tickduration = (note.tickstart + note.tickduration) - (lane[index].tickstart + lane[index].tickduration);
			note.tickstart = lane[index].tickstart + lane[index].tickduration;
			if(note.tickduration <= 0)
				note.isValid = false;
		}
		
		// check to see if this note's end overlaps with other notes
		if(index+1 < lane.length){
			if(lane[index+1].tickstart < (note.tickstart + note.tickduration) && (note.tickstart + note.tickduration) < (lane[index+1].tickstart + lane[index+1].tickduration)){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index+1].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		} else {
			if(lane[index].tickstart < (note.tickstart + note.tickduration) && (note.tickstart + note.tickduration) < (lane[index].tickstart + lane[index].tickduration)){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		}
	}

	// if there are no overlaps, return the original noteset
	return note;
}

// selects a note from the noteset
NoteSet.prototype.SelectNote = function(event){
	var lane = event.keyValue;
	//var index = (event.measure - 1) * 4 + event.beat;
	//return this.lanes[lane][index];
}

// removes a note from the noteset
NoteSet.prototype.RemoveNote = function(note) {
	// shouldn't try to remove notes that don't exist
	if (note !== undefined) {
		// throw the rhombus note deletion
		var keyEvent = new CustomEvent("denoto-erasenote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);

		// remove the note from each place it was found
		var lane = this.lanes[note.keyValue];
		for(var i = note.start; i < note.end; i++){
			lane[i] = undefined;
		}
	}
}

// represents a single note that exists in the pianoroll
function Note(event){
	this.keyValue = event.keyValue;
	this.tickstart = event.tickstart;
	this.tickduration = event.tickduration;
	this.color = event.color;
	this.ID = undefined;
	this.rnote = undefined;
	this.ypos = event.ypos;
}
</script>
