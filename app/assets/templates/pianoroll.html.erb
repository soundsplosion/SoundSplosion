<template>
	<!-- Pencil icon made by <a href="http://appzgear.com" title="Appzgear">Appzgear</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>. Licensed under <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0">CC BY 3.0</a> -->
	<!-- Cursor icon adapted from cursor by Gentleface.com, licensed under Creative Commons Attribution Non-commercial (by-nc) -->
	<!-- old header is slateblue -->
	<style>
		#pianoroll {
			position: relative;
			left: 0px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			width: calc(100% - 350px);
			height: 610px;
			overflow: scroll;
		}
		#bgCanvas {
			position: absolute;
			left: 0px;
			top: 30px;
			margin: 0px;
			padding: 0px;
			z-index: 0;
		}
		#fgCanvas {
			position: absolute;
			left: 0px;
			top: 30px;
			margin: 0px;
			padding: 0px;
			z-index: 1;
		}
		#bgMeasurebar {
			position: fixed;
			left: 100px;
			top: 150px;
			margin: 0px;
			padding: 0px;
			z-index: 0;
		}
		#fgMeasurebar {
			position: fixed;
			left: 100px;
			top: 150px;
			margin: 0px;
			padding: 0px;
			z-index: 1;
		}
		#overlayCanvas {
			position: absolute;
			left: 0px;
			top: 0px;
			margin: 0px;
			padding: 0px;
			z-index: 2;
		}
		#kbwrapper{
			background: #172837;
			height: 620px;
			width: 100px;
			float: left;
			z-index: 2;
			position: relative;
			padding-top: 7px;
		}
		#appkeyboard {
			background: #172837;
			float: left;
			position: relative;
			top: 30px;
		}
		#noteproperties {
			display: none;
			/*background: #252477;*/
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#notepropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			/*background: slateblue;*/
		}
		#noteproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#groupproperties {
			display: none;
			/*background: #252477;*/
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#grouppropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			/*background: slateblue;*/
		}
		#groupproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#instrumentproperties {
			display: block;
			/* background: #252477;*/
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#instrumentpropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
			/*background: slateblue;*/
		}
		#instrumentproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
		}
		.biggertext{
			font-family: 'Oswald';
			font-size: 20px;
			opacity: 0.85;
			color: #FFF;
		}
		.shorttextbox {
			width: 50px;
		}
		.slider {
			position: relative;
			top: 5px;
			width: 110px !important;
		}
		#preload{
			display: none;
		}
	</style>
	<div id="noteproperties">
		<div id="notepropertiesHeader"><h3>Note Properties</h3></div>
		<!--<p>Start <input type="text" id="note_start"></input></p>
		<p>Length <input type="text" id="note_length"></input></p>-->
		<p>Start: <denoto-editabletext type="shorttext" id="note_start" width="50"></denoto-editabletext></p>
		<p>Length: <denoto-editabletext type="shorttext" id="note_length" width="50"></denoto-editabletext></p>
		<p>Auto-adjust <input type="checkbox" id="note_autoadjust" checked></p>
	</div>
	<div id="groupproperties">
		<div id="grouppropertiesHeader"><h3>Group Properties</h3></div>
		<p>Start: <denoto-editabletext type="text" id="group_start" width="50"></denoto-editabletext></p>
		<p>Length: <denoto-editabletext type="text" id="group_length" width="50"></denoto-editabletext></p>
		<p>Auto-adjust <input type="checkbox" id="group_autoadjust" checked></p>
	</div>
	<div id="instrumentproperties">
		<div id="instrumentpropertiesHeader"><h3>Instrument Properties</h3></div>
		<p>Cutoff		<input class="slider" id="cutoff" type="range" min="-12" max="72" step="1" value="24" />     <denoto-editabletext width="25" id="cutoff_text" type="shorttext" value="24"></denoto-editabletext></p> <!-- cutoff, -36 to 36 (singlestepped) -->
		<p>Resonance	<input class="slider" id="resonance" type="range" min="0" max="24" step="1" value="6" />     <denoto-editabletext width="25" id="resonance_text" type="shorttext" value="6"></denoto-editabletext></p> <!-- resonance (res), 0 to 24 (singlestepped) -->
		<p>Mod			<input class="slider" id="mod" type="range" min="0" max="200" step="1" value="30" />         <denoto-editabletext width="25" id="mod_text" type="shorttext" value="3"></denoto-editabletext></p> <!-- depth, 0 to 20 (singlestepped) -->
		<p>Attack		<input class="slider" id="attack" type="range" min="0" max="100" step="1" value="0" />       <denoto-editabletext width="25" id="attack_text" type="shorttext" value="0"></denoto-editabletext></p> <!-- attack, 0 to 5 (100 steps) -->
		<p>Decay		<input class="slider" id="decay" type="range" min="0" max="100" step="1" value="5" />        <denoto-editabletext width="25" id="decay_text" type="shorttext" value="0.5"></denoto-editabletext></p> <!-- decay, 0 to 5 (100 steps) -->
		<p>Release time <input class="slider" id="release_time" type="range" min="0" max="200" step="1" value="10"/> <denoto-editabletext width="25" id="release_time_text" type="shorttext" value="0.5"></denoto-editabletext></p> <!-- release time, 0 to 5 (100 steps) -->
		<p>Feedback		<input class="slider" id="feedback" type="range" min="0" max="100" step="1" value="50" />    <denoto-editabletext width="25" id="feedback_text" type="shorttext" value="0.5"></denoto-editabletext></p> <!-- feedback, 0 to 1 (100 steps) -->
		<p>Echo			<input class="slider" id="echo" type="range" min="0" max="100" step="1" value="50" />        <denoto-editabletext width="25" id="echo_text" type="shorttext" value="0.5"></denoto-editabletext></p> <!-- echo, 0 to 1 (100 steps) -->
		<p>Echo Enabled <input id="echoEnabled" type="checkbox" /></p>
	</div>
	<div id="kbwrapper">
		<denoto-keyboard id="appkeyboard" keycount="61"></denoto-keyboard>
	</div>
	<div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
	<!--<canvas id="bgCanvas" width="32767" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas> MAX WIDTH CANVAS -->
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="bgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="overlayCanvas" width="3600" height="590" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
	<div id="preload">
		<img src='<%= asset_path("tb_pencil_cursor.png")%>' />
		<img src='<%= asset_path("tb_cursor_auto.png")%>' />
	</div>
</template>
<!-- Include sorted list for the noteset -->
<script src="<%= asset_path("SortedList.js")%>"></script>
<script src="<%= asset_path("noteset.js")%>"></script>

<script>
    (function(){
    	// keep track of display settings like ticks per pixel (AKA zoom level), and whether to show measure guides
    	var displaySettings = {TPP: 4, showguides: true, loopEnabled: false};

		// declare a persistent canvas
		var canvas;
		var bgMeasurebar, fgMeasurebar;
		var overlayCanvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var pianorollPrototype = Object.create(HTMLElement.prototype);

		// keep track of whether or not the notes are playing
		var playing = false;

		// keep track of preview notes
		var preview;
		var previewSet;
		var status;

		// keep track of loop bar
		var loopbar = {start: 0, end: 1920};
		var loopbarPreview;

		// keep track of displayed notes
		var noteset;// = new NoteSet();

		// current cursor mode. Options: draw, select
		var mode = 'draw';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		pianorollPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			var appkeyboard = root.getElementById("appkeyboard");

			// set up notesey
			noteset = new NoteSet(appkeyboard.getAttribute("keycount"));

			// give the noteset access to the host in order to throw events
			noteset.host = root.host;

			// keep track of note pane fields
			var notepane = root.getElementById("noteproperties");
			var note_start = root.getElementById("note_start");
			var note_length = root.getElementById("note_length");
			var note_autoadjust = root.getElementById("note_autoadjust");

			// keep track of group pane fields
			var grouppane = root.getElementById("groupproperties");
			var group_start = root.getElementById("group_start");
			var group_length = root.getElementById("group_length");
			var group_autoadjust = root.getElementById("group_autoadjust");

			// keep track of track pane fields
			var trackpane = root.getElementById("instrumentproperties");

			// get the canvas info
			canvas = root.querySelector('#bgCanvas');

			// resize the canvas and other elements to be the same height as the keyboard
			var keyboardHeight = parseInt(root.getElementById("appkeyboard").style.height) + 5;
			notepane.style.height = (keyboardHeight + 50) + "px";
			grouppane.style.height = (keyboardHeight + 50) + "px";
			trackpane.style.height = (keyboardHeight + 50) + "px";
			root.getElementById("kbwrapper").style.height = (keyboardHeight + 43) + "px";
			root.getElementById("pianoroll").style.height = (keyboardHeight + 50) + "px";
			canvas.setAttribute("height", keyboardHeight);

			var context = canvas.getContext("2d");
			var width = canvas.getAttribute("width");
			var height = canvas.getAttribute("height");

			// set up the background canvas
			drawCanvas(context, width, height, displaySettings);

			// set up the measure bar
			bgMeasurebar = root.querySelector('#bgMeasurebar');
			fgMeasurebar = root.querySelector('#fgMeasurebar');
			fgMeasurebarContext = fgMeasurebar.getContext("2d");
			drawMeasureBar(root, displaySettings);

			// set up the overlay
			overlayCanvas = root.querySelector('#overlayCanvas');
			overlayCanvas.setAttribute("height", keyboardHeight + 30);
			overlayContext = overlayCanvas.getContext("2d");

			canvas = root.querySelector('#fgCanvas');
			canvas.setAttribute("height", keyboardHeight);
			context = canvas.getContext("2d");

			// make the measure bar scroll with the rest of the piano roll
			root.getElementById("pianoroll").addEventListener("scroll", function(){
				var offset = canvas.getBoundingClientRect();
				bgMeasurebar.style.left = offset.left + "px";
				fgMeasurebar.style.left = offset.left + "px";
			});

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					var keyEvent = new CustomEvent("denoto-selectmode", {"detail": "select"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 100){ // pressed 'd'
					var keyEvent = new CustomEvent("denoto-drawmode", {"detail": "draw"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 99){ // pressed 'c'
					console.log(noteset); // log the current noteset to the console for debugging
				}
				else if(event.charCode === 120){ // TODO: change to use the real delete key instead of 'x'
					if(typeof noteset.currentNote !== 'undefined'){
						eraseNote(context, noteset.currentNote, displaySettings);

						// dispatch the event so that listeners can handle it
						noteset.RemoveNote(noteset.currentNote);
						noteset.currentNote = undefined;
						noteset.previousNote = undefined;
					}
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							eraseNote(context, noteset.selectedSet[index], displaySettings);
							noteset.RemoveNote(noteset.selectedSet[index]);
						}
					}
				}

				// handle if any panes need to change
				showPanes();
			});

			// listen to events thrown to this pattern editor
			root.host.addEventListener('denoto-createdpattern', function(){
				var name = event.detail.pattern._name;
				if(name == "Default Pattern Name")
					name = "[Double-click to enter pattern name]";

				noteset.pattern = event.detail.pattern;

				document.getElementById('header_name').setAttribute("value", name);
			});

			document.getElementById('header_name').addEventListener("keyup", function(){
				if(event.keyCode === 13){
					// handle changed name here
					noteset.pattern._name = event.srcElement.value;
				}
			});

			document.addEventListener('denoto-zoomin', function(){
				displaySettings.TPP = displaySettings.TPP / 2;
				if(displaySettings.TPP < 1)
					displaySettings.TPP = 1;

				// redraw the guiding lines, etc.
				redrawCanvas(root, displaySettings);

				// redraw the notes with their new location/sizes
				redrawAllNotes(root, noteset, displaySettings);

				// redraw the loop bar
				eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// redraw the loop bar
				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// redraw the measure bar
				drawMeasureBar(root, displaySettings);

				// redraw the overlay
				redrawOverlay(root, displaySettings);
			});

			document.addEventListener('denoto-zoomout', function(){
				displaySettings.TPP = displaySettings.TPP * 2;
				if(displaySettings.TPP > 16)
					displaySettings.TPP = 16;

				// redraw the guiding lines, etc.
				redrawCanvas(root, displaySettings);

				// redraw the notes with their new location/sizes
				redrawAllNotes(root, noteset, displaySettings);

				// redraw the loop bar
				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// redraw the measure bar
				drawMeasureBar(root, displaySettings);

				// redraw the overlay
				redrawOverlay(root, displaySettings);
			});

			document.addEventListener('denoto-selectmode', function(){
				mode = 'select';
				overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
			});

			document.addEventListener('denoto-showguides', function(){
				displaySettings.showguides = event.detail.showguides;
				redrawCanvas(root, displaySettings);
			});

			document.addEventListener('denoto-drawmode', function(){
				mode = 'draw';
				//overlayCanvas.style.cursor = 'cell';
				overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

				drawNote(context, noteset.currentNote, displaySettings);

				noteset.earliestStart = undefined;
				noteset.latestEnd = undefined;
				for(var index in noteset.selectedSet){
					drawNote(context, noteset.selectedSet[index], displaySettings);
				}
				if(noteset.selectedSet.length > 0){
					noteset.selectedSet = new Array();
				}

				noteset.currentNote = undefined;
				noteset.previousNote = undefined;
			});

			// update the measure bar to either show or not show the loop
			document.getElementById("transportbar").addEventListener("denoto-loopToggle",
				function(){
					displaySettings.loopEnabled = ! displaySettings.loopEnabled;

					// redraw the loop bar
					eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
					drawLoop(fgMeasurebarContext, loopbar, displaySettings);
				});

			// event listeners for drawing/moving/selecting/changing notes
			overlayCanvas.addEventListener('mousedown', function(){
				// make sure focus is removed from any text fields when drawing/selecting in the canvas
				document.activeElement.blur();

				var pageOffset = document.body.getBoundingClientRect();
				var offset = bgMeasurebar.getBoundingClientRect();
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				if(mouseY > bgMeasurebar.getAttribute("height"))
					handleMousedown();
				else
					startLoop();
			});
			document.addEventListener('mousemove', function(){
				if(typeof loopbarPreview !== 'undefined')
					previewLoop();
				else
					handleMousemove();
			});
			document.addEventListener('mouseup', function(){
				if(typeof preview !== 'undefined')
					handleMouseup();
				else if(typeof loopbarPreview !== 'undefined')
					endLoop();
			});

			// handle loop changes	
			document.addEventListener('denoto-updateloopstart',
				function(){
					eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
					loopbar.start = event.detail.start;
					drawLoop(fgMeasurebarContext, loopbar, displaySettings);
				});

			document.addEventListener('denoto-updateloopend',
				function(){
					eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
					loopbar.end = event.detail.end;
					drawLoop(fgMeasurebarContext, loopbar, displaySettings);
				});

			// move the time marker as necessary
			document.addEventListener('denoto-play', function(){
				playing = true;
				render();
			});
			document.addEventListener('denoto-stop', function(){
				playing = false;
			});

			function render(){
				// draw the time marker on the overlay
				redrawOverlay(root, displaySettings);
				drawTimeMarker(overlayContext, rhomb.seconds2Ticks(rhomb.getPosition()), overlayCanvas.getAttribute("height"), displaySettings);

				if(playing)
					window.requestAnimationFrame(render);
  			}

			function startLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				if(!displaySettings.loopEnabled)
					return;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				loopbarPreview = {start: mouseX * displaySettings.TPP, end: 0};
				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
			}

			function previewLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// do nothing if changes are not being made
				if(typeof loopbarPreview === 'undefined')
					return;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = overlayCanvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				// redraw the new loop bar
				eraseLoop(fgMeasurebarContext, loopbarPreview, displaySettings);
				
				// do not allow backwards draws
				if(mouseX * displaySettings.TPP >= loopbarPreview.start){
					loopbarPreview.end = mouseX * displaySettings.TPP;
				}
				drawLoop(fgMeasurebarContext, loopbarPreview, displaySettings);

				// send events to update the top bar fields
				var keyEvent = new CustomEvent("denoto-updateloopstart", {"detail": {"start": loopbarPreview.start}});
				document.dispatchEvent(keyEvent);
				keyEvent = new CustomEvent("denoto-updateloopend", {"detail": {"end": loopbarPreview.end}});
				document.dispatchEvent(keyEvent);
			}

			function endLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// do nothing if changes are not being made
				if(typeof loopbarPreview === 'undefined')
					return;

				// if the loop bar preview is valid, it is the new loop bar
				if(loopbarPreview.end > loopbarPreview.start){
					loopbar.start = loopbarPreview.start;
					loopbar.end = loopbarPreview.end;
				}

				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// dispatch an event that the loop has changed
				var keyEvent = new CustomEvent("denoto-updateloopstart", {"detail": {"start": loopbar.start}});
				root.host.dispatchEvent(keyEvent);
				document.dispatchEvent(keyEvent);
				keyEvent = new CustomEvent("denoto-updateloopend", {"detail": {"end": loopbar.end}});
				root.host.dispatchEvent(keyEvent);
				document.dispatchEvent(keyEvent);
				

				// reset the preview for the next time around
				loopbarPreview = undefined;
			}

			// hdndles mouse down events within the canvas
			function handleMousedown(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the piano roll
				mouseY = mouseY - mouseY % 23 + 3;

				var keyValue = (mouseY - 3) / 23;
				var key = keyValue % 12;
				var color = (key === 2 || key === 4 || key === 6 || key === 9 || key === 11) ? "#6666AA" : "#AAAAFF";
				//var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#252477" : "#A7BEE3";
				var outlinecolor = (color === "#6666AA") ? "#000044" : "#222266";
				//var outlinecolor = "#000000";

				if(mode === 'select'){

					if(!event.ctrlKey && noteset.selectedCount < 2){
						drawNote(context, noteset.currentNote, displaySettings);
					}

					preview = noteset.SelectNote({keyValue: keyValue, tickstart: mouseX * displaySettings.TPP});

					if(typeof preview === 'undefined'){
						status = undefined;
						overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';

						// deselect any notes
						drawNote(context, noteset.currentNote, displaySettings);
						noteset.previousNote = undefined;
						noteset.currentNote = undefined;

						// deselect the selected set if the user clicked outside of it without ctrl held down
						if(!event.ctrlKey){
							// redraw the formerly-selected notes as deselected
							for(var index in noteset.selectedSet){
								drawNote(context, noteset.selectedSet[index], displaySettings);
							}

							// reset the selected set to be empty
							noteset.selectedSet = new Array();
							noteset.selectedCount = 0;
						}

						// clear the note properties in the window
						note_start.setAttribute("value", "");
						note_length.setAttribute("value", "");
					} else {
						preview = new Note(preview);

						// display note's properties in the note pane if it valid and not part of a group
						if(!event.ctrlKey || typeof noteset.selectedSet[preview.ID] === 'undefined'){
							if(preview.tickduration !== 0){
								// display the note's properties in the window
								note_start.setAttribute("value", preview.tickstart);
								note_length.setAttribute("value", preview.tickduration);
							} else {
								// don't display properties for notes that can't exist in the noteset
								note_start.setAttribute("value", "");
								note_length.setAttribute("value", "");
							}
						}

						// deselect the selected set if the user clicked outside of it without ctrl held down
						if(!event.ctrlKey && typeof noteset.selectedSet[preview.ID] === 'undefined'){
							// redraw the formerly-selected notes as deselected
							for(var index in noteset.selectedSet){
								drawNote(context, noteset.selectedSet[index], displaySettings);
							}

							// reset the selected set to be empty
							noteset.selectedSet = new Array();
							noteset.selectedCount = 0;
						}

						noteset.earliestStart = undefined;
						noteset.latestEnd = undefined;

						// set up a new set of preview notes
						previewSet = new Array();
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined'){
								previewSet[index] = new Note(noteset.selectedSet[index]);

								// set the earliest and latest values
								if(typeof noteset.earliestStart === 'undefined' || previewSet[index].tickstart < noteset.earliestStart){
									noteset.earliestStart = previewSet[index].tickstart;
								}
								if(typeof noteset.latestEnd === 'undefined' || (previewSet[index].tickstart + previewSet[index].tickduration) > noteset.latestEnd){
									noteset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
								}
							}
						}

						// when only a single note is selected, its start is the earliest start, and its end is the latest end
						if(noteset.selectedCount < 2){
							noteset.earliestStart = preview.tickstart;
							noteset.latestEnd = preview.tickstart + preview.tickduration;
						}
					}

					status = mouseDownNote(mouseX, noteset, displaySettings);

					if(event.ctrlKey && status !== "none"){
						status = "move";
					}
					if (status === 'move' && typeof preview !== 'undefined'){
						preview.Xoffset = mouseX - (preview.tickstart / displaySettings.TPP);
					}
				} else {
					var temp = noteset.GetNote({"keyValue": keyValue, "tickstart": mouseX * displaySettings.TPP});
					var prev;
					if(typeof temp !== 'undefined'){
						while(typeof temp !== 'undefined'){
							prev = temp;
							temp = noteset.GetNote({"keyValue": keyValue, "tickstart": temp.tickstart + temp.tickduration + 1});
						}
						preview = new Note({"keyValue": keyValue, "tickstart": prev.tickstart + prev.tickduration, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = preview.tickstart / displaySettings.TPP;
					} else {
						preview = new Note({"keyValue": keyValue, "tickstart": mouseX * displaySettings.TPP, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = mouseX;
					}
				}
				
				// handle if any panes need to change
				if(!event.ctrlKey)
					showPanes();
			}

			function handleMousemove(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);
				mouseY = mouseY - mouseY % 23 + 3;
				var keyValue = (mouseY - 3) / 23;
				
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){
					overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

					if(typeof preview !== 'undefined' && button === 0){
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / displaySettings.TPP);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						if(x > 0 && (mouseX * displaySettings.TPP) < (preview.tickstart + preview.tickduration) && mouseX < preview.Xoffset){
							preview.tickstart += x * displaySettings.TPP;
							preview.tickduration -= x * displaySettings.TPP;
							preview = noteset.PreviewNote(preview);
						} else if (x > 0){
							preview.tickstart = preview.Xoffset * displaySettings.TPP;
							preview.tickduration = x * displaySettings.TPP;
							preview = noteset.PreviewNote(preview);
						} else if (x < 0){
							preview.tickduration -= x * displaySettings.TPP;
							preview.tickstart = preview.Xoffset * displaySettings.TPP - preview.tickduration;
							preview = noteset.PreviewNote(preview);
						}

						if(preview.isValid && (preview.tickstart + preview.tickduration >= preview.Xoffset * displaySettings.TPP || preview.tickstart >= preview.Xoffset * displaySettings.TPP)){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawNote(context, preview, displaySettings);
							}
						} else {
							preview = prevPreview;
						}
					}
				}
				else
				{
					if(typeof status === 'undefined' || (status !== "resize-duration" && status !== "resize-start" && status !== "move"))
						status = mouseOverNote(mouseX, noteset.currentNote, displaySettings);

					if (typeof preview !== 'undefined' && status === "resize-duration"){
						overlayCanvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - ((noteset.latestEnd) / displaySettings.TPP);
						var ratio = (noteset.latestEnd - noteset.earliestStart + x * displaySettings.TPP) / (noteset.latestEnd - noteset.earliestStart);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						preview.tickstart = Math.floor((noteset.currentNote.tickstart - noteset.earliestStart) * ratio + noteset.earliestStart);
						preview.tickduration = Math.ceil(noteset.currentNote.tickduration * ratio);

						// when modifying the duration, don't allow backwards "flips"
						if(preview.tickduration < 0)
							preview.tickduration = 0;
						preview = noteset.PreviewNote(preview);

						// clear the old rectangle
						if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
							eraseNote(context, prevPreview, displaySettings);

						// draw the new rectangle
						if(typeof preview !== 'undefined' && preview.isValid){
							drawSelectedNote(context, preview, displaySettings);
						}

						ResizeDurationSet(ratio, previewSet);

					}
					else if (typeof preview !== 'undefined' && status === "resize-start")
					{
						overlayCanvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = ((noteset.earliestStart) / displaySettings.TPP) - mouseX;
						var ratio = (noteset.latestEnd - noteset.earliestStart + x * displaySettings.TPP) / (noteset.latestEnd - noteset.earliestStart);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview);

						// modify the existing preview to match the new duration, and validate
						preview.tickstart = Math.floor((noteset.currentNote.tickstart - noteset.latestEnd) * ratio + noteset.latestEnd);
						preview.tickduration = Math.ceil(noteset.currentNote.tickduration * ratio);

						preview = noteset.PreviewNote(preview);

						// for single note resizes, make sure that resizing hasn't changed the endpoint (this is only supposed to resize the start)
						if(noteset.selectedCount > 1 || ((temp.tickstart + temp.tickduration) === (preview.tickstart + preview.tickduration) && preview.isValid)){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview, displaySettings);
							}
						} else {
							preview = temp;
						}

						ResizeStartSet(ratio, previewSet);
					}
					else if (typeof preview !== 'undefined' && status === "move")
					{
						overlayCanvas.style.cursor = "move";
						
						// draw a preview rectangle
						var x = mouseX - ((preview.tickstart / displaySettings.TPP) + preview.Xoffset);

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));
						var temp = new Note(preview); 

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * displaySettings.TPP;
						preview = noteset.PreviewNote(preview);

						// this is a movement, so do not allow resizing
						if(temp.tickduration === preview.tickduration && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedNote(context, preview, displaySettings);
							}
						} else {
							// if note is "stuck", make it flush with the next/previous note
							if(mouseX > (preview.tickstart + preview.tickduration) / displaySettings.TPP){
								temp.tickstart = (preview.tickstart + preview.tickduration) - temp.tickduration;
							} else if(mouseX < preview.tickstart / displaySettings.TPP){
								temp.tickstart = preview.tickstart;
							}
							
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedNote(context, temp, displaySettings);

							preview = temp;
						}

						x = preview.tickstart - noteset.currentNote.tickstart;

						MoveSet(x, previewSet);//, preview);

						// give initial values to the start and length properties of the group
						noteset.earliestStart = preview.tickstart;
						noteset.latestEnd = preview.tickstart + preview.tickduration;

						// update the start and length properties of the group
						for(var index in previewSet){
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
								if(typeof noteset.earliestStart === 'undefined' || previewSet[index].tickstart < noteset.earliestStart){
									noteset.earliestStart = previewSet[index].tickstart;
								}
								if(typeof noteset.latestEnd === 'undefined' || (previewSet[index].tickstart + previewSet[index].tickduration) > noteset.latestEnd){
									noteset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
								}
							}
						}

						// update the note properties pane with new values
						group_start.setAttribute("value", noteset.earliestStart);
						group_length.setAttribute("value", noteset.latestEnd - noteset.earliestStart);
					}
					else
					{
						var temp = noteset.GetNote({keyValue: keyValue, tickstart: (mouseX * displaySettings.TPP)});
						
						if(status !== "mouseover" && status !== "resize")
							status = mouseOverNote(mouseX, temp, displaySettings);

						if (status === "resize")
						{
							overlayCanvas.style.cursor = "ew-resize";
						}
						else if (status === "mouseover")
						{
							overlayCanvas.style.cursor = "move";
						}
						else
						{
							overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
						}
					}
				}

				// show the note preview's information
				if(typeof preview !== 'undefined' && preview.tickduration !== 0){
					// display the note's properties in the window
					root.getElementById("note_start").setAttribute("value", preview.tickstart);
					root.getElementById("note_length").setAttribute("value", preview.tickduration);
				}

				// handle if any panes need to change
				if(!event.ctrlKey)
					showPanes();
			}

			function handleMouseup(){
				// if there is not an existing note to work with, do nothing
				if(typeof preview === 'undefined'){
					status = undefined;

					// clear the note properties in the window
					root.getElementById("note_start").setAttribute("value", "");
					root.getElementById("note_length").setAttribute("value", "");

					// clear any multiselect if ctrl is not held down
					if(!event.ctrlKey){
						noteset.earliestStart = undefined;
						noteset.latestEnd = undefined;
						for(var index in noteset.selectedSet){
							drawNote(context, noteset.selectedSet[index], displaySettings);
						}
						noteset.selectedSet = new Array();
						noteset.selectedCount = 0;
					}

					return false;
				} else {
					// display the note's properties in the window
					root.getElementById("note_start").setAttribute("value", preview.tickstart);
					root.getElementById("note_length").setAttribute("value", preview.tickduration);
				}

				// unset the mousebutton for mousemove
				button = undefined;

				// don't draw anything if mouse originated outside of the canvas
				if(typeof preview === 'undefined'){
					return;
				}

				// check for right-clicks
				if(event.button === 2.0){
					// restore previous note to original appearance
					drawNote(context, noteset.previousNote, displaySettings);

					// select the previewed note
					noteset.SelectNote(preview);

					// don't remove non-existent notes
					if (typeof noteset.currentNote !== 'undefined') {
						// remove the note
						eraseNote(context, noteset.currentNote, displaySettings);
						noteset.RemoveNote(noteset.currentNote);
					}
					if(noteset.selectedCount == 1){
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined'){
								noteset.currentNote = noteset.selectedSet[index];
								note_start.setAttribute("value", noteset.currentNote.tickstart);
								note_length.setAttribute("value", noteset.currentNote.tickduration);
							}
						}
					}

				} else if(mode === 'draw') {
					var myNote = noteset.AddNote(preview);
					drawNote(context, myNote, displaySettings);

				} else if (status === "resize-duration" || status === "resize-start"){
					// reinitialize the start and end so they can be recalculated
					noteset.earliestStart = undefined;
					noteset.latestEnd = undefined;

					// set the selected note locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							noteset.selectedSet[index].tickstart = previewSet[index].tickstart;
							noteset.selectedSet[index].tickduration = previewSet[index].tickduration;
							drawSelectedNote(context, noteset.selectedSet[index], displaySettings);
							noteset.UpdateRhombNote(noteset.selectedSet[index]);

							if(typeof noteset.earliestStart === 'undefined' || noteset.selectedSet[index].tickstart < noteset.earliestStart)
								noteset.earliestStart = noteset.selectedSet[index].tickstart;
							if(typeof noteset.latestEnd === 'undefined' || (noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration) > noteset.latestEnd)
								noteset.latestEnd = noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration;
						}
					}

					// set the currently-selected note's start and duration to their new values
					noteset.currentNote.tickduration = preview.tickduration;
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview, displaySettings);

					// update note in rhombus
					noteset.UpdateRhombNote(noteset.currentNote);

				} else if (status === "move" || mode === "select"){
					// set the selected note locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
							noteset.selectedSet[index].tickstart = previewSet[index].tickstart;
						}
					}

					// set the currently-selected note's location to its new value
					noteset.currentNote.tickstart = preview.tickstart;
					drawSelectedNote(context, preview, displaySettings);

					// update the index of the current note in the sorted list
					noteset.AdjustIndex(noteset.currentNote);

					// update note in rhombus
					noteset.UpdateRhombNote(noteset.currentNote);

					// update the indices of the current notes selected set and update them in rhombus
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							noteset.AdjustIndex(noteset.selectedSet[index]);
							noteset.UpdateRhombNote(noteset.selectedSet[index]);
						}
					}
					
					if(event.ctrlKey){
						if(typeof noteset.selectedSet[noteset.currentNote.ID] !== 'undefined'){
							noteset.selectedSet[noteset.currentNote.ID] = undefined;
							noteset.selectedCount--;
							drawNote(context, noteset.currentNote, displaySettings);
							noteset.currentNote = undefined;
							noteset.previousNote = undefined;

							// update earliest and latest selected notes
							noteset.earliestStart = undefined;
							noteset.latestEnd = undefined;
							if(noteset.selectedCount > 0){
								for(var index in noteset.selectedSet){
									if(typeof noteset.selectedSet[index] !== 'undefined'){
										if(typeof noteset.earliestStart === 'undefined' || noteset.selectedSet[index].tickstart < noteset.earliestStart)
											noteset.earliestStart = noteset.selectedSet[index].tickstart;
										if(typeof noteset.latestEnd === 'undefined' || noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration > noteset.latestEnd)
											noteset.latestEnd = noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration;
									}
								}
								group_start.setAttribute("value", noteset.earliestStart);
								group_length.setAttribute("value", noteset.latestEnd - noteset.earliestStart);
							}

							// if there is only a single note in the set, then treat as a single note selection
							if(noteset.selectedCount === 1){
								for(var index in noteset.selectedSet){
									if(typeof noteset.selectedSet[index] !== 'undefined'){
										noteset.SelectNote(noteset.selectedSet[index]);
										noteset.previousNote = undefined;
									}
								}
								note_start.setAttribute("value", noteset.currentNote.tickstart);
								note_length.setAttribute("value", noteset.currentNote.tickduration);
							}

						} else {
							if(typeof noteset.earliestStart === 'undefined' || noteset.currentNote.tickstart < noteset.earliestStart){
								noteset.earliestStart = noteset.currentNote.tickstart;
							}
							if(typeof noteset.previousNote !== 'undefined' && noteset.previousNote.tickstart < noteset.earliestStart){
								noteset.earliestStart = noteset.previousNote.tickstart;	
							}
							if(typeof noteset.latestEnd === 'undefined' || noteset.currentNote.tickstart + noteset.currentNote.tickduration > noteset.latestEnd){
								noteset.latestEnd = noteset.currentNote.tickstart + noteset.currentNote.tickduration;
							}
							if(typeof noteset.previousNote !== 'undefined' && (typeof noteset.latestEnd === 'undefined' || noteset.previousNote.tickstart + noteset.previousNote.tickduration > noteset.latestEnd)){
								noteset.latestEnd = noteset.previousNote.tickstart + noteset.previousNote.tickduration;
							}
							group_start.setAttribute("value", noteset.earliestStart);
							group_length.setAttribute("value", noteset.latestEnd - noteset.earliestStart);

							if(typeof noteset.selectedSet[noteset.currentNote.ID] === 'undefined'){
								noteset.selectedSet[noteset.currentNote.ID] = noteset.currentNote;
								noteset.selectedCount++;
							}
							if(typeof noteset.previousNote !== 'undefined' && typeof noteset.selectedSet[noteset.previousNote.ID] === 'undefined'){
								noteset.selectedSet[noteset.previousNote.ID] = noteset.previousNote;
								noteset.selectedCount++;
							}
						}
					} else if(typeof noteset.selectedSet[noteset.currentNote.ID] === 'undefined'){
						noteset.earliestStart = noteset.currentNote.tickstart;
						noteset.latestEnd = noteset.currentNote.tickstart + noteset.currentNote.tickduration;
						for(var index in noteset.selectedSet){
							if(typeof noteset.selectedSet[index] !== 'undefined')
								drawNote(context, noteset.selectedSet[index], displaySettings);
						}

						// clear out the selected set
						noteset.selectedSet = new Array();
						noteset.selectedCount = 0;
					}
				}

				// reset preview to undefined
				preview = undefined;
				status = undefined;

				// determine if the displayed panes need to change
				showPanes();
			}

			// used to handle note property updates
			function handleNoteKeyUp()
			{
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					// keep a backup of the unchanged currently-selected note in order to erase it if needed
					var backup = new Note(noteset.currentNote);
					
					// try to change the parameters of the currently-selected note
					if(noteset.TrySetNote({tickstart: parseInt(note_start.value), tickduration: parseInt(note_length.value), autoadjust: note_autoadjust.checked})){
						// change succeeded, erase old note and draw the new one
						eraseNote(context, backup, displaySettings);
						drawSelectedNote(context, noteset.currentNote, displaySettings);
						
						// update the note in rhombus
						noteset.UpdateRhombNote(noteset.currentNote);

						// update the note properties pane with new values
						note_start.setAttribute("value", noteset.currentNote.tickstart);
						note_length.setAttribute("value", noteset.currentNote.tickduration);
					}
				}
			}

			// allow user to submit a new note start without submitting a form
			note_start.addEventListener('keyup', handleNoteKeyUp);
			note_length.addEventListener('keyup', handleNoteKeyUp);

			// used to handle group property updates
			function handleGroupKeyUp()
			{
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					// calculate how much to move everything by
					var start = parseInt(group_start.value);
					var x = start - noteset.earliestStart;
					var newLength = parseInt(group_length.value);
					var ratio = newLength / (noteset.latestEnd - noteset.earliestStart);

					// set up a new set of preview notes
					var previewSet = new Array();
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							previewSet[index] = new Note(noteset.selectedSet[index]);
						}
					}

					ResizeDurationSet(ratio, previewSet);

					noteset.earliestStart = undefined;
					noteset.latestEnd = undefined;

					// set the selected note locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							noteset.selectedSet[index].tickstart = previewSet[index].tickstart;
							noteset.selectedSet[index].tickduration = previewSet[index].tickduration;
							if(typeof noteset.earliestStart === 'undefined' || previewSet[index].tickstart < noteset.earliestStart){
								noteset.earliestStart = previewSet[index].tickstart;
							}
							if(typeof noteset.latestEnd === 'undefined' || previewSet[index].tickstart + previewSet[index].tickduration > noteset.latestEnd){
								noteset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
							}
						}
					}

					// set up a new set of preview notes
					previewSet = new Array();
					for(var index in noteset.selectedSet){
						if(typeof noteset.selectedSet[index] !== 'undefined'){
							previewSet[index] = new Note(noteset.selectedSet[index]);
						}
					}

					MoveSet(x, previewSet);

					noteset.earliestStart = undefined;
					noteset.latestEnd = undefined;

					// set the selected note locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							noteset.selectedSet[index].tickstart = previewSet[index].tickstart;
							noteset.selectedSet[index].tickduration = previewSet[index].tickduration;
							if(typeof noteset.earliestStart === 'undefined' || previewSet[index].tickstart < noteset.earliestStart){
								noteset.earliestStart = previewSet[index].tickstart;
							}
							if(typeof noteset.latestEnd === 'undefined' || previewSet[index].tickstart + previewSet[index].tickduration > noteset.latestEnd){
								noteset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
							}

							// update the note in rhombus
							noteset.UpdateRhombNote(noteset.selectedSet[index]);
						}
					}

					// update the note properties pane with new values
					group_start.setAttribute("value", noteset.earliestStart);
					group_length.setAttribute("value", noteset.latestEnd - noteset.earliestStart);
				}
			}

			// allow user to submit a new note start without submitting a form
			group_start.addEventListener('keyup', handleGroupKeyUp);
			group_length.addEventListener('keyup', handleGroupKeyUp);

			// shows different panes based on what is currently selected
			function showPanes(){
				if(noteset.selectedCount > 1){
					notepane.style.display = "none";
					trackpane.style.display = "none";
					grouppane.style.display = "block";
				}
				else if(typeof noteset.currentNote === 'undefined')
				{
					notepane.style.display = "none";
					grouppane.style.display = "none";
					trackpane.style.display = "block";
				}
				else
				{
					trackpane.style.display = "none";
					grouppane.style.display = "none";
					notepane.style.display = "block";
				}
			}

			// used to handle track property updates
			root.getElementById("release_time_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("release_time").value = input * 100;
					rhomb.setReleaseTime(input);
				}
			});
			root.getElementById("cutoff_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value);
					root.getElementById("cutoff").value = input;
					rhomb.setFilterCutoff(input);
				}
			});
			root.getElementById("resonance_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value);
					root.getElementById("resonance").value = input;
					rhomb.setFilterRes(input);
				}
			});
			root.getElementById("mod_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 10) / 10;
					root.getElementById("mod").value = input * 10;
					rhomb.setEnvDepth(input);
				}
			});
			root.getElementById("attack_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("attack").value = input * 100;
					rhomb.setAttackTime(input);
				}
			});
			root.getElementById("decay_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("decay").value = input * 100;
					rhomb.setDecayTime(input);
				}
			});
			root.getElementById("feedback_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100.0;
					root.getElementById("feedback").value = input * 100;
					rhomb.setFeedbackGain(input);
				}
			});
			root.getElementById("echo_text").addEventListener('keyup', function(){
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					var input = parseInt(event.srcElement.value * 100) / 100;
					root.getElementById("echo").value = input * 100;
					rhomb.setWetGain(input);
				}
			});

			// track property slider events
			root.getElementById("release_time").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("release_time_text").setAttribute("value", input);
				rhomb.setReleaseTime(input);
			};
			root.getElementById("cutoff").oninput = function(){
				var input = parseInt(event.srcElement.value);
				root.getElementById("cutoff_text").setAttribute("value", input);
				rhomb.setFilterCutoff(input);
			};
			root.getElementById("resonance").oninput = function(){
				var input = parseInt(event.srcElement.value);
				root.getElementById("resonance_text").setAttribute("value", input);
				rhomb.setFilterRes(input);
			};
			root.getElementById("mod").oninput = function(){
				var input = parseInt(event.srcElement.value) / 10;
				root.getElementById("mod_text").setAttribute("value", input);
				rhomb.setEnvDepth(input);
			};
			root.getElementById("attack").oninput = function(){
				var input = 0.005 + parseInt(event.srcElement.value) / 100.0;
				root.getElementById("attack_text").setAttribute("value", input);
				rhomb.setAttackTime(input);
			};
			root.getElementById("decay").oninput = function(){
				var input = 0.01 + parseInt(event.srcElement.value) / 100.0;
				root.getElementById("decay_text").setAttribute("value", input);
				rhomb.setDecayTime(input);
			};
			root.getElementById("feedback").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("feedback_text").setAttribute("value", input);
				rhomb.setFeedbackGain(input);
			};
			root.getElementById("echo").oninput = function(){
				var input = parseInt(event.srcElement.value) / 100.0;
				root.getElementById("echo_text").setAttribute("value", input);
				rhomb.setWetGain(input);
			};
			root.getElementById("echoEnabled").onchange = function(){
				rhomb.setEffectOn(event.srcElement.checked);
			}

			// moves a set of notes while previewing against the current noteset
			function MoveSet(x, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){// && previewSet[index].ID !== preview.ID){
						var prevPreview = noteset.PreviewNote(new Note(previewSet[index]));
						var temp = new Note(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Note(noteset.selectedSet[index]);
						previewSet[index].tickstart += x;
						previewSet[index] = noteset.PreviewNote(previewSet[index]);

						// noteset is a movement, so do not allow resizing
						if(temp.tickduration === previewSet[index].tickduration && previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedNote(context, previewSet[index], displaySettings);
							}
						} else {
							// if note is "stuck", make it flush with the next/previous note
							if((x + noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + noteset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedNote(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}

			// resizes a set of notes while previewing against the current noteset
			function ResizeStartSet(ratio, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){
						var prevPreview = noteset.PreviewNote(new Note(previewSet[index]));
						var temp = new Note(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Note(noteset.selectedSet[index]);
						previewSet[index].tickstart = Math.floor((previewSet[index].tickstart - noteset.latestEnd) * ratio + noteset.latestEnd);
						previewSet[index].tickduration = Math.ceil(previewSet[index].tickduration * ratio);
						previewSet[index] = noteset.PreviewNote(previewSet[index]);

						// noteset is a movement, so do not allow resizing
						if(previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedNote(context, previewSet[index], displaySettings);
							}
						} else {
							/*// if note is "stuck", make it flush with the next/previous note
							if((x + noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + noteset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}*/

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedNote(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}

			// resizes a set of notes while previewing against the current noteset
			function ResizeDurationSet(ratio, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){
						var prevPreview = noteset.PreviewNote(new Note(previewSet[index]));
						var temp = new Note(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Note(noteset.selectedSet[index]);
						previewSet[index].tickstart = Math.floor((previewSet[index].tickstart - noteset.earliestStart) * ratio + noteset.earliestStart);
						previewSet[index].tickduration = Math.ceil(previewSet[index].tickduration * ratio);
						previewSet[index] = noteset.PreviewNote(previewSet[index]);

						// noteset is a movement, so do not allow resizing
						if(previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedNote(context, previewSet[index], displaySettings);
							}
						} else {
							/*// if note is "stuck", make it flush with the next/previous note
							if((x + noteset.selectedSet[index].tickstart + noteset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + noteset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}*/

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								eraseNote(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedNote(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}
		};

		// register the element
		var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();
</script>