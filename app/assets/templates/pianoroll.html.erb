<template>
	<style>
		#pianoroll {
			position: relative;
			left: 0px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			padding: 0px;
		}
		#bgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
		#fgCanvas {
			position: absolute;
			left: 100px;
			top: 0px;
			margin: 0px;
			padding: 0px;
		}
	</style>
	<div id="pianoroll" style="" oncontextmenu="event.preventDefault(); return false;">
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
</template>
<!-- Include sorted list for the noteset -->
<script src="<%= asset_path("SortedList.js")%>"></script>

<script>
    (function(){
		// declare a persistent canvas
		var canvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var pianorollPrototype = Object.create(HTMLElement.prototype);

		// keep track of preview note
		var preview;

		// keep track of displayed notes
		var noteset = new NoteSet();

		// current cursor mode. Options: draw, select
		var mode = 'draw';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		pianorollPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			// give the noteset access to the host in order to throw events
			noteset.host = root.host;

			// get the canvas info
			canvas = root.querySelector('#bgCanvas');
			var context = canvas.getContext("2d");
			var width = canvas.getAttribute("width");
			var height = canvas.getAttribute("height");

			// fill the canvas background
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.fillStyle = "#EEEEEE";			
			context.fill();

			// draw the black key bars
			var on = true;
			var times = 0;
			for(var i = 26; i < height; i += 23){
				times++;
				if(on && times !== 7 && times !== 12){
					context.beginPath()
					context.rect(0, i, width, 23);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
					on = false;
				} else {
					on = true;
				}
				if(times === 7 || times === 12){
					context.beginPath()
					context.moveTo(0, i);
					context.lineTo(width, i);
					context.linewidth = 5;
					context.strokeStyle = "#000000";
					context.fillStyle = "#BBBBBB";
					context.fill();
					context.stroke();
				}
				if(times > 12){
					times = 1;
					//on = true;
				}
			}

			// draw the measure bars
			for(var i = 0.0; i < width; i += 40.0){
				context.beginPath();
				context.linewidth = 5;
				context.moveTo(i, 0);
				context.lineTo(i, height);
				if(i % 160 === 0.0){
					context.strokeStyle = "#000000";
				} else {
					context.strokeStyle = "#666666";
				}
				context.fill();
				context.stroke();
			}

			// outline the canvas
			context.beginPath();
			context.rect(1, 1, width-2, height-2);
			context.linewidth = 5;
			context.strokeStyle = "#000000";
			context.stroke();

			canvas = root.querySelector('#fgCanvas');
			context = canvas.getContext("2d");

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					mode = 'select';
					canvas.style.cursor = 'auto';
				}
				else if(event.charCode === 100){ // pressed 'd'
					mode = 'draw';
					canvas.style.cursor = 'cell';

					if(typeof noteset.currentNote !== 'undefined'){
						drawNote(currentNote);
					}

					noteset.currentNote = undefined;
					noteset.previousNote = undefined;
				}
			});

			document.addEventListener('denoto-selectmode', function(){
				mode = 'select';
				canvas.style.cursor = 'auto';
			});

			document.addEventListener('denoto-drawmode', function(){
				mode = 'draw';
				canvas.style.cursor = 'cell';

				if(typeof noteset.currentNote !== 'undefined'){
					drawNote(currentNote);
				}

				noteset.currentNote = undefined;
				noteset.previousNote = undefined;
			});

			document.addEventListener('keypress', function(){
				if(event.charCode === 120){
					if(typeof noteset.currentNote !== 'undefined'){
						eraseNote(context, noteset.currentNote);

						// dispatch the event so that listeners can handle it
						noteset.RemoveNote(noteset.currentNote);
						noteset.currentNote = undefined;
						noteset.previousNote = undefined;
					}
				}
			});


			canvas.addEventListener('mousedown', function(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the piano roll
				mouseY = mouseY - mouseY % 23 + 3;

				var keyValue = (mouseY - 3) / 23;
				var key = keyValue % 12;
				var color = (key === 1 || key === 3 || key === 5 || key === 8 || key === 10) ? "#6666AA" : "#AAAAFF";

				if(mode === 'select'){
					preview = noteset.SelectNote({keyValue: keyValue, tickstart: mouseX * 3});
				} else {
					preview = new Note({"keyValue": keyValue, "tickstart": mouseX * 3, "tickduration": 0, color: color});
				}
			});


			// add mouse event handling
			canvas.addEventListener('mousemove', function(){
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){
					canvas.style.cursor = 'cell';

					if(typeof preview !== 'undefined' && button === 0){
						// draw a preview rectangle
						var pageOffset = document.body.getBoundingClientRect();
						var offset = canvas.getBoundingClientRect();
						var x = event.pageX - (offset.left - pageOffset.left) - (preview.tickstart / 3);
						var direction = x === 0 ? 1 : Math.abs(x)/x;

						// save the previous state
						var prevPreview = noteset.PreviewNote(new Note(preview));

						// modify the existing preview to match the new duration, and validate
						preview.tickduration = x * 3;
						preview = noteset.PreviewNote(preview);

						// clear the old rectangle
						if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
							eraseNote(context, prevPreview);

						// draw the new rectangle
						if(typeof preview !== 'undefined' && preview.isValid){
							drawNote(context, preview);
						}
					}
				}
				else
					canvas.style.cursor = 'auto';
			});


			canvas.addEventListener('mouseup', function(){
				// if there is not an existing note to work with, do nothing
				if(typeof preview === 'undefined')
					return false;

				// unset the mousebutton for mousemove
				button = undefined;

				// don't draw anything if mouse originated outside of the canvas
				if(typeof preview === 'undefined'){
					return;
				}

				// check for right-clicks
				if(event.button === 2.0){
					// restore previous note to original appearance
					if(typeof noteset.previousNote !== 'undefined'){
						drawNote(context, noteset.previousNote);
					}

					// don't remove non-existent notes
					if (typeof noteset.currentNote !== 'undefined') {

						// remove the note
						eraseNote(context, noteset.currentNote);
						noteset.RemoveNote(noteset.currentNote);
					}

				} else if(mode === 'draw') {
					var myNote = noteset.AddNote(preview);

					if (myNote !== undefined) {
						drawNote(context, myNote);
					}
				} else if(mode === 'select') {
					// restore the old note's appearance
					if(typeof noteset.previousNote !== 'undefined'){
						drawNote(context, noteset.previousNote);
					}

					// draw the current note as selected
					if(typeof noteset.currentNote !== 'undefined'){
						drawSelectedNote(context, noteset.currentNote);
					}
				}

				// reset preview to undefined
				preview = undefined;
			});


			// reset mouse attributes when mousing out of the canvas
			canvas.addEventListener('mouseout',
				function(){
					// erase any preview rectangle
					if(typeof preview !== 'undefined')
						eraseNote(context, preview);

					preview = undefined;
				});
		};

		// register the element
		var pianoroll = document.registerElement('denoto-pianoroll', {prototype: pianorollPrototype});
})();

// represents a set of notes to be displayed
function NoteSet(){
	this.rhomb = undefined;
	this.host = undefined;
	this.currentNote = undefined;
	this.previousNote = undefined;
	this.lanes = new Array();
	for(var i = 1; i <= 24; i++){
		this.lanes[i] = new SortedList();
	}
}

// adds a note to the noteset
NoteSet.prototype.AddNote = function(note){
	// check if the note can be added
	note = this.PreviewNote(note);
	if(typeof note === 'undefined' || !note.isValid)
		return undefined;

	// assign a new ID to the note
	// TODO: fix temporary keyValue shift
	var rnote = new rhomb.Note(59 - note.keyValue, note.tickstart, note.tickduration);
	note.rnote = rnote;
	note.ID = rnote.id;

	// insert the note into the lane
	var lane = this.lanes[note.keyValue];
	lane.insertOne(note);

	// throw rhombus note creation
	var keyEvent = new CustomEvent("denoto-writenote", {"detail":{"note": rnote}});
	this.host.dispatchEvent(keyEvent);

	// return the added note (with any necessary adjustments)
	return note;
}

// adjusts an input note to make it valid (valid notes are unchanged)
NoteSet.prototype.PreviewNote = function(note){
	var lane = this.lanes[note.keyValue];

	// by default, a note is valid until proven otherwise
	note.isValid = true;

	if(note.tickduration <= 0)
		note.isValid = false;
	/*if(note.tickduration < 0){
		note.tickstart += note.tickduration;
		note.tickduration = Math.abs(note.tickduration);
	}*/
	var index = lane.bsearch(note.tickstart);
	
	// check to see if this note's beginning overlaps with other notes
	if(index !== -1 && note.isValid){
		if(lane[index].tickstart <= note.tickstart && (lane[index].tickstart + lane[index].tickduration) > note.tickstart){
			// if note is entirely within existing note, nothing to preview
			if((lane[index].tickstart + lane[index].tickduration) >= (note.tickstart + note.tickduration))
				note.isValid = false;

			// clip the beginning of the note to make it valid
			note.tickduration = (note.tickstart + note.tickduration) - (lane[index].tickstart + lane[index].tickduration);
			note.tickstart = lane[index].tickstart + lane[index].tickduration;
			if(note.tickduration <= 0)
				note.isValid = false;
		}
		
		// check to see if this note's end overlaps with other notes
		if(index+1 < lane.length){
			if(lane[index+1].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index+1].tickstart + lane[index+1].tickduration) || (note.tickstart < lane[index+1].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index+1].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		} else {
			if(lane[index].tickstart < (note.tickstart + note.tickduration) && ((note.tickstart + note.tickduration) < (lane[index].tickstart + lane[index].tickduration) || (note.tickstart < lane[index].tickstart))){
				note.tickduration -= (note.tickstart + note.tickduration) - lane[index].tickstart;
				if(note.tickduration <= 0){
					note.isValid = false;
				}
			}
		}
	}

	// make sure there are no notes between the new start and end
	if(lane.bsearch(note.tickstart) != lane.bsearch(note.tickstart + note.tickduration)){
		note.isValid = false;
	}

	// if there are no overlaps, return the original noteset
	return note;
}

// selects a note from the noteset
NoteSet.prototype.SelectNote = function(event){
	var lane = this.lanes[event.keyValue];
	var index = lane.bsearch(event);

	if(typeof lane[index] === 'undefined')
		return undefined;

	if(lane[index].tickstart <= event.tickstart && event.tickstart <= (lane[index].tickstart + lane[index].tickduration)){
		this.previousNote = this.currentNote;
		this.currentNote = lane[index];
		return lane[index];
	}

	return undefined;
}

// removes a note from the noteset
NoteSet.prototype.RemoveNote = function(note) {
	// shouldn't try to remove notes that don't exist
	if (note !== undefined) {
		// throw the rhombus note deletion
		var keyEvent = new CustomEvent("denoto-erasenote", {"detail": {"note": note.rnote}});
		this.host.dispatchEvent(keyEvent);

		// remove the note from each place it was found
		var lane = this.lanes[note.keyValue];
		var index = lane.bsearch(note);

		if(index !== -1){
			lane.remove(index);
			this.currentNote = undefined;
			this.previousNote = undefined;
		}
	}
}
// represents a single note that exists in the pianoroll
function Note(event){
	this.keyValue = event.keyValue;
	this.tickstart = event.tickstart;
	this.tickduration = event.tickduration;
	this.color = event.color;
	this.ID = undefined;
	this.rnote = undefined;
	this.isValid = event.isValid;
}
</script>
