<template>
	<!-- Pencil icon made by <a href="http://appzgear.com" title="Appzgear">Appzgear</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>. Licensed under <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0">CC BY 3.0</a> -->
	<!-- Cursor icon adapted from cursor by Gentleface.com, licensed under Creative Commons Attribution Non-commercial (by-nc) -->
	<!-- old header is slateblue -->
	<style>
		#trackview {
			background: #243544;
			position: relative;
			left: 0px;
			top: 0px;
			white-space: nowrap;
			margin: 0px;
			width: calc(100% - 450px);
			height: 610px;
			overflow: scroll;
		}
		#bgCanvas {
			position: absolute;
			left: 0px;
			top: 30px;
			margin: 0px;
			padding: 0px;
			z-index: 0;
		}
		#fgCanvas {
			position: absolute;
			left: 0px;
			top: 30px;
			margin: 0px;
			padding: 0px;
			z-index: 1;
		}
		#bgMeasurebar {
			position: fixed;
			left: 200px;
			top: 150px;
			margin: 0px;
			padding: 0px;
			z-index: 0;
		}
		#fgMeasurebar {
			position: fixed;
			left: 200px;
			top: 150px;
			margin: 0px;
			padding: 0px;
			z-index: 1;
		}
		#overlayCanvas {
			position: absolute;
			left: 0px;
			top: 0px;
			margin: 0px;
			padding: 0px;
			z-index: 2;
		}
		#tlwrapper{
			background: #172837;
			height: 620px;
			width: 200px;
			float: left;
			z-index: 2;
			position: relative;
			padding-top: 7px;
		}
		#tlcover{
			background: #172837;
			height: 30px;
			width: 200px;
			position: fixed;
			left: 0px;
			top: 150px;
			z-index: 3;
		}
		#apptracklist {
			background: #172837;
			float: left;
			position: relative;
			top: 30px;
		}
		#patternproperties {
			display: none;
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#patternpropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
		}
		#patternproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#groupproperties {
			display: none;
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
			text-align: right;
		}
		#grouppropertiesHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
		}
		#groupproperties p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
			position: relative;
			top: 5px;
		}
		#patternlist {
			display: block;
			background: #172837;
			float: right;
			width: 270px;
			height: 610px;
			left: calc(100% - 270px);
			position: fixed;
			z-index: 4;
			color: #FFFFFF;
		}
		#patternlistHeader {
			text-align: center;
			opacity: 0.9;
			position: relative;
			top: -15px;
			height: 25px;
		}
		#patternlistCaption {
			text-align: center;
			opacity: 0.9;
			width: 100%;
			font-size: 12px;
		}
		#patternlist p {
			padding-left: 10px;
			padding-right: 10px;
			opacity: 0.9;
		}
		.biggertext{
			font-family: 'Oswald';
			font-size: 20px;
			opacity: 0.85;
			color: #FFF;
		}
		.shorttextbox {
			width: 50px;
		}
		.slider {
			position: relative;
			top: 5px;
			width: 110px !important;
		}
		#footer{
			width: 100%;
			position: fixed;
			bottom: 0px;
			height: 100px;
			background: #172837;
			z-index: 3;
		}
		#footerWrapper{
			position: absolute;
			left: 200px;
			background: #243544;
			top: 10%;
			height: 80%;
			width: 100%;
		}
		#footerCanvas{
			position: absolute;
			width: 100%;
			height: 100%;
		}
		#screenposition{
			background: #FFFFFF;
			opacity: 0.1;
			position: absolute;
			top: 0px;
			height: 100%;
		}
		#tracksHeader {
			text-align: center;
			opacity: 0.9;
			position: absolute;
			width: 100%;
			top: -15px;
			height: 25px;
			color: #FFFFFF;
			opacity: 0.9;
		}
		#preload{
			display: none;
		}
	</style>
	<div id="patternproperties">
		<div id="patternpropertiesHeader"><h3>Pattern Properties</h3></div>
		<!--<p>Start <input type="text" id="pattern_start"></input></p>
		<p>Length <input type="text" id="pattern_length"></input></p>-->
		<p>Start: <denoto-editabletext type="shorttext" id="pattern_start" width="50"></denoto-editabletext></p>
		<p>Length: <denoto-editabletext type="shorttext" id="pattern_length" width="50"></denoto-editabletext></p>
		<p>Auto-adjust <input type="checkbox" id="pattern_autoadjust" checked></p>
	</div>
	<div id="groupproperties">
		<div id="grouppropertiesHeader"><h3>Group Properties</h3></div>
		<p>Start: <denoto-editabletext type="text" id="group_start" width="50"></denoto-editabletext></p>
		<p>Length: <denoto-editabletext type="text" id="group_length" width="50"></denoto-editabletext></p>
		<p>Auto-adjust <input type="checkbox" id="group_autoadjust" checked></p>
	</div>
	<div id="patternlist">
		<div id="patternlistHeader"><h3>Note Patterns</h3></div>
		<div id="patternlistCaption">Drag and drop onto desired track</div>
		<div id="patterns"></div>
	</div>
	<div id="tlcover">
		<div id="tracksHeader"><h3>Tracks</h3></div>
	</div>
	<div id="tlwrapper">
		<denoto-tracklist id="apptracklist" trackcount="0"></denoto-tracklist>
	</div>
	<div id="trackview" style="" oncontextmenu="event.preventDefault(); return false;">
		<canvas id="bgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgCanvas" width="3600" height="560" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="bgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="fgMeasurebar" width="3600" height="30" oncontextmenu="event.preventDefault(); return false;"></canvas>
		<canvas id="overlayCanvas" width="3600" height="590" oncontextmenu="event.preventDefault(); return false;"></canvas>
	</div>
	<div id="footer">
		<div id="footerWrapper">
			<canvas id="footerCanvas" width="3600" height="590" oncontextmenu="event.preventDefault(); return false;"></canvas>
			<div id="screenposition"></div>
		</div>
	</div>
	<div id="preload">
		<img src='<%= asset_path("tb_pencil_cursor.png")%>' />
		<img src='<%= asset_path("tb_cursor_auto.png")%>' />
	</div>
</template>
<!-- Include sorted list for the trackset -->
<script src="<%= asset_path("SortedList.js")%>"></script>
<script src="<%= asset_path("trackset.js")%>"></script>
<link rel="import" href="<%= asset_path("tracklist.html")%>">
<link rel="import" href="<%= asset_path("editabletext.html")%>">
<link rel="import" href="<%= asset_path("pattern.html")%>">

<script>
    (function(){
    	// keep track of display settings like ticks per pixel (AKA zoom level), and whether to show measure guides
    	var displaySettings = {TPP: 16, showguides: true, loopEnabled: false, quantization: (1920 / 16), timesig_num: 4, timesig_den: 4, snapto: false, endmarkerticks: 4 * 7680, maxmeasures: 20};

		// declare a persistent canvas
		var bgCanvas, canvas;
		var bgMeasurebar, fgMeasurebar;
		var overlayCanvas, footerCanvas;

		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var trackviewPrototype = Object.create(HTMLElement.prototype);

		// keep track of whether or not the patterns are playing
		var playing = false;

		// keep track of preview patterns
		var preview;
		var previewSet;
		var previewMarker;
		var status;

		// keep track of loop bar
		var loopbar = {start: 0, end: 1920};
		var loopbarPreview;

		// keep track of displayed patterns
		var trackset;

		// current cursor mode. Options: draw, select
		var mode = 'select';

		// set by mousedown, unset by mouseup, used in mousemove
		var button;

		// specify the created callback ("constructor")
		trackviewPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			var apptracklist = root.getElementById("apptracklist");

			// set up trackset
			trackset = new TrackSet(apptracklist.getAttribute("trackcount"));

			// give the trackset access to the host in order to throw events
			trackset.host = root.host;

			// keep track of pattern pane fields
			var patternpane = root.getElementById("patternproperties");
			var pattern_start = root.getElementById("pattern_start");
			var pattern_length = root.getElementById("pattern_length");
			var pattern_autoadjust = root.getElementById("pattern_autoadjust");

			// keep track of group pane fields
			var grouppane = root.getElementById("groupproperties");
			var group_start = root.getElementById("group_start");
			var group_length = root.getElementById("group_length");
			var group_autoadjust = root.getElementById("group_autoadjust");

			// keep track of track pane fields
			var trackpane = root.getElementById("patternlist");

			// keep track of on-screen elements
			var screenposition = root.getElementById("screenposition");
			var trackview = root.getElementById("trackview");
			bgMeasurebar = root.querySelector('#bgMeasurebar');
			fgMeasurebar = root.querySelector('#fgMeasurebar');
			overlayCanvas = root.querySelector('#overlayCanvas');
			footerCanvas = root.querySelector('#footerCanvas');
			canvas = root.querySelector('#fgCanvas');
			bgCanvas = root.querySelector('#bgCanvas');

			// keep track of contexts
			var context = canvas.getContext("2d");
			var bgContext = bgCanvas.getContext("2d");
			var overlayContext = overlayCanvas.getContext("2d");
			var footerContext = footerCanvas.getContext("2d");
			var fgMeasurebarContext = fgMeasurebar.getContext("2d");

			// resize the canvas and other elements to be the same height as the tracklist
			var tracklistHeight = parseInt(root.getElementById("apptracklist").style.height) + 5;
			setHeights(tracklistHeight);

			// draw the background canvas
			redrawEverything();

			// setup scrolling events
			setupScrolling();

			// set up top bar interface events
			setupTopbarEvents();

			var keyEvent = new CustomEvent("denoto-selectmode", {"detail": "select"});
			document.dispatchEvent(keyEvent);

			// listen for song imports
			document.addEventListener('denoto-importsong', function(){
				// preemtively set size to single-tracked
				setHeights(80);

				// add the song's patterns
				var patternDiv = root.getElementById("patterns");
				while(patternDiv.firstChild){
					patternDiv.removeChild(patternDiv.firstChild);
				}
				var patterns = rhomb._song._patterns;
				for(var key in patterns){
					var that = patterns[key];
					var pattern = document.createElement("denoto-pattern");
					pattern.setAttribute("id", that._id);
					pattern.setAttribute("value", that._name);
					pattern.setAttribute("duration", that._length);
					patternDiv.appendChild(pattern);
				}

				// add the song's tracks
				var tracks = rhomb._song._tracks;
				for(var index in tracks){
					var that = tracks[index];
					var trackEvent = new CustomEvent("denoto-addtrack", {"detail": {"index": index, "track": that}});
					document.dispatchEvent(trackEvent);
				}
			});

			document.addEventListener('denoto-addtrack', function(){
          		trackset.AddTrack(event.detail.track, event.detail.index);
			});

			document.addEventListener('denoto-setheights', function(){
				setHeights(event.detail.height);
				redrawEverything();
			});

			document.addEventListener('keypress', function(){
				if(event.charCode === 115){ // pressed 's'
					var keyEvent = new CustomEvent("denoto-selectmode", {"detail": "select"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 100){ // pressed 'd'
					var keyEvent = new CustomEvent("denoto-drawmode", {"detail": "draw"});
					document.dispatchEvent(keyEvent);
				}
				else if(event.charCode === 99){ // pressed 'c'
					console.log(trackset); // log the current trackset to the console for debugging
				}
				else if(event.charCode === 120){ // TODO: change to use the real delete key instead of 'x'
					if(typeof trackset.currentPattern !== 'undefined'){
						erasePattern(context, trackset.currentPattern, displaySettings);

						// dispatch the event so that listeners can handle it
						trackset.RemovePattern(trackset.currentPattern);
						trackset.currentPattern = undefined;
						trackset.previousPattern = undefined;
					}
					for(var index in trackset.selectedSet){
						if(typeof trackset.selectedSet[index] !== 'undefined'){
							erasePattern(context, trackset.selectedSet[index], displaySettings);
							trackset.RemovePattern(trackset.selectedSet[index]);
						}
					}
					
					// update the overview image on the footer
					footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
					footerContext.drawImage(canvas, 0, 0);
				}

				// handle if any panes need to change
				showPanes();
			});

			// listen to events thrown to this pattern editor
			root.host.addEventListener('denoto-createdpattern', function(){
				var name = event.detail.pattern._name;
				if(name == "Default Pattern Name")
					name = "[Double-click to enter pattern name]";

				trackset.pattern = event.detail.pattern;

				document.getElementById('header_name').setAttribute("value", name);
			});

			document.addEventListener('denoto-previewpattern', function(){
				preview = new Pattern(event.detail);
				button = 0;
				status = "add";

				drawPattern(context, trackset.currentPattern, displaySettings);
				trackset.currentPattern = preview;
				trackset.earliestStart = preview.tickstart;
				trackset.latestEnd = preview.tickstart + preview.tickduration;
			});

			overlayCanvas.addEventListener('dblclick', function(){
				/*root.host.ownerDocument.getElementById("apppianoroll").style.display = "block";
				root.host.ownerDocument.getElementById("apptrackview").style.display = "none";*/
			});

			// event listeners for drawing/moving/selecting/changing patterns
			overlayCanvas.addEventListener('mousedown', function(){
				// make sure focus is removed from any text fields when drawing/selecting in the canvas
				document.activeElement.blur();

				var pageOffset = document.body.getBoundingClientRect();
				var offset = bgMeasurebar.getBoundingClientRect();
				var mouseY = event.pageY - (offset.top - pageOffset.top);
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				if(mode === 'select' && isWithinRange(mouseX, (displaySettings.endmarkerticks / displaySettings.TPP), displaySettings)){
					endmarkerMousedown();
				} else {
					// handle in piano roll if below the measure bar
					if(mouseY > bgMeasurebar.getAttribute("height"))
						handleMousedown();
					else
						startLoop();
				}
			});
			document.addEventListener('mousemove', function(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = overlayCanvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				if(typeof previewMarker !== 'undefined')
					endmarkerMousemove();
				else if(typeof loopbarPreview !== 'undefined')
					previewLoop();
				else if (typeof preview !== 'undefined')
					handleMousemove();
				else if(mode === 'select' && isWithinRange(mouseX, (displaySettings.endmarkerticks / displaySettings.TPP)))
					overlayCanvas.style.cursor = 'ew-resize';
				else
					handleMousemove();
			});
			document.addEventListener('mouseup', function(){
				if(typeof previewMarker !== 'undefined')
					endmarkerMouseup();
				else if(typeof preview !== 'undefined')
					handleMouseup();
				else if(typeof loopbarPreview !== 'undefined')
					endLoop();
			});

			function render(){
				// draw the time marker on the overlay
				redrawOverlay(root, displaySettings);
				var ticks = rhomb.seconds2Ticks(rhomb.getPosition());
				drawTimeMarker(overlayContext, ticks, overlayCanvas.getAttribute("height"), displaySettings);

				var beat_ticks = Math.floor((480 * 4) / displaySettings.timesig_den);
				var measure_ticks = displaySettings.timesig_num * beat_ticks;
				var q_beat_ticks = Math.floor(beat_ticks / 4);
				var beat, q_beat;

				var measure = Math.floor(ticks / measure_ticks);
				if(measure < displaySettings.maxmeasures){
					ticks = ticks % measure_ticks;

					beat = Math.floor(ticks / beat_ticks);
					ticks = ticks % beat_ticks;

					q_beat = Math.floor(ticks / q_beat_ticks);
					ticks = ticks % q_beat_ticks;

					ticks = Math.floor(ticks);
				} else {
					beat = 0;
					q_beat = 0;
					ticks = 0;
				}

				var timeEvent = new CustomEvent("denoto-setcurrenttime", {"detail": {"measure": measure, "beat": beat, "quarter_beat": q_beat, "tick": ticks}});
				document.dispatchEvent(timeEvent);

				if(playing)
					window.requestAnimationFrame(render);
  			}

			function setHeights(height){
				height +=4;
				root.getElementById("tlwrapper").style.height = (height + 123) + "px";
				patternpane.style.height = (height + 130) + "px";
				grouppane.style.height = (height + 130) + "px";
				trackpane.style.height = (height + 130) + "px";
				trackview.style.height = (height + 50) + "px";
				canvas.setAttribute("height", height);
				bgCanvas.setAttribute("height", height);
				overlayCanvas.setAttribute("height", height + 30);
				footerCanvas.setAttribute("height", height);
				var footertop = (height + 180) < (window.innerHeight - 100) ? (height + 180) : (window.innerHeight - 100);
				root.getElementById("footer").style.top = footertop + "px";
			}

			function setWidths(width){
				canvas.setAttribute("width", width);
				bgCanvas.setAttribute("width", width);
				overlayCanvas.setAttribute("width", width);
				footerCanvas.setAttribute("width", width);
				bgMeasurebar.setAttribute("width", width);
				fgMeasurebar.setAttribute("width", width);
			}

			function resizeScrollbar(){
				screenposition.style.width = ((document.body.clientWidth - 470) * trackview.clientWidth) / trackview.scrollWidth + "px";
				footerCanvas.style.width = (document.body.clientWidth - 470) + "px";
			}

			function setupScrolling(){
				// move the screen position indicator
				var offset = canvas.getBoundingClientRect();
				screenposition.style.width = ((document.body.clientWidth - 470) * trackview.clientWidth) / trackview.scrollWidth + "px";
				screenposition.style.left = ((document.body.clientWidth - parseInt(screenposition.style.width) - 470) * (200 - offset.left)) / (trackview.scrollWidth - trackview.clientWidth) + "px";
				footerCanvas.style.width = (document.body.clientWidth - 470) + "px";

				var scrollButton = undefined;
				footerCanvas.addEventListener("mousedown", scrollPreview);
				screenposition.addEventListener("mousedown", scrollPreview);
				document.addEventListener("mousemove", function(){
					if(scrollButton === 0)
						scrollPreview();
				});
				document.addEventListener("mouseup", function(){
					scrollButton = undefined;
				});

				function scrollPreview(){
					event.preventDefault();

					// get page coordinates for the mouse that account for scrolling
					var pageOffset = document.body.getBoundingClientRect();
					var offset = footerCanvas.getBoundingClientRect();
					var mouseX = event.pageX - (offset.left - pageOffset.left);
					var coord = mouseX - (parseInt(screenposition.style.width) / 2);

					if(coord < 0)
						coord = 0;

					if(coord + screenposition.clientWidth > footerCanvas.clientWidth)
						coord = footerCanvas.clientWidth - screenposition.clientWidth;

					screenposition.style.left = coord + "px";

					trackview.scrollLeft = Math.round((trackview.scrollWidth - trackview.clientWidth) * (coord / (footerCanvas.clientWidth - screenposition.clientWidth)));
					document.body.focus();

					scrollButton = event.button;
				}

				// resize the footer when window is resized
				window.addEventListener('resize', resizeScrollbar);

				// make the measure bar scroll with the rest of the piano roll
				root.getElementById("trackview").addEventListener("scroll", function(){
					var offset = canvas.getBoundingClientRect();
					var trackview = root.getElementById("trackview");
					bgMeasurebar.style.left = offset.left + "px";
					fgMeasurebar.style.left = offset.left + "px";

					// move the screen position indicator
					screenposition.style.left = ((document.body.clientWidth - parseInt(screenposition.style.width) - 470) * (200 - offset.left)) / (trackview.scrollWidth - trackview.clientWidth) + "px";
					footerCanvas.style.width = (document.body.clientWidth - 470) + "px";
				});
			}

			function setupTopbarEvents(){
				document.addEventListener('denoto-setendtime', function(){
					var beat = Math.floor((480 * 4) / displaySettings.timesig_den);
					var measure = displaySettings.timesig_num * beat;
					var quarter_beat = beat / 4;
					var ticks = event.detail.measure * measure + event.detail.beat * beat + event.detail.quarter_beat * quarter_beat + event.detail.tick;

					displaySettings.endmarkerticks = ticks;

					redrawEverything();
				});

				document.addEventListener('denoto-setduration', function(){
					var beat = Math.floor((480 * 4) / displaySettings.timesig_den);
					var measure = displaySettings.timesig_num * beat;

					displaySettings.maxmeasures = event.detail.total_measures;

					if(displaySettings.maxmeasures < (displaySettings.endmarkerticks / measure)){
						var newend = displaySettings.maxmeasures * measure;
						displaySettings.endmarkerticks = newend;

						measure = displaySettings.maxmeasures;
						beat = 0;
						var q_beat = 0;
						var ticks = 0;

						var timeEvent = new CustomEvent("denoto-setendtime", {"detail": {"measure": measure, "beat": beat, "quarter_beat": q_beat, "tick": ticks}});
						document.dispatchEvent(timeEvent);
					}

					redrawEverything();
				});

				document.getElementById('header_name').addEventListener("keyup", function(){
					if(event.keyCode === 13){
						// handle changed name here
						trackset.pattern._name = event.srcElement.value;
					}
				});

				document.addEventListener('denoto-settimesignature', function(){
					displaySettings.timesig_num = event.detail.numerator;
					displaySettings.timesig_den = event.detail.denominator;
					
					// redraw the guiding lines, etc.
					redrawTracksCanvas(root, displaySettings);				
				});

				document.addEventListener('denoto-updatequantization', function(){
					displaySettings.quantization = 1920 / event.detail.value;
					
					// redraw the guiding lines, etc.
					redrawTracksCanvas(root, displaySettings);
				});

				document.addEventListener('denoto-snapto', function(){
					displaySettings.snapto = event.detail.snapto;
				});

				document.addEventListener('denoto-zoomin', function(){
					displaySettings.TPP = displaySettings.TPP / 2;
					if(displaySettings.TPP < 1)
						displaySettings.TPP = 1;

					redrawEverything();
				});

				document.addEventListener('denoto-zoomout', function(){
					displaySettings.TPP = displaySettings.TPP * 2;
					if(displaySettings.TPP > 16)
						displaySettings.TPP = 16;

					redrawEverything();
				});

				document.addEventListener('denoto-selectmode', function(){
					mode = 'select';
					overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
				});

				document.addEventListener('denoto-showguides', function(){
					displaySettings.showguides = event.detail.showguides;
					redrawTracksCanvas(root, displaySettings);
				});

				document.addEventListener('denoto-drawmode', function(){
					mode = 'draw';
					//overlayCanvas.style.cursor = 'cell';
					overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

					drawPattern(context, trackset.currentPattern, displaySettings);

					trackset.earliestStart = undefined;
					trackset.latestEnd = undefined;
					for(var index in trackset.selectedSet){
						drawPattern(context, trackset.selectedSet[index], displaySettings);
					}
					if(trackset.selectedSet.length > 0){
						trackset.selectedSet = new Array();
					}

					trackset.currentPattern = undefined;
					trackset.previousPattern = undefined;
				});

				// update the measure bar to either show or not show the loop
				document.getElementById("transportbar").addEventListener("denoto-loopToggle",
					function(){
						displaySettings.loopEnabled = ! displaySettings.loopEnabled;

						// redraw the loop bar
						eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
						drawLoop(fgMeasurebarContext, loopbar, displaySettings);
					});

				// handle loop changes	
				document.addEventListener('denoto-updateloopstart',
					function(){
						eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
						loopbar.start = event.detail.start;
						drawLoop(fgMeasurebarContext, loopbar, displaySettings);
					});

				document.addEventListener('denoto-updateloopend',
					function(){
						eraseLoop(fgMeasurebarContext, loopbar, displaySettings);
						loopbar.end = event.detail.end;
						drawLoop(fgMeasurebarContext, loopbar, displaySettings);
					});

				// move the time marker as necessary
				document.addEventListener('denoto-play', function(){
					playing = true;
					render();
				});
				document.addEventListener('denoto-stop', function(){
					playing = false;
				});
			}

			function redrawEverything(){
				// resize any needed elements due to zooming or length changes
				var width = (displaySettings.maxmeasures * displaySettings.timesig_num * Math.floor((480 * 4) / displaySettings.timesig_den)) / displaySettings.TPP;
				setWidths(width);

				// redraw the guiding lines, etc.
				redrawTracksCanvas(root, displaySettings);

				// redraw the patterns with their new location/sizes
				redrawAllPatterns(root, trackset, displaySettings);

				// redraw the loop bar
				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// redraw the measure bar
				drawMeasureBar(root, displaySettings);

				// redraw the overlay
				redrawOverlay(root, displaySettings);

				// update the overview image on the footer
				footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
				footerContext.drawImage(canvas, 0, 0);

				// resize the scroll bar
				resizeScrollbar();
			}

			function startLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				if(!displaySettings.loopEnabled)
					return;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				loopbarPreview = {start: mouseX * displaySettings.TPP, end: 0};
				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
			}

			function previewLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// do nothing if changes are not being made
				if(typeof loopbarPreview === 'undefined')
					return;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = overlayCanvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);

				// redraw the new loop bar
				eraseLoop(fgMeasurebarContext, loopbarPreview, displaySettings);
				
				// do not allow backwards draws
				if(mouseX * displaySettings.TPP >= loopbarPreview.start){
					loopbarPreview.end = mouseX * displaySettings.TPP;
				}
				drawLoop(fgMeasurebarContext, loopbarPreview, displaySettings);

				// send events to update the top bar fields
				var keyEvent = new CustomEvent("denoto-updateloopstart", {"detail": {"start": loopbarPreview.start}});
				document.dispatchEvent(keyEvent);
				keyEvent = new CustomEvent("denoto-updateloopend", {"detail": {"end": loopbarPreview.end}});
				document.dispatchEvent(keyEvent);
			}

			function endLoop(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// do nothing if changes are not being made
				if(typeof loopbarPreview === 'undefined')
					return;

				// if the loop bar preview is valid, it is the new loop bar
				if(loopbarPreview.end > loopbarPreview.start){
					loopbar.start = loopbarPreview.start;
					loopbar.end = loopbarPreview.end;
				}

				clearMeasureBar(fgMeasurebarContext, fgMeasurebar.getAttribute("width"), fgMeasurebar.getAttribute("height"));
				drawLoop(fgMeasurebarContext, loopbar, displaySettings);

				// dispatch an event that the loop has changed
				var keyEvent = new CustomEvent("denoto-updateloopstart", {"detail": {"start": loopbar.start}});
				root.host.dispatchEvent(keyEvent);
				document.dispatchEvent(keyEvent);
				keyEvent = new CustomEvent("denoto-updateloopend", {"detail": {"end": loopbar.end}});
				root.host.dispatchEvent(keyEvent);
				document.dispatchEvent(keyEvent);
				

				// reset the preview for the next time around
				loopbarPreview = undefined;
			}

			// handles mouse down events on the end marker
			function endmarkerMousedown(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = overlayCanvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
					var ticks = mouseX * displaySettings.TPP;

				previewMarker = mouseX;

				drawEndmarker(root, displaySettings, previewMarker * displaySettings.TPP);
				displaySettings.endmarkerticks = ticks;
			}

			// handles mouse down events on the end marker
			function endmarkerMousemove(){
				if(button === 0){
					// get page coordinates for the mouse that account for scrolling
					var pageOffset = document.body.getBoundingClientRect();
					var offset = overlayCanvas.getBoundingClientRect();
					var mouseX = event.pageX - (offset.left - pageOffset.left);
					var ticks = mouseX * displaySettings.TPP;

					previewMarker = mouseX;

					drawEndmarker(root, displaySettings, previewMarker * displaySettings.TPP);
					displaySettings.endmarkerticks = ticks;

					var beat_ticks = Math.floor((480 * 4) / displaySettings.timesig_den);
					var measure_ticks = displaySettings.timesig_num * beat_ticks;
					var q_beat_ticks = Math.floor(beat_ticks / 4);
					var beat, q_beat;

					var measure = Math.floor(ticks / measure_ticks);
					if(measure < displaySettings.maxmeasures){
						ticks = ticks % measure_ticks;

						beat = Math.floor(ticks / beat_ticks);
						ticks = ticks % beat_ticks;

						q_beat = Math.floor(ticks / q_beat_ticks);
						ticks = ticks % q_beat_ticks;
					} else {
						beat = 0;
						q_beat = 0;
						ticks = 0;
					}

					var timeEvent = new CustomEvent("denoto-setendtime", {"detail": {"measure": measure, "beat": beat, "quarter_beat": q_beat, "tick": ticks}});
					document.dispatchEvent(timeEvent);
				}
			}

			// handles mouse down events on the end marker
			function endmarkerMouseup(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = overlayCanvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var ticks = mouseX * displaySettings.TPP;

				drawEndmarker(root, displaySettings, ticks);

				displaySettings.endmarkerticks = ticks;

				var beat_ticks = Math.floor((480 * 4) / displaySettings.timesig_den);
				var measure_ticks = displaySettings.timesig_num * beat_ticks;
				var q_beat_ticks = Math.floor(beat_ticks / 4);
				var beat, q_beat;

				var measure = Math.floor(ticks / measure_ticks);
				if(measure < displaySettings.maxmeasures){
					ticks = ticks % measure_ticks;

					beat = Math.floor(ticks / beat_ticks);
					ticks = ticks % beat_ticks;

					q_beat = Math.floor(ticks / q_beat_ticks);
					ticks = ticks % q_beat_ticks;
				} else {
					beat = 0;
					q_beat = 0;
					ticks = 0;
				}

				var timeEvent = new CustomEvent("denoto-setendtime", {"detail": {"measure": measure, "beat": beat, "quarter_beat": q_beat, "tick": ticks}});
				document.dispatchEvent(timeEvent);

				// unset mouse button for mousemove events
				button = undefined;
				previewMarker = undefined;
			}

			// handles mouse down events within the canvas
			function handleMousedown(){
				// keep the i-bar "text cursor" from appearing
				event.preventDefault();

				// set mouse button for mousemove events
				button = event.button;

				// get page coordinates for the mouse that account for scrolling
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);

				// calculate effective pixel positions for the track view
				mouseY = mouseY - mouseY % 80;
				var trackIndex = mouseY / 80;

				var color = "#6666AA";
				var outlinecolor = "#000044";

				if(mode === 'select'){

					if(!event.ctrlKey && trackset.selectedCount < 2){
						drawPattern(context, trackset.currentPattern, displaySettings);
					}

					preview = trackset.SelectPattern({trackIndex: trackIndex, tickstart: mouseX * displaySettings.TPP});

					if(typeof preview === 'undefined'){
						status = undefined;
						overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';

						// deselect any patterns
						drawPattern(context, trackset.currentPattern, displaySettings);
						trackset.previousPattern = undefined;
						trackset.currentPattern = undefined;

						// deselect the selected set if the user clicked outside of it without ctrl held down
						if(!event.ctrlKey){
							// redraw the formerly-selected patterns as deselected
							for(var index in trackset.selectedSet){
								drawPattern(context, trackset.selectedSet[index], displaySettings);
							}

							// reset the selected set to be empty
							trackset.selectedSet = new Array();
							trackset.selectedCount = 0;
						}

						// clear the pattern properties in the window
						pattern_start.setAttribute("value", "");
						pattern_length.setAttribute("value", "");
					} else {
						preview = new Pattern(preview);

						// display pattern's properties in the pattern pane if it valid and not part of a group
						if(!event.ctrlKey || typeof trackset.selectedSet[preview.ID] === 'undefined'){
							if(preview.tickduration !== 0){
								// display the pattern's properties in the window
								pattern_start.setAttribute("value", preview.tickstart);
								pattern_length.setAttribute("value", preview.tickduration);
							} else {
								// don't display properties for patterns that can't exist in the trackset
								pattern_start.setAttribute("value", "");
								pattern_length.setAttribute("value", "");
							}
						}

						// deselect the selected set if the user clicked outside of it without ctrl held down
						if(!event.ctrlKey && typeof trackset.selectedSet[preview.ID] === 'undefined'){
							// redraw the formerly-selected patterns as deselected
							for(var index in trackset.selectedSet){
								drawPattern(context, trackset.selectedSet[index], displaySettings);
							}

							// reset the selected set to be empty
							trackset.selectedSet = new Array();
							trackset.selectedCount = 0;
						}

						trackset.earliestStart = undefined;
						trackset.latestEnd = undefined;

						// set up a new set of preview patterns
						previewSet = new Array();
						for(var index in trackset.selectedSet){
							if(typeof trackset.selectedSet[index] !== 'undefined'){
								previewSet[index] = new Pattern(trackset.selectedSet[index]);

								// set the earliest and latest values
								if(typeof trackset.earliestStart === 'undefined' || previewSet[index].tickstart < trackset.earliestStart){
									trackset.earliestStart = previewSet[index].tickstart;
								}
								if(typeof trackset.latestEnd === 'undefined' || (previewSet[index].tickstart + previewSet[index].tickduration) > trackset.latestEnd){
									trackset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
								}
							}
						}

						// when only a single pattern is selected, its start is the earliest start, and its end is the latest end
						if(trackset.selectedCount < 2){
							trackset.earliestStart = preview.tickstart;
							trackset.latestEnd = preview.tickstart + preview.tickduration;
						}
					}

					status = mouseDownPattern(mouseX, trackset, displaySettings);

					if(event.ctrlKey && status !== "none"){
						status = "move";
					}
					if (status === 'move' && typeof preview !== 'undefined'){

						// snap to guides if enabled
						if(displaySettings.snapto){
							var adjustment = displaySettings.quantization / displaySettings.TPP;
							mouseX = Math.round(mouseX / adjustment) * adjustment;
						}

						preview.Xoffset = mouseX - (preview.tickstart / displaySettings.TPP);
					}
				} else { // draw mode

					// snap to guides if enabled
					if(displaySettings.snapto){
						var adjustment = displaySettings.quantization / displaySettings.TPP;
						mouseX = Math.round(mouseX / adjustment) * adjustment;
					}

					var temp = trackset.GetPattern({"trackIndex": trackIndex, "tickstart": mouseX * displaySettings.TPP});
					var prev;
					if(typeof temp !== 'undefined'){
						while(typeof temp !== 'undefined'){
							prev = temp;
							temp = trackset.GetPattern({"trackIndex": trackIndex, "tickstart": temp.tickstart + temp.tickduration + 1});
						}
						preview = new Pattern({"trackIndex": trackIndex, "tickstart": prev.tickstart + prev.tickduration, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = preview.tickstart / displaySettings.TPP;
					} else {
						preview = new Pattern({"trackIndex": trackIndex, "tickstart": mouseX * displaySettings.TPP, "tickduration": 0, color: color, outlinecolor: outlinecolor});
						preview.Xoffset = mouseX;
					}
				}
				
				// handle if any panes need to change
				if(!event.ctrlKey)
					showPanes();

				// update the overview image on the footer
				footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
				footerContext.drawImage(canvas, 0, 0);
			}

			function handleMousemove(){
				var pageOffset = document.body.getBoundingClientRect();
				var offset = canvas.getBoundingClientRect();
				var mouseX = event.pageX - (offset.left - pageOffset.left);
				var mouseY = event.pageY - (offset.top - pageOffset.top);
				mouseY = mouseY - mouseY % 80;
				var trackIndex = mouseY / 80;
				
				// handle left click-and-drag based on the cursor mode
				if(mode === 'draw'){

					// snap to guides if enabled
					if(displaySettings.snapto){
						var adjustment = displaySettings.quantization / displaySettings.TPP;
						mouseX = Math.round(mouseX / adjustment) * adjustment;
					}

					overlayCanvas.style.cursor = 'url(<%= asset_path("tb_pencil_cursor.png")%>) 0 31, auto';

					if(typeof preview !== 'undefined' && button === 0){
						// draw a preview rectangle
						var x = mouseX - (preview.tickstart / displaySettings.TPP);

						// save the previous state
						var prevPreview = trackset.PreviewPattern(new Pattern(preview));

						// modify the existing preview to match the new duration, and validate
						if(x > 0 && (mouseX * displaySettings.TPP) < (preview.tickstart + preview.tickduration) && mouseX < preview.Xoffset){
							preview.tickstart += x * displaySettings.TPP;
							preview.tickduration -= x * displaySettings.TPP;
							preview = trackset.PreviewPattern(preview);
						} else if (x > 0){
							preview.tickstart = preview.Xoffset * displaySettings.TPP;
							preview.tickduration = x * displaySettings.TPP;
							preview = trackset.PreviewPattern(preview);
						} else if (x < 0){
							preview.tickduration -= x * displaySettings.TPP;
							preview.tickstart = preview.Xoffset * displaySettings.TPP - preview.tickduration;
							preview = trackset.PreviewPattern(preview);
						}

						if(preview.isValid && (preview.tickstart + preview.tickduration >= preview.Xoffset * displaySettings.TPP || preview.tickstart >= preview.Xoffset * displaySettings.TPP)){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawPattern(context, preview, displaySettings);
							}
						} else {
							preview = prevPreview;
						}
					}
				}
				else
				{
					if(typeof status === 'undefined' || (status !== "resize-duration" && status !== "resize-start" && status !== "move" && status !== "add"))
						status = mouseOverPattern(mouseX, trackset.currentPattern, displaySettings);

					if (typeof preview !== 'undefined' && status === "resize-duration"){
						overlayCanvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = mouseX - ((trackset.latestEnd) / displaySettings.TPP);
						var ratio = (trackset.latestEnd - trackset.earliestStart + x * displaySettings.TPP) / (trackset.latestEnd - trackset.earliestStart);

						// save the previous state
						var prevPreview = trackset.PreviewPattern(new Pattern(preview));

						// modify the existing preview to match the new duration, and validate
						preview.tickstart = Math.floor((trackset.currentPattern.tickstart - trackset.earliestStart) * ratio + trackset.earliestStart);
						preview.tickduration = Math.ceil(trackset.currentPattern.tickduration * ratio);

						// when modifying the duration, don't allow backwards "flips"
						if(preview.tickduration < 0)
							preview.tickduration = 0;

						// snap to guides if enabled
						if(displaySettings.snapto){
							var end = preview.tickstart + preview.tickduration;
							end = Math.round(end / displaySettings.quantization) * displaySettings.quantization;
							var delta = end - (preview.tickstart + preview.tickduration);
							preview.tickduration += delta;
						}

						preview = trackset.PreviewPattern(preview);

						// redraw the pattern if the set resize won't do it for us
						if(previewSet.length < 2){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedPattern(context, preview, displaySettings);
							}
						}

						ResizeDurationSet(ratio, previewSet);

					}
					else if (typeof preview !== 'undefined' && status === "resize-start")
					{
						overlayCanvas.style.cursor = "ew-resize";
						
						// draw a preview rectangle
						var x = ((trackset.earliestStart) / displaySettings.TPP) - mouseX;
						var ratio = (trackset.latestEnd - trackset.earliestStart + x * displaySettings.TPP) / (trackset.latestEnd - trackset.earliestStart);

						// save the previous state
						var prevPreview = trackset.PreviewPattern(new Pattern(preview));
						var temp = new Pattern(preview);

						// modify the existing preview to match the new duration, and validate
						preview.tickstart = Math.floor((trackset.currentPattern.tickstart - trackset.latestEnd) * ratio + trackset.latestEnd);
						preview.tickduration = Math.ceil(trackset.currentPattern.tickduration * ratio);

						// snap to guides if enabled
						if(displaySettings.snapto){
							var delta = preview.tickstart;
							preview.tickstart = Math.floor(preview.tickstart / displaySettings.quantization) * displaySettings.quantization;
							delta = delta - preview.tickstart;
							preview.tickduration += delta;
						}

						preview = trackset.PreviewPattern(preview);

						// for single pattern resizes, make sure that resizing hasn't changed the endpoint (this is only supposed to resize the start)
						if(trackset.selectedCount > 1 || ((temp.tickstart + temp.tickduration) === (preview.tickstart + preview.tickduration) && preview.isValid)){
							// redraw the pattern if the set resize won't do it for us
							if(previewSet.length < 2){
								// clear the old rectangle
								if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
									erasePattern(context, prevPreview, displaySettings);

								// draw the new rectangle
								if(typeof preview !== 'undefined' && preview.isValid){
									drawSelectedPattern(context, preview, displaySettings);
								}
							}
						} else {
							preview = temp;
						}

						ResizeStartSet(ratio, previewSet);
					}
					else if (typeof preview !== 'undefined' && (status === "move" || status === "add"))
					{
						overlayCanvas.style.cursor = "move";
						
						// draw a preview rectangle
						var x = mouseX - ((preview.tickstart / displaySettings.TPP) + preview.Xoffset);

						// save the previous state
						var prevPreview = trackset.PreviewPattern(new Pattern(preview));
						var temp = new Pattern(preview); 

						// modify the existing preview to match the new duration, and validate
						preview.tickstart += x * displaySettings.TPP;
						// don't let the user attempt to move a pattern outside of the tracks
						if(trackIndex >= 0 || trackIndex < trackset.tracks.length)
							preview.trackIndex = trackIndex;

						// snap to guides if enabled
						if(displaySettings.snapto){
							preview.tickstart = Math.round(preview.tickstart / displaySettings.quantization) * displaySettings.quantization;
						}

						preview = trackset.PreviewPattern(preview);

						// this is a movement, so do not allow resizing
						if(temp.tickduration === preview.tickduration && preview.isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof preview !== 'undefined' && preview.isValid){
								drawSelectedPattern(context, preview, displaySettings);
							}
						} else {
							// if pattern is "stuck", make it flush with the next/previous pattern
							if(mouseX > (preview.tickstart + preview.tickduration) / displaySettings.TPP){
								preview.tickstart = (preview.tickstart + preview.tickduration) - temp.tickduration;
								preview.tickduration = temp.tickduration;
							} else if(mouseX < preview.tickstart / displaySettings.TPP){
								preview.tickstart = preview.tickstart;
								preview.tickduration = temp.tickduration;
							}

							preview = trackset.PreviewPattern(preview);

							if(preview.isValid && preview.tickduration === temp.tickduration){
								temp.tickstart = preview.tickstart;
								temp.trackIndex = preview.trackIndex;
							}
							
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedPattern(context, temp, displaySettings);

							preview = temp;
						}

						x = preview.tickstart - trackset.currentPattern.tickstart;

						// no need to do group processing when adding a single pattern
						if(status !== "add"){
							MoveSet(x, previewSet);//, preview);

							// give initial values to the start and length properties of the group
							trackset.earliestStart = preview.tickstart;
							trackset.latestEnd = preview.tickstart + preview.tickduration;

							// update the start and length properties of the group
							for(var index in previewSet){
								if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
									if(typeof trackset.earliestStart === 'undefined' || previewSet[index].tickstart < trackset.earliestStart){
										trackset.earliestStart = previewSet[index].tickstart;
									}
									if(typeof trackset.latestEnd === 'undefined' || (previewSet[index].tickstart + previewSet[index].tickduration) > trackset.latestEnd){
										trackset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
									}
								}
							}

							// update the pattern properties pane with new values
							group_start.setAttribute("value", trackset.earliestStart);
							group_length.setAttribute("value", trackset.latestEnd - trackset.earliestStart);
						}
					}
					else
					{
						var temp = trackset.GetPattern({trackIndex: trackIndex, tickstart: (mouseX * displaySettings.TPP)});
						
						if(status !== "mouseover" && status !== "resize")
							status = mouseOverPattern(mouseX, temp, displaySettings);

						if (status === "resize")
						{
							overlayCanvas.style.cursor = "ew-resize";
						}
						else if (status === "mouseover")
						{
							overlayCanvas.style.cursor = "move";
						}
						else
						{
							overlayCanvas.style.cursor = 'url(<%= asset_path("tb_cursor_auto.png")%>) 12 3, auto';
						}
					}
				}

				// show the pattern preview's information
				if(typeof preview !== 'undefined' && preview.tickduration !== 0){
					// display the pattern's properties in the window
					root.getElementById("pattern_start").setAttribute("value", preview.tickstart);
					root.getElementById("pattern_length").setAttribute("value", preview.tickduration);
				}

				// handle if any panes need to change
				/*if(!event.ctrlKey)
					showPanes();*/
			}

			function handleMouseup(){
				// update the overview image on the footer
				footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
				footerContext.drawImage(canvas, 0, 0);

				// if there is not an existing pattern to work with, do nothing
				if(typeof preview === 'undefined'){
					status = undefined;

					// clear the pattern properties in the window
					root.getElementById("pattern_start").setAttribute("value", "");
					root.getElementById("pattern_length").setAttribute("value", "");

					// clear any multiselect if ctrl is not held down
					if(!event.ctrlKey){
						trackset.earliestStart = undefined;
						trackset.latestEnd = undefined;
						for(var index in trackset.selectedSet){
							drawPattern(context, trackset.selectedSet[index], displaySettings);
						}
						trackset.selectedSet = new Array();
						trackset.selectedCount = 0;
					}

					return false;
				} else {
					// display the pattern's properties in the window
					root.getElementById("pattern_start").setAttribute("value", preview.tickstart);
					root.getElementById("pattern_length").setAttribute("value", preview.tickduration);
				}

				// unset the mousebutton for mousemove
				button = undefined;

				// don't draw anything if mouse originated outside of the canvas
				if(typeof preview === 'undefined'){
					return;
				}

				// check for right-clicks
				if(event.button === 2.0){
					// restore previous pattern to original appearance
					drawPattern(context, trackset.previousPattern, displaySettings);

					// select the previewed pattern
					trackset.SelectPattern(preview);

					// don't remove non-existent patterns
					if (typeof trackset.currentPattern !== 'undefined') {
						// remove the pattern
						erasePattern(context, trackset.currentPattern, displaySettings);
						trackset.RemovePattern(trackset.currentPattern);
					}
					if(trackset.selectedCount == 1){
						for(var index in trackset.selectedSet){
							if(typeof trackset.selectedSet[index] !== 'undefined'){
								trackset.currentPattern = trackset.selectedSet[index];
								pattern_start.setAttribute("value", trackset.currentPattern.tickstart);
								pattern_length.setAttribute("value", trackset.currentPattern.tickduration);
							}
						}
					}

					// update the overview image on the footer
					footerContext.clearRect(0, 0, footerCanvas.width, footerCanvas.height);
					footerContext.drawImage(canvas, 0, 0);

				} else if(mode === 'draw') {
					var myPattern = trackset.AddPattern(preview);
					drawPattern(context, myPattern, displaySettings);

				} else if (status === "resize-duration" || status === "resize-start"){
					// reinitialize the start and end so they can be recalculated
					trackset.earliestStart = undefined;
					trackset.latestEnd = undefined;

					// set the selected pattern locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							if(previewSet[index].ID === trackset.currentPattern.ID){
								// set the currently-selected pattern's start and duration to their new values
								trackset.currentPattern.tickduration = preview.tickduration;
								trackset.currentPattern.tickstart = preview.tickstart;
							}

							trackset.selectedSet[index].tickstart = previewSet[index].tickstart;
							trackset.selectedSet[index].tickduration = previewSet[index].tickduration;
							drawSelectedPattern(context, trackset.selectedSet[index], displaySettings);
							trackset.UpdateRhombPattern(trackset.selectedSet[index]);

							if(typeof trackset.earliestStart === 'undefined' || trackset.selectedSet[index].tickstart < trackset.earliestStart)
								trackset.earliestStart = trackset.selectedSet[index].tickstart;
							if(typeof trackset.latestEnd === 'undefined' || (trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration) > trackset.latestEnd)
								trackset.latestEnd = trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration;
						}
					}

					// if the preview set hasn't already taken care of it, update the current pattern
					if(trackset.selectedCount < 2){
						// set the currently-selected pattern's start and duration to their new values
						trackset.currentPattern.tickduration = preview.tickduration;
						trackset.currentPattern.tickstart = preview.tickstart;
						drawSelectedPattern(context, preview, displaySettings);
					}

					// update pattern in rhombus
					trackset.UpdateRhombPattern(trackset.currentPattern);

				} else if (status === "move" || (mode === "select" && status !== "add")){
					// set the selected pattern locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined' && previewSet[index].ID !== preview.ID){
							trackset.selectedSet[index].tickstart = previewSet[index].tickstart;
						}
					}

					// set the currently-selected pattern's location to its new value
					trackset.currentPattern.tickstart = preview.tickstart;
					drawSelectedPattern(context, preview, displaySettings);

					if(typeof trackset.currentPattern !== 'undefined' && trackset.currentPattern.trackIndex !== preview.trackIndex){
						// remove and readd the pattern to get it into the correct track
						trackset.RemovePattern(trackset.currentPattern);
						trackset.AddPattern(preview);
						trackset.SelectPattern(preview);
					}
					else if(typeof trackset.currentPattern === 'undefined'){
						// add the new pattern, since it came from the palette
						trackset.AddPattern(preview);
						trackset.SelectPattern(preview);
					}
					else {
						// update the index of the current pattern in the sorted list
						trackset.AdjustIndex(trackset.currentPattern);
					}

					// update pattern in rhombus
					trackset.UpdateRhombPattern(trackset.currentPattern);

					// update the indices of the current patterns selected set and update them in rhombus
					for(var index in trackset.selectedSet){
						if(typeof trackset.selectedSet[index] !== 'undefined'){
							trackset.AdjustIndex(trackset.selectedSet[index]);
							trackset.UpdateRhombPattern(trackset.selectedSet[index]);
						}
					}
					
					if(event.ctrlKey){
						if(typeof trackset.selectedSet[trackset.currentPattern.ID] !== 'undefined'){
							trackset.selectedSet[trackset.currentPattern.ID] = undefined;
							trackset.selectedCount--;
							drawPattern(context, trackset.currentPattern, displaySettings);
							trackset.currentPattern = undefined;
							trackset.previousPattern = undefined;

							// update earliest and latest selected patterns
							trackset.earliestStart = undefined;
							trackset.latestEnd = undefined;
							if(trackset.selectedCount > 0){
								for(var index in trackset.selectedSet){
									if(typeof trackset.selectedSet[index] !== 'undefined'){
										if(typeof trackset.earliestStart === 'undefined' || trackset.selectedSet[index].tickstart < trackset.earliestStart)
											trackset.earliestStart = trackset.selectedSet[index].tickstart;
										if(typeof trackset.latestEnd === 'undefined' || trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration > trackset.latestEnd)
											trackset.latestEnd = trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration;
									}
								}
								group_start.setAttribute("value", trackset.earliestStart);
								group_length.setAttribute("value", trackset.latestEnd - trackset.earliestStart);
							}

							// if there is only a single pattern in the set, then treat as a single pattern selection
							if(trackset.selectedCount === 1){
								for(var index in trackset.selectedSet){
									if(typeof trackset.selectedSet[index] !== 'undefined'){
										trackset.SelectPattern(trackset.selectedSet[index]);
										trackset.previousPattern = undefined;
									}
								}
								pattern_start.setAttribute("value", trackset.currentPattern.tickstart);
								pattern_length.setAttribute("value", trackset.currentPattern.tickduration);
							}

						} else {
							if(typeof trackset.earliestStart === 'undefined' || trackset.currentPattern.tickstart < trackset.earliestStart){
								trackset.earliestStart = trackset.currentPattern.tickstart;
							}
							if(typeof trackset.previousPattern !== 'undefined' && trackset.previousPattern.tickstart < trackset.earliestStart){
								trackset.earliestStart = trackset.previousPattern.tickstart;	
							}
							if(typeof trackset.latestEnd === 'undefined' || trackset.currentPattern.tickstart + trackset.currentPattern.tickduration > trackset.latestEnd){
								trackset.latestEnd = trackset.currentPattern.tickstart + trackset.currentPattern.tickduration;
							}
							if(typeof trackset.previousPattern !== 'undefined' && (typeof trackset.latestEnd === 'undefined' || trackset.previousPattern.tickstart + trackset.previousPattern.tickduration > trackset.latestEnd)){
								trackset.latestEnd = trackset.previousPattern.tickstart + trackset.previousPattern.tickduration;
							}
							group_start.setAttribute("value", trackset.earliestStart);
							group_length.setAttribute("value", trackset.latestEnd - trackset.earliestStart);

							if(typeof trackset.selectedSet[trackset.currentPattern.ID] === 'undefined'){
								trackset.selectedSet[trackset.currentPattern.ID] = trackset.currentPattern;
								trackset.selectedCount++;
							}
							if(typeof trackset.previousPattern !== 'undefined' && typeof trackset.selectedSet[trackset.previousPattern.ID] === 'undefined'){
								trackset.selectedSet[trackset.previousPattern.ID] = trackset.previousPattern;
								trackset.selectedCount++;
							}
						}
					} else if(typeof trackset.selectedSet[trackset.currentPattern.ID] === 'undefined'){
						trackset.earliestStart = trackset.currentPattern.tickstart;
						trackset.latestEnd = trackset.currentPattern.tickstart + trackset.currentPattern.tickduration;
						for(var index in trackset.selectedSet){
							if(typeof trackset.selectedSet[index] !== 'undefined')
								drawPattern(context, trackset.selectedSet[index], displaySettings);
						}

						// clear out the selected set
						trackset.selectedSet = new Array();
						trackset.selectedCount = 0;
					}
				} else if (status === "add"){
					trackset.AddPattern(preview);
					drawPattern(context, preview, displaySettings);
					trackset.previousPattern = undefined;
					trackset.currentPattern = undefined;
				}

				// reset preview to undefined
				preview = undefined;
				status = undefined;

				// determine if the displayed panes need to change
				/*showPanes();*/
			}

			// used to handle pattern property updates
			function handlePatternKeyUp()
			{
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					// keep a backup of the unchanged currently-selected pattern in order to erase it if needed
					var backup = new Pattern(trackset.currentPattern);
					
					// try to change the parameters of the currently-selected pattern
					if(trackset.TrySetPattern({tickstart: parseInt(pattern_start.value), tickduration: parseInt(pattern_length.value), autoadjust: pattern_autoadjust.checked})){
						// change succeeded, erase old pattern and draw the new one
						erasePattern(context, backup, displaySettings);
						drawSelectedPattern(context, trackset.currentPattern, displaySettings);
						
						// update the pattern in rhombus
						trackset.UpdateRhombPattern(trackset.currentPattern);

						// update the pattern properties pane with new values
						pattern_start.setAttribute("value", trackset.currentPattern.tickstart);
						pattern_length.setAttribute("value", trackset.currentPattern.tickduration);
					}
				}
			}

			// allow user to submit a new pattern start without submitting a form
			pattern_start.addEventListener('keyup', handlePatternKeyUp);
			pattern_length.addEventListener('keyup', handlePatternKeyUp);

			// used to handle group property updates
			function handleGroupKeyUp()
			{
				if(event.keyCode == 13){
					// TODO: sanitize inputs
					// calculate how much to move everything by
					var start = parseInt(group_start.value);
					var x = start - trackset.earliestStart;
					var newLength = parseInt(group_length.value);
					var ratio = newLength / (trackset.latestEnd - trackset.earliestStart);

					// set up a new set of preview patterns
					var previewSet = new Array();
					for(var index in trackset.selectedSet){
						if(typeof trackset.selectedSet[index] !== 'undefined'){
							previewSet[index] = new Pattern(trackset.selectedSet[index]);
						}
					}

					ResizeDurationSet(ratio, previewSet);

					trackset.earliestStart = undefined;
					trackset.latestEnd = undefined;

					// set the selected pattern locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							trackset.selectedSet[index].tickstart = previewSet[index].tickstart;
							trackset.selectedSet[index].tickduration = previewSet[index].tickduration;
							if(typeof trackset.earliestStart === 'undefined' || previewSet[index].tickstart < trackset.earliestStart){
								trackset.earliestStart = previewSet[index].tickstart;
							}
							if(typeof trackset.latestEnd === 'undefined' || previewSet[index].tickstart + previewSet[index].tickduration > trackset.latestEnd){
								trackset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
							}
						}
					}

					// set up a new set of preview patterns
					previewSet = new Array();
					for(var index in trackset.selectedSet){
						if(typeof trackset.selectedSet[index] !== 'undefined'){
							previewSet[index] = new Pattern(trackset.selectedSet[index]);
						}
					}

					MoveSet(x, previewSet);

					trackset.earliestStart = undefined;
					trackset.latestEnd = undefined;

					// set the selected pattern locations to their new values
					for(var index in previewSet){
						if(typeof previewSet[index] !== 'undefined'){
							trackset.selectedSet[index].tickstart = previewSet[index].tickstart;
							trackset.selectedSet[index].tickduration = previewSet[index].tickduration;
							if(typeof trackset.earliestStart === 'undefined' || previewSet[index].tickstart < trackset.earliestStart){
								trackset.earliestStart = previewSet[index].tickstart;
							}
							if(typeof trackset.latestEnd === 'undefined' || previewSet[index].tickstart + previewSet[index].tickduration > trackset.latestEnd){
								trackset.latestEnd = previewSet[index].tickstart + previewSet[index].tickduration;
							}

							// update the pattern in rhombus
							trackset.UpdateRhombPattern(trackset.selectedSet[index]);
						}
					}

					// update the pattern properties pane with new values
					group_start.setAttribute("value", trackset.earliestStart);
					group_length.setAttribute("value", trackset.latestEnd - trackset.earliestStart);
				}
			}

			// allow user to submit a new pattern start without submitting a form
			group_start.addEventListener('keyup', handleGroupKeyUp);
			group_length.addEventListener('keyup', handleGroupKeyUp);

			// shows different panes based on what is currently selected
			function showPanes(){
				if(trackset.selectedCount > 1){
					patternpane.style.display = "none";
					trackpane.style.display = "none";
					grouppane.style.display = "block";
				}
				else if(typeof trackset.currentPattern === 'undefined')
				{
					patternpane.style.display = "none";
					grouppane.style.display = "none";
					trackpane.style.display = "block";
				}
				else
				{
					trackpane.style.display = "none";
					grouppane.style.display = "none";
					patternpane.style.display = "block";
				}
			}

			// moves a set of patterns while previewing against the current trackset
			function MoveSet(x, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){// && previewSet[index].ID !== preview.ID){
						var prevPreview = trackset.PreviewPattern(new Pattern(previewSet[index]));
						var temp = new Pattern(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Pattern(trackset.selectedSet[index]);
						previewSet[index].tickstart += x;
						previewSet[index] = trackset.PreviewPattern(previewSet[index]);

						// trackset is a movement, so do not allow resizing
						if(temp.tickduration === previewSet[index].tickduration && previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedPattern(context, previewSet[index], displaySettings);
							}
						} else {
							// if pattern is "stuck", make it flush with the next/previous pattern
							if((x + trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								previewSet[index].tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
								previewSet[index].tickduration = temp.tickduration;
							} else if((x + trackset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								previewSet[index].tickstart = previewSet[index].tickstart;
								previewSet[index].tickduration = temp.tickduration;
							}

							previewSet[index] = trackset.PreviewPattern(previewSet[index]);

							if(previewSet[index].isValid && previewSet[index].tickduration === temp.tickduration){
								temp.tickstart = previewSet[index].tickstart;
								temp.trackIndex = previewSet[index].trackIndex;
							}

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedPattern(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}

			// resizes a set of patterns while previewing against the current trackset
			function ResizeStartSet(ratio, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){
						var prevPreview = trackset.PreviewPattern(new Pattern(previewSet[index]));
						var temp = new Pattern(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Pattern(trackset.selectedSet[index]);
						previewSet[index].tickstart = Math.floor((previewSet[index].tickstart - trackset.latestEnd) * ratio + trackset.latestEnd);
						previewSet[index].tickduration = Math.ceil(previewSet[index].tickduration * ratio);

						// snap to guides if enabled
						if(displaySettings.snapto){
							// resize start
							var delta = previewSet[index].tickstart;
							previewSet[index].tickstart = Math.floor(previewSet[index].tickstart / displaySettings.quantization) * displaySettings.quantization;
							delta = delta - previewSet[index].tickstart;
							previewSet[index].tickduration += delta;

							// resize duration
							var end = previewSet[index].tickstart + previewSet[index].tickduration;
							end = Math.round(end / displaySettings.quantization) * displaySettings.quantization;
							delta = end - (previewSet[index].tickstart + previewSet[index].tickduration);
							previewSet[index].tickduration += delta;
						}

						previewSet[index] = trackset.PreviewPattern(previewSet[index]);

						// trackset is a movement, so do not allow resizing
						if(previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedPattern(context, previewSet[index], displaySettings);
							}
						} else {
							/*// if pattern is "stuck", make it flush with the next/previous pattern
							if((x + trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + trackset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}*/

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedPattern(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}

			// resizes a set of patterns while previewing against the current trackset
			function ResizeDurationSet(ratio, previewSet){
				for(var index in previewSet){
					if(typeof previewSet[index] !== 'undefined'){
						var prevPreview = trackset.PreviewPattern(new Pattern(previewSet[index]));
						var temp = new Pattern(previewSet[index]);

						// modify the existing preview to match the new duration, and validate
						previewSet[index] = new Pattern(trackset.selectedSet[index]);
						previewSet[index].tickstart = Math.floor((previewSet[index].tickstart - trackset.earliestStart) * ratio + trackset.earliestStart);
						previewSet[index].tickduration = Math.ceil(previewSet[index].tickduration * ratio);

						// snap to guides if enabled
						if(displaySettings.snapto){
							// resize duration
							var end = previewSet[index].tickstart + previewSet[index].tickduration;
							end = Math.round(end / displaySettings.quantization) * displaySettings.quantization;
							var delta = end - (previewSet[index].tickstart + previewSet[index].tickduration);
							previewSet[index].tickduration += delta;

							// resize start
							delta = previewSet[index].tickstart;
							previewSet[index].tickstart = Math.floor(previewSet[index].tickstart / displaySettings.quantization) * displaySettings.quantization;
							delta = delta - previewSet[index].tickstart;
							previewSet[index].tickduration += delta;
						}

						previewSet[index] = trackset.PreviewPattern(previewSet[index]);

						// trackset is a movement, so do not allow resizing
						if(previewSet[index].isValid){
							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							if(typeof previewSet[index] !== 'undefined' && previewSet[index].isValid){
								drawSelectedPattern(context, previewSet[index], displaySettings);
							}
						} else {
							/*// if pattern is "stuck", make it flush with the next/previous pattern
							if((x + trackset.selectedSet[index].tickstart + trackset.selectedSet[index].tickduration) > (previewSet[index].tickstart + previewSet[index].tickduration)){
								temp.tickstart = (previewSet[index].tickstart + previewSet[index].tickduration) - temp.tickduration;
							} else if((x + trackset.selectedSet[index].tickstart) < previewSet[index].tickstart){
								temp.tickstart = previewSet[index].tickstart;
							}*/

							// clear the old rectangle
							if(typeof prevPreview !== 'undefined' && prevPreview.isValid)
								erasePattern(context, prevPreview, displaySettings);

							// draw the new rectangle
							drawSelectedPattern(context, temp, displaySettings);

							previewSet[index] = temp;
						}
					}
				}
			}
		};

		// register the element
		var trackview = document.registerElement('denoto-trackview', {prototype: trackviewPrototype});
})();
</script>