<template>
	<div id="outer">
		<div id="container">
		</div>
		<canvas id="fgCanvas" width="1000px" height="500px"></canvas>
		<canvas id="bgCanvas" width="1000px" height="500px"></canvas>
	</div>
<style>	
	#outer {
		position: relative;
		width: 100%;
		height: 100%;
	}
	#bgCanvas {
		position: absolute;
		left: -8px;
		top: 0px;
		z-index: 0;
	}
	#fgCanvas {
		position: absolute;
		left: -8px;
		top: 0px;
		z-index: 1;
	}
	#container {
		position: absolute;
		left: 0px;
		top: 0px;
		width: 100%;
		height: 100%;
		z-index: 2;
	}
	.level {
		display: inline-block;
		vertical-align: middle;
	}
	.hspacer {
		display: inline-block;
		width: 50px;
	}
	.vspacer {
		display: block;
		height: 25px;
	}
	.filler {
		height: 63px;
	}
	.nodeline {
		display: block;
		margin-top: auto;
		margin-bottom: auto;
	}
	.node {
		display: inline-block;
		background: #243544;
		color: #FFFFFF;
		opacity: 0.9;
		padding: 10px;
		margin: 0px;
	}
	.node:hover {
		cursor: pointer;
	}
	.tb_button {
		-webkit-filter: invert(100%);
		opacity: 0.75;
		position: relative;
		top: -3px;
		right: -3px;
	}
	.tb_button:hover{
		opacity: 1.0;
	}
</style>
</template>
<script>
	(function(){
		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var effectsgraphPrototype = Object.create(HTMLElement.prototype);
		var baseid = 0;
		var highestlevel = 0;

		function Node(parents){
			this.id = baseid++;
			this.parents = parents;

			if(this.parents === null || typeof this.parents === 'undefined'){
				this.level = 0;
			} else {
				var level = 0;
				for(var index in this.parents){
					if(parents[index].level + 1 > level)
						level = parents[index].level + 1;

					parents[index].children.push(this);
				}
				this.level = level;
				if(level > highestlevel)
					highestlevel = level;
			}
			this.children = new Array();
		}

		effectsgraphPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			var bgCanvas = root.getElementById("bgCanvas");
			var bgContext = bgCanvas.getContext("2d");
			var fgCanvas = root.getElementById("fgCanvas");
			var fgContext = fgCanvas.getContext("2d");

			var that = this;
			this.instruments = new Array();

			var nodes = new Array();
			nodes[0] = new Node();
			nodes[1] = new Node([nodes[0]]);
			nodes[2] = new Node([nodes[0]]);
			nodes[3] = new Node([nodes[1]]);
			nodes[4] = new Node([nodes[2]]);
			nodes[5] = new Node([nodes[1]]);
			nodes[6] = new Node([nodes[2]]);
			nodes[7] = new Node([nodes[2], nodes[3]]);
			nodes[8] = new Node([nodes[1], nodes[4]]);

			var instrument = {"headid": 0, "nodeset": nodes};

			// create the divs
			var container = root.getElementById("container");
			container.innerHTML = "";
			for(var i = 0; i <= highestlevel; i++){
				var spacer = document.createElement("div");
				spacer.setAttribute("id", "spacer" + i);
				spacer.setAttribute("class", "hspacer");
				container.appendChild(spacer);

				var div = document.createElement("div");
				div.setAttribute("id", "subcontainer" + i);
				div.setAttribute("class", "level");
				container.appendChild(div);
			}

			var toprocess = new Array();
			toprocess[0] = nodes[0];
			
			// set up nodes on screen
			for(var i = 0; i < toprocess.length; i++){
				var node = toprocess[i];
				Array.prototype.push.apply(toprocess, node.children);
			}

			// sort nodes by level before adding them to the graph representation
			function compare(a, b){
				if (a.level < b.level)
					return -1;
				if (a.level > b.level)
					return 1;
				if(typeof a.parents === 'undefined')
					return -1;
				if(typeof b.parents === 'undefined')
					return 1;

				if(a.parents[0].id < b.parents[0].id)
					return -1;
				if(a.parents[0].id > b.parents[0].id)
					return 1;
				return 0;
			}

			toprocess.sort(compare);
			// for(var i = 0; i < toprocess.length; i++){
			// 	if(typeof toprocess[i].parents !== 'undefined')
			// 		toprocess[i].parents.sort(compare);
			// }
			// toprocess.sort(compare);


			for(var i = 0; i < toprocess.length; i++){
				var node = toprocess[i];

				var dest = root.getElementById("node" + node.id);
				if(dest === null){
					console.log("Adding node " + node.id + ".");
					dest = document.createElement("div");
					dest.setAttribute("class", "nodeline");
					root.getElementById("subcontainer" + node.level).appendChild(dest);

					var innerdiv = document.createElement("div");
					innerdiv.setAttribute("class", "vspacer");
					dest.appendChild(innerdiv);

					innerdiv = document.createElement("div");
					innerdiv.setAttribute("class", "node");
					innerdiv.setAttribute("id", "node" + node.id);
					innerdiv.innerText = "Effect " + node.id;

					innerdiv.addEventListener("click", function(){
						event.preventDefault();
						console.log(parseInt(event.srcElement.parentElement.id.substring(4)));
					});

					innerdiv.addEventListener("mouseover", function(){
						var id = parseInt(event.srcElement.id.substring(4));
						var node = nodes[id];

						fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));

						for(var i in node.parents){
							var parent = root.getElementById("node" + node.parents[i].id);
							var child = root.getElementById("node" + node.id);
							drawArrow(fgContext, parent, child, "#FF00FF");
						}

						for(var i in node.children){
							var parent = root.getElementById("node" + node.id);
							var child = root.getElementById("node" + node.children[i].id);
							drawArrow(fgContext, parent, child, "#00FF00");
						}

					});

					innerdiv.addEventListener("mouseout", function(){
						fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
					});

					dest.appendChild(innerdiv);

					// check to see if this node needs a filler
					// var lowestparent = 999999;
					// for(var j in node.parents){
					// 	if(node.parents[j].level < lowestparent)
					// 		lowestparent = node.parents[j].level;
					// }
					// console.log(node.level + " vs " + lowestparent);
					// if(node.level !== lowestparent + 1 && node.level !== 0){
					// 	var line = document.createElement("div");

					// 	var filler = document.createElement("div");
					// 	filler.setAttribute("class", "filler");

					// 	line.appendChild(filler);

					// 	for(var j = lowestparent + 1; j < node.level; j++){
					// 		root.getElementById("subcontainer" + j).appendChild(line);
					// 	}
					// }
				} else {
					console.log("Node " + node.id + " already existed.");
				}
			}
			
			// draw arrows from parents to children
			for(var i = 0; i < toprocess.length; i++){
				var node = toprocess[i];
				var parent = root.getElementById("node" + node.id);

				for(var index in node.children){
					var child = root.getElementById("node" + node.children[index].id);
					drawArrow(bgContext, parent, child, "#000000");
				}
			}
		};

		// register the element
		var effectsgraph = document.registerElement('denoto-effectsgraph', {prototype: effectsgraphPrototype});
	})();
</script>

<script>
// move back to graph.js as soon as we're ready to commit to git
/* JavaScript Library for drawing things in the denoto effects graph */

// draws an arrow from the exit (right side) of an ancestor to the entry (left side) of a successor
function drawArrow(context, ancestorElement, successorElement, color){
	var exit = getExitPoint(ancestorElement);
	var entry = getEntryPoint(successorElement);

	context.beginPath();
	context.moveTo(exit.x, exit.y);
	context.lineTo(entry.x, entry.y);
	context.lineWidth = 3;
	context.strokeStyle = color;
	context.stroke();
	context.closePath();

	//drawTriangle(context, entry);
}

// gets the point arrows leaving the node should start from
function getExitPoint(element){
	var rect = element.getBoundingClientRect();
	var x = rect.left + rect.width;
	var y = rect.top + Math.round(rect.height / 2);

	return {x: x, y: y};
}

// gets the point arrows entering the node should end at
function getEntryPoint(element){
	var rect = element.getBoundingClientRect();
	var x = rect.left;
	var y = rect.top + Math.round(rect.height / 2);

	return {x: x, y: y};
}

// draws a triangle at the end of the arrow
function drawTriangle(context, endpoint, color){
	context.beginPath();
	context.moveTo(endpoint.x, endpoint.y);
	context.lineTo(endpoint.x - 5, endpoint.y - 2);
	context.lineTo(endpoint.x - 5, endpoint.y + 2);
	context.lineTo(endpoint.x, endpoint.y);
	context.lineWidth = 3;
	context.fillStyle = color;
	context.fill();
	context.closePath();
}
</script>
<denoto-effectsgraph></denoto-effectsgraph>