<template>
	<div id="outer">
		<div id="container">
		</div>
		<canvas id="fgCanvas" width="1000px" height="500px"></canvas>
		<canvas id="bgCanvas" width="1000px" height="500px"></canvas>
	</div>
<style>	
	#outer {
		position: relative;
		width: 100%;
		height: 100%;
	}
	#bgCanvas {
		position: absolute;
		left: 0px;
		top: 0px;
		z-index: 0;
	}
	#fgCanvas {
		position: absolute;
		left: 0px;
		top: 0px;
		z-index: 1;
	}
	#container {
		position: absolute;
		left: 0px;
		top: 0px;
		width: 100%;
		height: 100%;
		z-index: 2;
	}
	.level {
		display: inline-block;
		vertical-align: middle;
	}
	.hspacer {
		display: inline-block;
		width: 50px;
	}
	.vspacer {
		display: block;
		height: 25px;
	}
	.filler {
		height: 63px;
	}
	.nodeline {
		display: block;
		margin-top: auto;
		margin-bottom: auto;
	}
	.node {
		display: inline-block;
		background: #243544;
		color: #FFFFFF;
		opacity: 0.9;
		padding: 10px;
		margin: 0px;
	}
	.node:hover {
		cursor: pointer;
	}
	.tb_button {
		-webkit-filter: invert(100%);
		opacity: 0.75;
		position: relative;
		top: -3px;
		right: -3px;
	}
	.tb_button:hover{
		opacity: 1.0;
	}
</style>
</template>
<script>
	(function(){
		// get the template for this element
		var template = document.currentScript.ownerDocument.querySelector('template');

		// copy a prototype from HTMLElement
		var effectsgraphPrototype = Object.create(HTMLElement.prototype);
		var baseid = 0;
		var highestlevel = 0;

		// move to container component when separating this
		var effectsgraphholder;

		function Node(parents){
			this.id = baseid++;
			this.parents = parents;

			if(this.parents === null || typeof this.parents === 'undefined'){
				this.level = 0;
			} else {
				var level = 0;
				for(var index in this.parents){
					if(parents[index].level + 1 > level)
						level = parents[index].level + 1;

					parents[index].children.push(this);
				}
				this.level = level;
				if(level > highestlevel)
					highestlevel = level;
			}
			this.children = new Array();
		}

		effectsgraphPrototype.createdCallback = function(){
			var root = this.createShadowRoot();
			root.appendChild(document.importNode(template.content, true));

			// move to container component when separating this
			effectsgraphholder = root.host;

			var bgCanvas = root.getElementById("bgCanvas");
			var bgContext = bgCanvas.getContext("2d");
			var fgCanvas = root.getElementById("fgCanvas");
			var fgContext = fgCanvas.getContext("2d");

			var that = this;
			this.instruments = new Array();

			var nodes = new Array();
			nodes[  0 ] = new Node();
			nodes[  1 ] = new Node([nodes[0]]);
			nodes[  2 ] = new Node([nodes[0]]);
			nodes[  3 ] = new Node([nodes[1]]);
			nodes[  4 ] = new Node([nodes[2]]);
			nodes[  5 ] = new Node([nodes[1]]);
			nodes[  6 ] = new Node([nodes[2]]);
			nodes[  7 ] = new Node([nodes[2], nodes[3]]);
			nodes[  8 ] = new Node([nodes[1], nodes[4]]);
			nodes[  9 ] = new Node();
			nodes[ 10 ] = new Node([nodes[9], nodes[2]]);

			var instrument = {"headid": 0, "nodeset": nodes};

			// create the divs
			var container = root.getElementById("container");
			container.innerHTML = "";
			for(var i = 0; i <= highestlevel; i++){
				var spacer = document.createElement("div");
				spacer.setAttribute("id", "spacer" + i);
				spacer.setAttribute("class", "hspacer");
				container.appendChild(spacer);

				var div = document.createElement("div");
				div.setAttribute("id", "subcontainer" + i);
				div.setAttribute("class", "level");
				container.appendChild(div);
			}

			var toprocess = new Array();
			
			// set up nodes on screen
			for(var i = 0; i < nodes.length; i++){
				var node = nodes[i];
				if(toprocess.indexOf(node) === -1)
					toprocess.push(node);
				Array.prototype.push.apply(toprocess, node.children);
			}

			// sort nodes by level before adding them to the graph representation
			function compare(a, b){
				if (a.level < b.level)
					return -1;
				if (a.level > b.level)
					return 1;
				if(a.id < b.id)
					return -1;
				if(a.id > b.id)
					return 1;
				return 0;
			}

			toprocess.sort(compare);

			for(var i = 0; i < toprocess.length; i++){
				var node = toprocess[i];

				var dest = root.getElementById("node" + node.id);
				if(dest === null){
					console.log("Adding node " + node.id + ".");
					dest = document.createElement("div");
					dest.setAttribute("class", "nodeline");
					root.getElementById("subcontainer" + node.level).appendChild(dest);

					var innerdiv = document.createElement("div");
					innerdiv.setAttribute("class", "vspacer");
					dest.appendChild(innerdiv);

					innerdiv = document.createElement("div");
					innerdiv.setAttribute("class", "node");
					innerdiv.setAttribute("id", "node" + node.id);
					innerdiv.innerText = "Effect " + node.id;

					innerdiv.addEventListener("click", function(){
						event.preventDefault();
						console.log(parseInt(event.srcElement.id.substring(4)));
					});

					innerdiv.addEventListener("mouseover", function(){
						var id = parseInt(event.srcElement.id.substring(4));
						var node = nodes[id];

						fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));

						for(var i in node.parents){
							var parent = root.getElementById("node" + node.parents[i].id);
							var child = root.getElementById("node" + node.id);
							drawArrow(fgCanvas, fgContext, parent, child, "#FF00FF");
						}

						for(var i in node.children){
							var parent = root.getElementById("node" + node.id);
							var child = root.getElementById("node" + node.children[i].id);
							drawArrow(fgCanvas, fgContext, parent, child, "#00FF00");
						}

					});

					innerdiv.addEventListener("mouseout", function(){
						fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
					});

					dest.appendChild(innerdiv);
				} else {
					console.log("Node " + node.id + " already existed.");
				}
				}
			
			// draw arrows from parents to children
			for(var i = 0; i < toprocess.length; i++){
				var node = toprocess[i];
				var parent = root.getElementById("node" + node.id);

				for(var index in node.children){
					var child = root.getElementById("node" + node.children[index].id);
					drawArrow(bgCanvas, bgContext, parent, child, "#00FF00");
				}
			}







			// move to container component when separating this
			document.addEventListener('denoto-edittrack', function(){
				if(typeof effectsgraphholder === 'undefined'){
					effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
				}
			});

			document.addEventListener('denoto-editpattern', function(){
				if(typeof effectsgraphholder === 'undefined'){
					effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
				}
			});

			document.addEventListener('denoto-editeffects', function(){
				if(typeof effectsgraphholder !== 'undefined'){
	          		document.getElementById("midi-interface").appendChild(effectsgraphholder);
	          		effectsgraphholder = undefined;
          		}

          		// do import stuff here
			});
		};

		// register the element
		var effectsgraph = document.registerElement('denoto-effectsgraph', {prototype: effectsgraphPrototype});
	})();
</script>