<link rel="import" href="<%= asset_path("nodeproperties.html")%>">
<template>
  <div id="outer">
    <div id="tlcover">
      <div id="tracksHeader"><h3>Tracks</h3></div>
    </div>
    <div id="tlwrapper">
      <denoto-tracklist id="effectstracklist" trackcount="0" hiderowcover="true"></denoto-tracklist>
    </div>
    <div id="container">
    </div>
    <canvas id="fgCanvas" width="100px" height="500px"></canvas>
    <canvas id="bgCanvas" width="100px" height="500px"></canvas>
  </div>
  <denoto-nodeproperties id="nodeproperties"></denoto-nodeproperties>
  <div id="panebackground"></div>
  </div>
  <div id="preload">
    <img id="plusimg" src='<%= asset_path("plus.png")%>' />
    <img id="ximg" src="<%= asset_path("delete_box.png")%>" />
  </div>
  <style>
    #preload{
      display: none;
    }
    #outer {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #bgCanvas {
      position: absolute;
      left: 125px;
      top: 0px;
      z-index: 0;
    }
    #fgCanvas {
      position: absolute;
      left: 125px;
      top: 0px;
      z-index: 1;
    }
    #container {
      position: absolute;
      left: 125px;
      top: 0px;
      width: calc(100% - 275px);
      height: 100%;
      z-index: 2;
      white-space: nowrap;
    }
    .filler {
      height: 63px;
    }
    .node {
      display: inline-block;
      background: #243544;
      color: #FFFFFF;
      opacity: 0.9;
      padding: 10px;
      margin: 0px;
    }
    .node:hover {
      cursor: pointer;
    }
    .tb_button {
      -webkit-filter: invert(100%);
      opacity: 0.75;
      position: relative;
      top: -3px;
      right: -3px;
    }
    .tb_button:hover{
      opacity: 1.0;
    }
    #nodeproperties {
      display: none;
      background: #172837;
      float: right;
      width: 270px;
      height: calc(100% - 155px);
      left: calc(100% - 270px);
      position: fixed;
      z-index: 6;
      color: #FFFFFF;
      text-align: right;
    }
    #panebackground {
      background: #172837;
      float: right;
      width: 270px;
      height: calc(100% - 155px);
      left: calc(100% - 270px);
      position: fixed;
      z-index: 5;
      color: #FFFFFF;
      text-align: right;
    }
    #tlwrapper{
      background: #172837;
      height: calc(100% - 155px);
      width: 125px;
      float: left;
      z-index: 4;
      position: fixed;
      padding-top: 7px;
    }
    #tlcover{
      background: #172837;
      height: 30px;
      width: 125px;
      position: fixed;
      left: 0px;
      top: 150px;
      z-index: 5;
    }
    #tracksHeader {
      text-align: center;
      opacity: 0.9;
      position: absolute;
      width: 100%;
      top: -15px;
      height: 25px;
      color: #FFFFFF;
      opacity: 0.9;
    }
    #effectsHeader {
      text-align: center;
      opacity: 0.9;
      position: relative;
      width: 100%;
      top: -15px;
      height: 25px;
      color: #FFFFFF;
      opacity: 0.9;
    }
    #effectstracklist {
      background: #172837;
      float: left;
      position: relative;
      top: 30px;
    }
  </style>
</template>
<script>
(function(){
  // get the template for this element
  var template = document.currentScript.ownerDocument.querySelector('template');

  // copy a prototype from HTMLElement
  var effectsgraphPrototype = Object.create(HTMLElement.prototype);

  // move to container component when separating this
  var effectsgraphholder;

  effectsgraphPrototype.createdCallback = function(){
    var root = this.createShadowRoot();
    root.appendChild(document.importNode(template.content, true));

    // move to container component when separating this
    effectsgraphholder = root.host;

    // move to container component when separating this
    document.addEventListener('denoto-edittrack', function(){
      if(typeof effectsgraphholder === 'undefined'){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
      }
    });

    document.addEventListener('denoto-editpattern', function(){
      if(typeof effectsgraphholder === 'undefined'){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
      }
    });

    document.addEventListener('denoto-editeffects', function(){
      if(typeof effectsgraphholder !== 'undefined'){
        document.getElementById("midi-interface").appendChild(effectsgraphholder);
        effectsgraphholder = undefined;
      }
      if (typeof rhomb !== "undefined") {
        console.log("[EffectsGraph] - disabling record");
        rhomb.setRecordEnabled(false);
        rhomb.Record.clearBuffer();
      }
    });

    document.addEventListener('click', function(){
      var nodeproperties = root.getElementById('nodeproperties');
      nodeproperties.style.display = "none";
    });
  };

  effectsgraphPrototype.attachedCallback = function(){
    var that = this;
    var root = this.shadowRoot;

    var bgCanvas = root.getElementById("bgCanvas");
    var bgContext = bgCanvas.getContext("2d");
    var fgCanvas = root.getElementById("fgCanvas");
    var fgContext = fgCanvas.getContext("2d");

    resizeCanvases();

    fgCanvas.addEventListener("drop", function(){
      var src = JSON.parse(event.dataTransfer.getData("text/plain"));
      var node = getObjById(src._id);
      var div = getDiv(node);

      var x = event.clientX + node.offsetX - fgCanvas.getBoundingClientRect().left;
      var y = event.clientY + node.offsetY - fgCanvas.getBoundingClientRect().top;

      div.style.left = x + "px";
      div.style.top = y + "px";
      node.setGraphX(x);
      node.setGraphY(y);

      // redraw the connecting lines
      drawBG();
    });

    fgCanvas.addEventListener("dragover", function(){
      event.preventDefault();
    });

    // create the instrument div
    var container = root.getElementById("container");
    container.innerHTML = "";

    var panebackground = root.getElementById("panebackground");

    var effectTypes = rhomb.effectTypes();
    var effectNames = rhomb.effectDisplayNames();
    if(typeof this.effectName === 'undefined' || this.effectName === "dist")
    	panebackground.innerHTML = "<span id='effectsHeader'><h3>Effect Types</h3></span>" + effectNames[0] + "<input type='radio' name='effecttype' id='effect_0' value=" + effectTypes[0] + " checked />";
    else
    	panebackground.innerHTML = "<span id='effectsHeader'><h3>Effect Types</h3></span>" + effectNames[0] + "<input type='radio' name='effecttype' id='effect_0' value=" + effectTypes[0] + " />";
    
    for(var i = 1; i < effectTypes.length; i++){
    	if(typeof this.effectName !== 'undefined' && this.effectName === effectTypes[i])
    		panebackground.innerHTML += "<br>" + effectNames[i] + "<input type='radio' name='effecttype' id='effect_" + i + "' value=" + effectTypes[i] + " checked />";
    	else
    		panebackground.innerHTML += "<br>" + effectNames[i] + "<input type='radio' name='effecttype' value=" + effectTypes[i] + " />";
    }

    this.radioHandler = function(){
    	var array = root.querySelectorAll('[name="effecttype"]');
    	for(var i in array){
    		if(array[i].checked) {
          console.log("[EffectsGraph] - setting that.effectName to " + array[i].value);
    			that.effectName = array[i].value;
        }
    	}
    }

    panebackground.addEventListener('click', this.radioHandler);

    // fill the tracklist component with tracks
    setupTracklist();

    this.handleAddTrack = function(){
    	rerender();
    };

    this.handleDeleteTrack = function() {
      rerender();
    };

    document.addEventListener("denoto-addtrack", this.handleAddTrack);
    document.addEventListener('denoto-deletetrack', this.handleDeleteTrack);

    // get handles to the tracks in the tracklist
    var trackElements = new Array();
    var tracks = rhomb.getSong().getTracks();
    for(var i = 0; i < tracks.length(); i++){
      var track = tracks.getObjBySlot(i);

      //var trackElement = root.getElementById("track" + track._id);
      var tracklist = root.getElementById("effectstracklist");
      var trackDiv = tracklist.shadowRoot.getElementById((track._id + ""));
      var trackElement = trackDiv.shadowRoot.getElementById("container"); // don't change any attributes of this element, treat as read only
      trackElements[track._id] = trackElement;
      

      // adapt this when tracks can route to any instrument, remember that trackElements[] members are READ ONLY, don't go messing up another component's shadowroot
      /*innerdiv.addEventListener("mouseover", function(){
      var id = parseInt(event.srcElement.id.substring(5));
      var track = tracks.getObjById(id);
      var target = track._target;

      fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));

      var parent = event.srcElement;
      var child = root.getElementById("instrument" + target);
      drawArrow(fgCanvas, fgContext, parent, child, "#243588");
      });

      innerdiv.addEventListener("mouseout", function(){
      fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
      });*/
    }
    
    // add all instrument nodes to an array
    var nodes = new Array();
    var instruments = rhomb.getSong().getInstruments();
    for(var i = 0; i < instruments.length(); i++){
      nodes.push(instruments.getObjBySlot(i));
    }

		// add all effects nodes to the array
    var effects = rhomb.getSong().getEffects();
    for(var key in effects){
    	nodes.push(effects[key]);
    }

    //console.log(nodes);

    for(var i = 0; i < nodes.length; i++){
      var node = nodes[i];

      var dest = root.getElementById("node" + node._id);
      if(dest === null){
        var nodediv = document.createElement("div");
        nodediv = document.createElement("div");
        nodediv.setAttribute("class", "node");
        nodediv.setAttribute("id", "node" + node._id);
        nodediv.setAttribute("draggable", "true");
        nodediv.style.position = "absolute";
        nodediv.style.left = node.graphX() + "px";
        nodediv.style.top = node.graphY() + "px";

        nodediv.innerText = node.displayName();

        nodediv.addEventListener("click", function(n){
          return function(){
            event.preventDefault();
            event.stopPropagation();
            var nodeproperties = root.getElementById('nodeproperties');
            nodeproperties.style.display = "block";
            nodeproperties.setAttribute("targetid", n._id);
            nodeproperties.setAttribute("targettype", "node");
          };
        }(node));

        nodediv.addEventListener("dragstart", function(n){
          return function(e){
            event.dataTransfer.setData("text/plain", JSON.stringify(n));
          }
        }(node));

        nodediv.addEventListener("mousedown", function(n, nd){
        	return function(e){
        		n.offsetX = parseInt(nd.getBoundingClientRect().left) - event.pageX;
        		n.offsetY = parseInt(nd.getBoundingClientRect().top) - event.pageY;
        	}
        }(node, nodediv));

        nodediv.addEventListener("dragover", function(){
          event.preventDefault();
        });

        nodediv.addEventListener("drop", function(){
		    	// recreate the event and send it to the canvas
		    	var e = new Event("drop");
		    	for(var key in event){
		    		e[key] = event[key];
		    	}

		    	// dispatch to the foreground canvas
		    	fgCanvas.dispatchEvent(e);
        });

        nodediv.addEventListener("mouseover", function(){
          var id = parseInt(event.srcElement.id.substring(4));
          var node = rhomb.getSong().getEffects()[id];

          // fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));

          // var parents = node.graphParents();
          // for(var i in parents){
          //   var parent = getDiv(parents[i]);
          //   var child = root.getElementById("node" + node._id);
          //   drawArrow(fgCanvas, fgContext, parent, child, "#243588");
          // }

          // var children = node.graphChildren();
          // for(var i in children){
          //   var parent = root.getElementById("node" + node._id);
          //   var child = getDiv(children[i]);
          //   drawArrow(fgCanvas, fgContext, parent, child, "#0055FF");
          // }
        });

        nodediv.addEventListener("mouseout", function(){
          fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
        });

        container.appendChild(nodediv);
      } else {
        //console.log("Node " + node.id + " already existed.");
      }
    }

    function drawBG(){
      // clear existing arrows
      bgContext.clearRect(0, 0, parseInt(bgCanvas.getAttribute("width")), parseInt(bgCanvas.getAttribute("height")));

      // draw arrows from parent nodes to child nodes
      for(var i = 0; i < nodes.length; i++){
        var node = nodes[i];
        var parent = root.getElementById("node" + node._id);
        var children = node.graphChildren();
        for(var index in children){
          var child = getDiv(children[index]);
          drawArrow(bgCanvas, bgContext, parent, child, "#CCCCCC");
        }
      }

      // draw arrows from tracks to instruments
      for(var i = 0; i < tracks.length(); i++){
        var track = tracks.getObjBySlot(i);
        var target = getObjById(track._target);

        var parent = trackElements[track._id];
        var child = getDiv(target);
        //drawArrow(bgCanvas, bgContext, parent, child, "#CCCCCC"); // use this when the connections are changeable
        drawArrow(bgCanvas, bgContext, parent, child, "#000000"); // the connections are hardwired, so render in black
      }
    }

    drawBG();

    function getObjById(id){
    	var obj = rhomb.getSong().getInstruments().getObjById(id);
    	if(typeof obj !== 'undefined')
    		return obj;
    	obj = rhomb.getSong().getEffects()[id];
    	if(typeof obj !== 'undefined')
    		return obj;
    }

    function getDiv(target){
      var result;
      if(target.isEffect() || target.isInstrument())
        result = root.getElementById("node" + target._id);
      else
        result = root.getElementById("track" + target._id);
      return result;
    }

    function resizeCanvases(){
      var width = document.body.offsetWidth;

      bgCanvas.setAttribute("width", width);
      bgCanvas.setAttribute("height", window.innerHeight - 155);
      fgCanvas.setAttribute("width", width);
      fgCanvas.setAttribute("height", window.innerHeight - 155);
    }

    function rerender(){
      if(typeof effectsgraphholder === 'undefined'){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
        //document.getElementById("midi-interface").appendChild(effectsgraphholder);

        effectsgraphholder = document.createElement('denoto-effectsgraph');
        document.getElementById("midi-interface").appendChild(effectsgraphholder);
        effectsgraphholder = undefined;
      }
    }

    function setupTracklist(){
      var tracklist = root.getElementById("effectstracklist");

      // clear any existing tracks from the tracklist
      var trackEvent = new CustomEvent('denoto-deletealltracks', {detail: undefined});
      tracklist.dispatchEvent(trackEvent);

      // add the song's tracks
      var count = 0;
      var slots = rhomb.getSong().getTracks()._slots;
      for(var index in slots) {
        var track = rhomb.getSong().getTracks().getObjBySlot(index);
        var trackEvent = new CustomEvent("denoto-addtrack", {"detail": {"index": index, "track": track}});
        tracklist.dispatchEvent(trackEvent);
      }
    }
  };

  effectsgraphPrototype.detachedCallback = function(){
  	document.removeEventListener("denoto-addtrack", this.handleAddTrack);
  	document.removeEventListener('denoto-deletetrack', this.handleDeleteTrack);
  	this.shadowRoot.querySelector('[name="effecttype"]').removeEventListener('click', this.radioHandler);
  }

  // register the element
  var effectsgraph = document.registerElement('denoto-effectsgraph', {prototype: effectsgraphPrototype});
})();
</script>