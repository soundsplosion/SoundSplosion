<link rel="import" href="<%= asset_path("nodeproperties.html")%>">
<link rel="import" href="<%= asset_path("dialog.html")%>">
<script src="<%= asset_path("menu.js")%>"></script>
<template>
  <div id="outer">
    <div id="tlcover">
      <div id="tracksHeader"><h3>Tracks</h3></div>
    </div>
    <div id="tlwrapper">
      <denoto-tracklist id="effectstracklist" trackcount="0" hiderowcover="true"></denoto-tracklist>
    </div>
    <div id="tlbg">
    </div>
    <div id="container">
    </div>
    <div id="scroller">
    </div>
    <canvas id="fgCanvas" width="800px" height="600px"></canvas>
    <canvas id="bgCanvas" width="800px" height="600px"></canvas>
    <denoto-nodeproperties id="nodeproperties"></denoto-nodeproperties>
    <div id="panebackground"></div>
  </div>
  </div>
  <div id="preload">
    <img id="plusimg" src='<%= asset_path("plus.png")%>' />
    <img id="ximg" src="<%= asset_path("delete_box.png")%>" />
  </div>
  <style>
    #preload{
      display: none;
    }
    #outer {
      position: relative;
      width: 100%;
      height: 100%;
    }
    #bgCanvas {
      position: absolute;
      left: 125px;
      top: 0px;
      z-index: 1;
    }
    #fgCanvas {
      position: absolute;
      left: 125px;
      top: 0px;
      z-index: 2;
    }
    #container {
      position: absolute;
      left: 125px;
      top: 0px;
      /*width: calc(100% - 275px);
      height: 100%;*/
      z-index: 3;
      white-space: nowrap;
    }
    #scroller {
      position: absolute;
      left: 125px;
      top: 0px;
      width: calc(100% - 275px);
      height: 100%;
      z-index: 0;
      white-space: nowrap;
    }
    .filler {
      height: 63px;
    }
    .tb_button {
      -webkit-filter: invert(100%);
      opacity: 0.75;
      position: relative;
      top: -3px;
      right: -3px;
    }
    .tb_button:hover{
      opacity: 1.0;
    }
    #nodeproperties {
      display: none;
      background: #172837;
      float: right;
      width: 270px;
      height: calc(100% - 145px);
      left: calc(100% - 270px);
      position: fixed;
      z-index: 6;
      color: #FFFFFF;
      text-align: right;
      overflow-y: scroll;
    }
    #panebackground {
      background: #172837;
      float: right;
      width: 270px;
      height: calc(100% - 145px);
      left: calc(100% - 270px);
      position: fixed;
      z-index: 5;
      color: #FFFFFF;
      text-align: right;
    }
    #tlwrapper{
      background: #172837;
      height: calc(100% - 155px);
      width: 125px;
      float: left;
      z-index: 4;
      position: relative;
      padding-top: 7px;
    }
    #tlbg{
      background: #172837;
      height: 100%;
      width: 125px;
      top: 0px;
      float: left;
      z-index: 0;
      position: fixed;
      padding-top: 7px;
    }
    #tlcover{
      background: #172837;
      height: 30px;
      width: 125px;
      position: fixed;
      left: 0px;
      top: 150px;
      z-index: 5;
    }
    .menu{
      color: #FFFFFF;
      opacity: 1.0;
      padding: 10px;
      position: absolute;
      background: #243544;
      z-index: 10;
    }
    .menuoption{
      opacity: 0.9;
      margin: 0px;
      padding: 0px;
      width: 100%;
    }
    .menuoption:hover {
      cursor: pointer;
      opacity: 1.0;
    }
    .menuheader{
      text-align: center;
      cursor: default;
    }
    .menuheader h3{
      margin: 0px;
      margin-bottom: 5px;
    }
    #tracksHeader {
      text-align: center;
      opacity: 0.9;
      position: absolute;
      width: 100%;
      top: -15px;
      height: 25px;
      color: #FFFFFF;
      opacity: 0.9;
    }
    #effectsHeader {
      text-align: center;
      opacity: 0.9;
      position: relative;
      width: 100%;
      top: -15px;
      height: 25px;
      color: #FFFFFF;
      opacity: 0.9;
    }
    #effectstracklist {
      background: #172837;
      float: left;
      position: relative;
      top: 30px;
    }
    .node {
      display: inline-block;
      background: #243544;
      color: #FFFFFF;
      opacity: 0.9;
      padding-left: 10px;
      padding-right: 10px;
      padding-top: 0px;
      padding-bottom: 0px;
      margin: 0px;
      vertical-align: middle;
      z-index: 4;
    }
    .node:hover {
      cursor: pointer;
    }
    .nodename{
      display: inline-block;
      vertical-align: middle;
      margin-top: 10px;
      margin-bottom: 10px;
    }
    .nodeinputdiv{
      display: inline-block;
      position: relative;
      width: 20px;
      left: -25px;
      height: 100%;
      padding: 0px;
      vertical-align: middle;
    }
    .nodeoutputdiv{
      display: inline-block;
      position: relative;
      width: 20px;
      right: -25px;
      height: 100%;
      padding: 0px;
      vertical-align: middle;
    }
    .connection{
      width: 20px;
      height: 20px;
      margin-left: 0px;
      margin-right: 0px;
      margin-top: 0px;
      margin-bottom: 0px;
    }
    .innerconnection{
      width: 10px;
      height: 10px;
      margin-left: 0px;
      margin-right: 0px;
      margin-top: 0px;
      margin-bottom: 0px;
    }
    .selectedNode{
      background: #6486DD;
      text-shadow: 1px 1px #444444;
    }
  </style>
</template>
<script>
(function(){
  // get the template for this element
  var template = document.currentScript.ownerDocument.querySelector('template');

  // copy a prototype from HTMLElement
  var effectsgraphPrototype = Object.create(HTMLElement.prototype);

  // move to container component when separating this
  var effectsgraphholder;

  var audiocolor = "#8888FF";
  var controlcolor = "#FF8888";
  var audiocolorFG = "#2222FF";
  var controlcolorFG = "#FF2222";

  effectsgraphPrototype.createdCallback = function(){
    var that = this;
    var root = that.createShadowRoot();
    root.appendChild(document.importNode(template.content, true));

    // move to container component when separating this
    effectsgraphholder = root.host;

    // move to container component when separating this
    document.addEventListener('denoto-edittrack', function(){
      if(typeof effectsgraphholder === 'undefined' && root.host.parentNode === document.getElementById("midi-interface")){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
      }
    });

    document.addEventListener('denoto-editpattern', function(){
      if(typeof effectsgraphholder === 'undefined' && root.host.parentNode === document.getElementById("midi-interface")){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
      }
    });

    document.addEventListener('denoto-editeffects', function(){
      rhomb.Undo._clearUndoStack();
      if(typeof effectsgraphholder !== 'undefined'){
        document.getElementById("midi-interface").appendChild(effectsgraphholder);
        effectsgraphholder = undefined;
      }
      if (typeof rhomb !== "undefined") {
        console.log("[EffectsGraph] - disabling record");
        rhomb.setRecordEnabled(false);
        rhomb.Record.clearBuffer();
      }

      var nodeproperties = root.getElementById('nodeproperties');
      nodeproperties.style.display = "none";

      // var targetId = nodeproperties.getAttribute("targetid");      
      // var nd = root.getElementById("node" + targetId);
      // if(nd !== null)
      //   nd.classList.add("selectedNode");
    });

    // move the time marker as necessary
    document.addEventListener('denoto-play', function() {
      that.rendering = true;
      render();
    });

    document.addEventListener('denoto-stop', function() {
      that.rendering = false;
    });

    document.addEventListener('rhombus-stop', function() {
      that.rendering = false;
    });

    document.addEventListener('denoto-updatestartpos', function() {
      render();
    });

    this.rendering = false;

    function render() {
      setTimeout(function() {
        if(that.rendering && rhomb.isPlaying())
          window.requestAnimationFrame(render);

        var ticks = rhomb.seconds2Ticks(rhomb.getPosition());

        // The tick value can become negative when playback loops around
        // This is to 'correct' the tick value so that the time display is more accurate
        if (ticks < 0) {
          ticks = rhomb.getLoopEnd() + ticks;
        }

        var timeEvent = new CustomEvent("denoto-setcurrenttime", {"detail": {"ticks": ticks}});
        document.dispatchEvent(timeEvent);

      }, 1000/45);
    }
  };

  effectsgraphPrototype.attachedCallback = function(){
    var that = this;
    var root = this.shadowRoot;

    var bgCanvas = root.getElementById("bgCanvas");
    var bgContext = bgCanvas.getContext("2d");
    var fgCanvas = root.getElementById("fgCanvas");
    var fgContext = fgCanvas.getContext("2d");

    this.handleRedrawEverything = function(){
      rerender();
    };

    document.addEventListener("denoto-redraweverything", this.handleRedrawEverything);

    fgCanvas.addEventListener("drop", function(){
      var dropData = event.dataTransfer.getData("text/plain");
      if (dropData === ""){
        return;
      }

      var src = JSON.parse(dropData);
      that.draggingItem = undefined;

      if(src.type === "connection"){
        // clear existing arrows if a connection is dropped on to the canvas
        fgContext.clearRect(0, 0, parseInt(bgCanvas.getAttribute("width")), parseInt(bgCanvas.getAttribute("height")));
        return;
      }

      var node = getObjById(src._id);
      var div = getDiv(node);

      var x = event.clientX + node.offsetX - fgCanvas.getBoundingClientRect().left;
      var y = event.clientY + node.offsetY - fgCanvas.getBoundingClientRect().top;

      div.style.left = x + "px";
      div.style.top = y + "px";
      node.setGraphX(x);
      node.setGraphY(y);

      // redraw the connecting lines
      drawFG(node);
      drawBG();
    });

    fgCanvas.addEventListener("dragover", function(){
      event.preventDefault();
      var x = event.clientX - fgCanvas.getBoundingClientRect().left;
      var y = event.clientY - fgCanvas.getBoundingClientRect().top;
      var pos = {x: x, y: y};
      previewArrow(pos);
      if(typeof that.draggingItem !== 'undefined' && that.draggingItem.type === 'movement'){
        var div = getDiv(that.draggingItem);
        pos.x = event.clientX - div.getBoundingClientRect().left + that.draggingItem.offsetX;
        pos.y = event.clientY - div.getBoundingClientRect().top + that.draggingItem.offsetY;
        previewFG(that.draggingItem, pos);
      }
    });

    fgCanvas.addEventListener("contextmenu", function(){
      event.preventDefault();
      var x = event.clientX - parseInt(fgCanvas.getBoundingClientRect().left);
      var y = event.clientY - parseInt(fgCanvas.getBoundingClientRect().top);
      createContextMenu({x: x-10, y: y-10}, container);
    });

    fgCanvas.addEventListener("mousedown", function(){
      event.preventDefault();
    });

    // create the instrument div
    var container = root.getElementById("container");
    container.innerHTML = "";

    // fill the tracklist component with tracks
    setupTracklist();

    this.handleKeyDown = function(){
      if (event.keyCode === 90) { // pressed 'z'
        if(event.ctrlKey){
          rhomb.Undo.doUndo();
          rerender();
        }
      }
    }

    this.handleAddTrack = function(){
      rerender();
    };

    this.handleDeleteTrack = function() {
      rerender();
    };

    this.handleEffectsClick = function(){
      var nodeproperties = root.getElementById('nodeproperties');
      nodeproperties.style.display = "none";

      // deselect all nodes
      var selectedSet = container.getElementsByClassName("selectedNode");
      for(var i = 0; i < selectedSet.length; i++){
        selectedSet[i].classList.remove("selectedNode");
      }
    };

    fgCanvas.addEventListener("click", this.handleEffectsClick);

    this.resizeCanvases = function(){
      var width = window.innerWidth - 410;
      var height = window.innerHeight - 145;

      var pos = getMinSize();
      if(pos.x > width)
        width = pos.x;
      if(pos.y > height)
        height = pos.y;

      bgCanvas.setAttribute("width", width + 210);
      bgCanvas.setAttribute("height", height);
      fgCanvas.setAttribute("width", width + 210);
      fgCanvas.setAttribute("height", height);

      var scroller = root.getElementById("scroller");
      scroller.setAttribute("width", width);
      scroller.setAttribute("height", height);
      scroller.style.width = width + "px";
      scroller.style.height = height + "px";

      var outer = root.getElementById("outer");
      outer.style.width = (width + 210) + "px";
      outer.style.height = height + "px";

      drawBG();
    };

    function getMinSize(){
      var children = container.childNodes;
      var highestX = 0;
      var highestY = 0;

      for(var i = 0; i < children.length; i++){
        var rect = children[i].getBoundingClientRect();
        var right = parseInt(rect.right);
        if(highestX < right)
          highestX = right;

        var bottom = parseInt(rect.bottom);
        if(highestY < bottom)
          highestY = bottom;
      }

      return {x: highestX, y: highestY};
    }

    this.handleScroll = function(){
      var left = window.scrollX;
      root.getElementById("tlwrapper").style.left = left + "px";
      drawBG();
    };


    this.selectNode = function(n){
      // show the node's properties
      var nodeproperties = root.getElementById('nodeproperties');
      nodeproperties.style.display = "block";
      nodeproperties.setAttribute("targetid", n._id);
      nodeproperties.setAttribute("targettype", "node");

      // deselect all other nodes
      var selectedSet = container.getElementsByClassName("selectedNode");
      for(var i = 0; i < selectedSet.length; i++){
        selectedSet[i].classList.remove("selectedNode");
      }

      // select this node
      var nd = root.getElementById("node" + n._id);
      nd.classList.add("selectedNode");
    };

    this.resizeCanvases();

    document.addEventListener("keydown", this.handleKeyDown);
    document.addEventListener("denoto-addtrack", this.handleAddTrack);
    document.addEventListener('denoto-deletetrack', this.handleDeleteTrack);
    window.addEventListener('resize', this.resizeCanvases);
    window.addEventListener("scroll", this.handleScroll);

    // get handles to the tracks in the tracklist
    var trackElements = new Array();
    var tracks = rhomb.getSong().getTracks();
    for(var i = 0; i < tracks.length(); i++){
      var track = tracks.getObjBySlot(i);

      var tracklist = root.getElementById("effectstracklist");
      var trackDiv = tracklist.shadowRoot.getElementById((track._id + ""));
      var trackElement = trackDiv.shadowRoot.getElementById("container"); // don't change any attributes of this element, treat as read only
      trackElements[track._id] = trackElement;

      var conn = document.createElement("div");
      conn.setAttribute("class", "connection");
      conn.setAttribute("id", "track" + track._id + "output0");
      conn.style.position = "absolute";
      conn.style.left = "0px";
      var top = parseInt(trackElement.getBoundingClientRect().top) - parseInt(bgCanvas.getBoundingClientRect().top) + Math.round(parseInt(trackElement.getBoundingClientRect().height) / 2) - 5;
      conn.style.top = top + "px";

      conn.addEventListener("drop", function(id, slot){
        return function(){
          event.stopPropagation();
          that.draggingItem = undefined;
          var src = JSON.parse(event.dataTransfer.getData("text/plain"));
          if(src.type === "connection" && src.direction !== "output"){
            var destination = getObjById(id);
            var source = getObjById(src.nodeId);

            if (destination.connectionExists(destination, slot, source, src.slot)) {
              rhomb.killAllNotes();
              destination.graphDisconnect(slot, source, src.slot);
            }
            else {
              destination.graphConnect(slot, source, src.slot);
            }

            // redraw the connections after making the new one
            drawBG();
          }
        };
      }(track._id, 0));

      conn.addEventListener("dragover", function(c){
        return function(){
          event.preventDefault();
          previewArrow(c);
        };
      }(conn));

      container.appendChild(conn);

      var innerconn = document.createElement("div");
      innerconn.setAttribute("class", "innerconnection");
      innerconn.style.background = controlcolorFG;
      innerconn.style.position = "absolute";
      innerconn.style.left = "0px";
      innerconn.style.top = "5px";
      innerconn.setAttribute("draggable", "true");

      innerconn.addEventListener("dragstart", function(id, slot, div){
        return function(){
          event.stopPropagation();
          var n = {nodeId: id, slot: slot, type: "connection", direction: "output"};
          that.draggingItem = {nodeId: id, slot: slot, type: "connection", divId: div.getAttribute("id"), colorFG: controlcolorFG, color: controlcolor};
          event.dataTransfer.setData("text/plain", JSON.stringify(n));
        };
      }(track._id, 0, conn));
      
      conn.appendChild(innerconn);

      // remember that trackElements[] members are READ ONLY, don't go messing up another component's shadowroot
      // add mouseover later
    }
    
    // add all instrument nodes to an array
    var nodes = new Array();
    var instruments = rhomb.getSong().getInstruments();
    for(var i = 0; i < instruments.length(); i++){
      nodes.push(instruments.getObjBySlot(i));
    }

    // add all effects nodes to the array
    var effects = rhomb.getSong().getEffects();
    for(var key in effects){
      nodes.push(effects[key]);
    }

    for(var i = 0; i < nodes.length; i++){
      var node = nodes[i];

      var dest = root.getElementById("node" + node._id);
      if(dest === null){
        createNode(node);
      } else {
        //console.log("Node " + node.id + " already existed.");
      }
    }

    function createNode(node){
      var nodediv = document.createElement("div");
      nodediv = document.createElement("div");
      nodediv.setAttribute("class", "node");
      nodediv.setAttribute("id", "node" + node._id);
      nodediv.setAttribute("draggable", "true");
      nodediv.style.position = "absolute";
      nodediv.style.left = node.graphX() + "px";
      nodediv.style.top = node.graphY() + "px";

      var inputsdiv = document.createElement("div");
      inputsdiv.setAttribute("class", "nodeinputdiv");
      nodediv.appendChild(inputsdiv);

      var span = document.createElement("div");
      span.innerText = node.displayName();
      span.setAttribute("class", "nodename");
      nodediv.appendChild(span);

      var outputsdiv = document.createElement("div");
      outputsdiv.setAttribute("class", "nodeoutputdiv");
      nodediv.appendChild(outputsdiv);

      var inputs = node.graphInputs();
      var count = 0;
      for(var k in inputs){
        var color;
        var colorFG;
        if(inputs[k].type === "audio"){
          color = audiocolor; // audio is blue
          colorFG = audiocolorFG;
        }
        else{
          color = controlcolor; // control is red
          colorFG = controlcolorFG;
        }

        var conn = document.createElement("div");
        conn.setAttribute("class", "connection");
        conn.setAttribute("id", "node" + node._id + "input" + count);

        conn.addEventListener("drop", function(id, slot){
          return function(){
            event.stopPropagation();
            that.draggingItem = undefined;
            var src = JSON.parse(event.dataTransfer.getData("text/plain"));
            if(src.type === "connection" && src.direction !== "input"){
              var destination = getObjById(id);
              var source = getObjById(src.nodeId);

              if (source.connectionExists(source, src.slot, destination, slot)) {
                rhomb.killAllNotes();
                source.graphDisconnect(src.slot, destination, slot);
              }
              else {
                source.graphConnect(src.slot, destination, slot);
              }
              var connectEvent = new CustomEvent("denoto-connectnodes");
              document.dispatchEvent(connectEvent);
              // redraw the connections after making the new one
              drawBG();
            }
          };
        }(node._id, count));

        conn.addEventListener("dragover", function(c){
          return function(){
            event.preventDefault();
            previewArrow(c);
          };
        }(conn));

        inputsdiv.appendChild(conn);

        var innerconn = document.createElement("div");
        innerconn.setAttribute("class", "innerconnection");
        innerconn.style.background = colorFG;
        innerconn.style.position = "relative";
        innerconn.style.left = "5px";
        innerconn.style.top = "5px";
        innerconn.setAttribute("draggable", "true");

        innerconn.addEventListener("dragstart", function(id, slot, div, clr, clrFG){
          return function(){
            event.stopPropagation();
            var n = {nodeId: id, slot: slot, type: "connection", direction: "input"};
            that.draggingItem = {nodeId: id, slot: slot, type: "connection", divId: div.getAttribute("id"), colorFG: clrFG, color: clr};
            event.dataTransfer.setData("text/plain", JSON.stringify(n));
          };
        }(node._id, count, conn, color, colorFG));
        
        conn.appendChild(innerconn);
        count++;
      }

      var outputs = node.graphOutputs();
      count = 0;
      for(var k in outputs){
        var color;
        var colorFG;
        if(outputs[k].type === "audio"){
          color = audiocolor; // audio is blue
          colorFG = audiocolorFG;
        }
        else{
          color = controlcolor; // control is red
          colorFG = controlcolorFG;
        }

        var conn = document.createElement("div");
        conn.setAttribute("class", "connection");
        conn.setAttribute("id", "node" + node._id + "output" + count);

        conn.addEventListener("drop", function(id, slot){
          return function(){            
            event.stopPropagation();
            that.draggingItem = undefined;
            var src = JSON.parse(event.dataTransfer.getData("text/plain"));
            if(src.type === "connection" && src.direction !== "output"){
              var destination = getObjById(id);
              var source = getObjById(src.nodeId);
              
              if (destination.connectionExists(destination, slot, source, src.slot)) {
                rhomb.killAllNotes();
                destination.graphDisconnect(slot, source, src.slot);
              }
              else {
                destination.graphConnect(slot, source, src.slot);
              }

              // redraw the connections after making the new one
              drawBG();
            }
          };
        }(node._id, count));

        conn.addEventListener("dragover", function(c){
          return function(){
            event.preventDefault();
            previewArrow(c);
          };
        }(conn));

        outputsdiv.appendChild(conn);

        var innerconn = document.createElement("div");
        innerconn.setAttribute("class", "innerconnection");
        innerconn.style.background = colorFG;
        innerconn.style.position = "relative";
        innerconn.style.left = "5px";
        innerconn.style.top = "5px";
        innerconn.setAttribute("draggable", "true");

        innerconn.addEventListener("dragstart", function(id, slot, div, clr, clrFG){
          return function(){
            event.stopPropagation();
            var n = {nodeId: id, slot: slot, type: "connection", direction: "output"};
            that.draggingItem = {nodeId: id, slot: slot, type: "connection", divId: div.getAttribute("id"), colorFG: clrFG, color: clr};
            event.dataTransfer.setData("text/plain", JSON.stringify(n));
          };
        }(node._id, count, conn, color, colorFG));
        
        conn.appendChild(innerconn);
        count++;
      }

      nodediv.addEventListener("click", function(n, nd){
        return function(){
          event.preventDefault();
          event.stopPropagation();
          // var nodeproperties = root.getElementById('nodeproperties');
          // nodeproperties.style.display = "block";
          // nodeproperties.setAttribute("targetid", n._id);
          // nodeproperties.setAttribute("targettype", "node");

          // // deselect all other nodes
          // var selectedSet = container.getElementsByClassName("selectedNode");
          // for(var i = 0; i < selectedSet.length; i++){
          //   selectedSet[i].classList.remove("selectedNode");
          // }

          // // select this node
          // nd.classList.add("selectedNode");
        };
      }(node, nodediv));

      nodediv.addEventListener("dragstart", function(n){
        return function(e){
          event.dataTransfer.setData("text/plain", JSON.stringify(n));
          that.draggingItem = n;
          that.draggingItem.type = "movement";
        }
      }(node));

      nodediv.addEventListener("mousedown", function(n, nd){
        return function(e){
          n.offsetX = parseInt(nd.getBoundingClientRect().left) - event.clientX + 10;
          n.offsetY = parseInt(nd.getBoundingClientRect().top) - event.clientY;

          // display the node's properties and highlight it
          that.selectNode(n);
        }
      }(node, nodediv));

      nodediv.addEventListener("contextmenu", function(n, nd){
        return function(){
          event.preventDefault();
          // don't delete the master node
          if(! n.isEffect() || ! n.isMaster()){
            var type = (n.isEffect()) ? "effect" : "instrument";

            var removeThisNode = (function(x){ return function(){ removeNodeFromGraph(x); root.getElementById('nodeproperties').style.display = "none"; } })(n);

            var dialogEvent = new CustomEvent("denoto-dialogbox", {"detail": {
                type: "okcancel",
                caption: "Delete " + type + "?",
                message: "This will permanently delete the " + type + " and associated parameter settings.",
                okButton: "Yes, delete it!",
                okHandler: removeThisNode,
                cancelButton: "No, keep it.",
                cancelHandler: function(){},
                inescapable: false,
                htmlNode: undefined
              }}
            );
            document.dispatchEvent(dialogEvent);
          }
        }
      }(node, nodediv));

      nodediv.addEventListener("dragover", function(){
        event.preventDefault();
        var x = event.clientX - fgCanvas.getBoundingClientRect().left;
        var y = event.clientY - fgCanvas.getBoundingClientRect().top;
        var pos = {x: x, y: y};
        previewArrow(pos);
        if(typeof that.draggingItem !== 'undefined' && that.draggingItem.type === 'movement'){
          var div = getDiv(that.draggingItem);
          pos.x = event.clientX - div.getBoundingClientRect().left + that.draggingItem.offsetX;
          pos.y = event.clientY - div.getBoundingClientRect().top + that.draggingItem.offsetY - 10;
          previewFG(that.draggingItem, pos);
        }
      });

      nodediv.addEventListener("drop", function(n){
        // recreate the event and send it to the canvas
        var e = new Event("drop");
        for(var key in event){
          e[key] = event[key];
        }

        // dispatch to the foreground canvas
        fgCanvas.dispatchEvent(e);
      });

      nodediv.addEventListener("mouseover", function(n){
        return function(){
          var id = parseInt(event.srcElement.id.substring(4));
          var effect = rhomb.getSong().getEffects()[id];

          // draw connections here
          drawFG(n);
        }
      }(node));

      nodediv.addEventListener("mouseout", function(){
        fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
      });

      container.appendChild(nodediv);
    }

    function previewArrow(dest){
      if(typeof that.draggingItem === 'undefined')
        return;

      var src = that.draggingItem;
      if(src.type === "connection"){
        // make the draw only fire on the top element to get it
        event.stopPropagation();

        // draw an arrow to the current connection point
        fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));

        if(typeof dest.x === 'undefined' || typeof dest.y === 'undefined')
          drawArrow(fgCanvas, fgContext, root.getElementById(src.divId), dest, src.colorFG);
        else
          drawArrowToPoint(fgCanvas, fgContext, root.getElementById(src.divId), {x: dest.x, y: dest.y}, src.color);
      }
    }

    function drawBG(){
      // clear existing arrows
      bgContext.clearRect(0, 0, parseInt(bgCanvas.getAttribute("width")), parseInt(bgCanvas.getAttribute("height")));

      // draw arrows from parent nodes to child nodes
      if(typeof nodes !== 'undefined'){
        for(var i = 0; i < nodes.length; i++){
          var node = nodes[i];
          
          var inputs = node.graphInputs();
          for(var k in inputs){
            var input = inputs[k];

            for(var j in input.from){
              var child = getInputDiv(node, k);
              var parent = getOutputDiv(input.from[j].node, input.from[j].slot);

              var color;
              if(input.type === "audio")
                color = audiocolor; // audio is blue
              else
                color = controlcolor; // control is red

              drawArrow(bgCanvas, bgContext, parent, child, color);
            }
          }
        }
      }
    }

    function previewFG(node, offset){
      if(typeof offset === 'undefined')
        offset = {x: 0, y: 0};

      // draw the current position in FG color
      drawFG(node);

      var inputs = node.graphInputs();
      for(var k in inputs){
        var input = inputs[k];

        for(var j in input.from){
          var child = getInputDiv(node, k);
          var parent = getOutputDiv(input.from[j].node, input.from[j].slot);

          var color;
          if(input.type === "audio")
            color = audiocolor; // audio is blue
          else
            color = controlcolor; // control is red

          drawArrow(fgCanvas, fgContext, parent, child, color, offset, undefined);
        }
      }
        
      var outputs = node.graphOutputs();
      for(var k in outputs){
        var output = outputs[k];

        for(var j in output.to){
          var child = getInputDiv(output.to[j].node, output.to[j].slot);
          var parent = getOutputDiv(node, k);

          var color;
          if(output.type === "audio")
            color = audiocolor; // audio is blue
          else
            color = controlcolor; // control is red

          drawArrow(fgCanvas, fgContext, parent, child, color, undefined, offset);
        }
      }
    }

    function drawFG(node, offset){
      if(typeof offset === 'undefined')
        offset = {x: 0, y: 0};

      // clear existing arrows
      fgContext.clearRect(0, 0, parseInt(bgCanvas.getAttribute("width")), parseInt(bgCanvas.getAttribute("height")));

      var inputs = node.graphInputs();
      for(var k in inputs){
        var input = inputs[k];

        for(var j in input.from){
          var child = getInputDiv(node, k);
          var parent = getOutputDiv(input.from[j].node, input.from[j].slot);

          var colorFG;
          if(input.type === "audio")
            colorFG = audiocolorFG; // audio is blue
          else
            colorFG = controlcolorFG; // control is red

          drawArrow(fgCanvas, fgContext, parent, child, colorFG, offset, undefined);
        }
      }
        
      var outputs = node.graphOutputs();
      for(var k in outputs){
        var output = outputs[k];

        for(var j in output.to){
          var child = getInputDiv(output.to[j].node, output.to[j].slot);
          var parent = getOutputDiv(node, k);

          var colorFG;
          if(output.type === "audio")
            colorFG = audiocolorFG; // audio is blue
          else
            colorFG = controlcolorFG; // control is red

          drawArrow(fgCanvas, fgContext, parent, child, colorFG, undefined, offset);
        }
      }
    }

    drawBG();

    function getObjById(id){
      var obj = rhomb.getSong().getInstruments().getObjById(id);
      if(typeof obj !== 'undefined')
        return obj;
      obj = rhomb.getSong().getEffects()[id];
      if(typeof obj !== 'undefined')
        return obj;
      obj = rhomb.getSong().getTracks().getObjById(id);
      if(typeof obj !== 'undefined')
        return obj;
    }

    function getDiv(target){
      var result;
      if(target.isEffect() || target.isInstrument())
        result = root.getElementById("node" + target._id);
      else
        result = root.getElementById("track" + target._id);
      return result;
    }

    function getInputDiv(target, slot){
      var result;
      if(target.isEffect() || target.isInstrument())
        result = root.getElementById("node" + target._id + "input" + slot);
      else
        result = root.getElementById("track" + target._id + "input" + slot);
      return result;
    }

    function getOutputDiv(target, slot){
      var result;
      if(typeof target.isEffect !== 'undefined' && target.isEffect() || typeof target.isInstrument !== 'undefined' && target.isInstrument())
        result = root.getElementById("node" + target._id + "output" + slot);
      else
        result = root.getElementById("track" + target._id + "output" + slot);
      return result;
    }

    function effectCreator(type, parentId){
      return function(o){
        var effectId = rhomb.addEffect(type);
        var effect = rhomb.getSong().getEffects()[effectId];

        // create a div for the effect node
        createNode(effect);
        nodes.push(effect);

        // position the div on the screen
        var div = getDiv(effect);
        var parent = root.getElementById(parentId);
        div.style.left = (parseInt(parent.style.left) + 10) + "px";
        div.style.top = (parseInt(parent.style.top) + 10) + "px";
        effect.setGraphX(parseInt(div.style.left));
        effect.setGraphY(parseInt(div.style.top));

        // display the properties of the effect and highlight it
        that.selectNode(effect);

        // redraw the background lines
        drawBG();

        // remove the menu when done
        parent.parentNode.removeChild(parent);
      };
    }

    function instrumentCreator(type, parentId, sampleSet){
      return function(o){
        var instrId = rhomb.addInstrument(type, undefined, undefined, sampleSet);
        var instr = rhomb.getSong().getInstruments().getObjById(instrId);

        // create a div for the effect node
        createNode(instr);
        nodes.push(instr);

        // position the div on the screen
        var div = getDiv(instr);
        var parent = root.getElementById(parentId);
        div.style.left = (parseInt(parent.style.left) + 10) + "px";
        div.style.top = (parseInt(parent.style.top) + 10) + "px";
        instr.setGraphX(parseInt(div.style.left));
        instr.setGraphY(parseInt(div.style.top));

        var instEvent = new CustomEvent("denoto-addgraphinstrument");
        document.dispatchEvent(instEvent);

        // display the properties of the effect and highlight it
        that.selectNode(instr);

        // redraw the background lines
        drawBG();

        // remove the menu when done
        parent.parentNode.removeChild(parent);
      };
    }

    function createEffectsMenu(pos, parent){
      var effectTypes = rhomb.effectTypes();
      var effectNames = rhomb.effectDisplayNames();
      var options = new Array();
      for(var i = 0; i < effectTypes.length; i++){
        options.push({caption: effectNames[i], id: "effect_" + effectTypes[i], click: effectCreator(effectTypes[i], "ctxmenu")}); 
      }
      
      // remove competing menu
      var instrMenu = root.getElementById("instrumentsmenu");
      if(instrMenu !== null)
      	instrMenu.parentNode.removeChild(instrMenu);

      createMenu(root, "effectsmenu", parent, options, "Insert Effect", pos, undefined);
    }

    function createInstrumentsMenu(pos, parent){
      var instrTypes = rhomb.instrumentTypes();
      var instrNames = rhomb.instrumentDisplayNames();
      var sampleSets = rhomb.sampleSets();
      var options = new Array();
      for(var i = 0; i < instrTypes.length; i++){
        options.push({caption: instrNames[i], id: "instr_" + instrTypes[i], click: instrumentCreator(instrTypes[i], "ctxmenu", sampleSets[i])}); 
      }
      
      // remove competing menu
      var effectsMenu = root.getElementById("effectsmenu");
      if(effectsMenu !== null)
      	effectsMenu.parentNode.removeChild(effectsMenu);
      
      createMenu(root, "instrumentsmenu", parent, options, "Insert Instrument", pos, undefined);
    }

    function createContextMenu(pos, parent){
      var options = new Array();
      options.push({caption: "Effects", id: "effects_option", click: function(){createSubMenu("effects_option", createEffectsMenu);} });
      options.push({caption: "Instruments", id: "instruments_option", click: function(){createSubMenu("instruments_option", createInstrumentsMenu);} });
      createMenu(root, "ctxmenu", parent, options, "Insert Graph Node", pos, undefined);
    }

    function createSubMenu(parentId, delegate){
      var parent = root.getElementById(parentId);
      if(parent !== null){
	      var rect = parent.getBoundingClientRect();
	      var pos = {x: rect.width-1, y: 30};
	      delegate(pos, parent);
    	}
    }

    function removeNodeFromGraph(node){
      // remove the div from display
      var nodeDiv = getDiv(node);
      container.removeChild(nodeDiv);

      // remove the node from the nodes list
      nodes.splice(nodes.indexOf(node), 1);

      // remove the node from rhombus (currently bugged in rhombus)
      if(node.isInstrument())
        rhomb.removeInstrument(node);
      else if(node.isEffect())
        rhomb.removeEffect(node);

      // redraw the background lines
      drawBG();

      // remove the foreground lines
      fgContext.clearRect(0, 0, parseInt(fgCanvas.getAttribute("width")), parseInt(fgCanvas.getAttribute("height")));
    }

    function rerender(){
      if(typeof effectsgraphholder === 'undefined'){
        effectsgraphholder = document.getElementById("midi-interface").removeChild(root.host);
        //document.getElementById("midi-interface").appendChild(effectsgraphholder);

        effectsgraphholder = document.createElement('denoto-effectsgraph');
        document.getElementById("midi-interface").appendChild(effectsgraphholder);
        effectsgraphholder = undefined;
      }
    }

    function setupTracklist(){
      var tracklist = root.getElementById("effectstracklist");

      // clear any existing tracks from the tracklist
      var trackEvent = new CustomEvent('denoto-deletealltracks', {detail: undefined});
      tracklist.dispatchEvent(trackEvent);

      // add the song's tracks
      var count = 0;
      var slots = rhomb.getSong().getTracks()._slots;
      for(var index in slots) {
        var track = rhomb.getSong().getTracks().getObjBySlot(index);
        var trackEvent = new CustomEvent("denoto-addtrack", {"detail": {"index": index, "track": track}});
        tracklist.dispatchEvent(trackEvent);
      }
    }

    this.resizeCanvases();

    this.rendering = true;
    if(typeof rhomb !== 'undefined' && rhomb.isPlaying())
      render();
  };

  effectsgraphPrototype.detachedCallback = function(){
    document.removeEventListener("keydown", this.handleKeyDown);
    document.removeEventListener("denoto-addtrack", this.handleAddTrack);
    document.removeEventListener('denoto-deletetrack', this.handleDeleteTrack);
    window.removeEventListener('resize', this.resizeCanvases);
    window.removeEventListener("scroll", this.handleScroll);
    document.removeEventListener("denoto-redraweverything", this.handleRedrawEverything);
    this.rendering = false;
  }

  // register the element
  var effectsgraph = document.registerElement('denoto-effectsgraph', {prototype: effectsgraphPrototype});
})();
</script>
